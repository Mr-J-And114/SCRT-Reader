### USER
我正在设计一个阅读器软件，下面是设定文档，你帮我看看有没有什么补充和修改的地方。
CRT风格阅读器软件开发项目。
简介：一个模仿20世纪80-90年代命令行终端CRT显示屏效果的阅读器，可以实现一些动画效果、播放多媒体内容，具备一定可拓展性，支持即时读取外部压缩包文件以及自定义排版等（详细功能后述），基本设定为SCP基金会同人，主要用于沉浸式阅读、文字冒险、视觉小说等领域。
目前使用Godot v4.6及对应语言开发，但开发者只是入门级别，需要AI一步一步协作完成该项目。
软件功能：
1.操作界面
1.1. 基本不使用鼠标，绝大部分交互通过键盘完成，鼠标只能进行复制粘贴、打开超链接等交互。
1.2. 命令行操作系统，通过底部输入框输入代码指令完成操作，指令集待定
1.3. 顶部有状态栏，显示该目前所在位置、文件名称，右上角有一个邮件图标，显示是否收到新邮件（剧情功能）
其它待补充
2.视听效果
2.1. CRT显示屏效果（目前已部分实现，但需要优化）
2.2. 可以让用户在设置中自行切换颜色、背景等设置
2.3. 操作过程中播放一些机械、电子声，模拟老式设备运行噪音
2.4. 考虑增加CRT效果拟真度，类似于https://github.com/Swordfish90/cool-retro-term
2.5. 每个文件打开都需要时间，通过简单的进度条加载
3.文件结构
3.1. 压缩包：将文档以及所有会使用的素材都打包在一起，并在阅读器打开后作为根目录存在。
3.2. 头文件：在每一层文件夹都含有的txt格式文件，有特殊文件后缀使其会在阅读器中隐藏；主要用于设置该层文件夹打开时所需的权限、当前文件夹密码、该层文件夹内多媒体文件的密码、文件简介描述等；可以设置触发器触发jumpscare、新邮件、升级等meta内容。
3.3. 文档文件：使用自定义TXT类markdown语言，可以让阅读器读取并生成对应格式；文档开头会有密码、模板、风格等隐藏的设置内容，但不会展示给读者；有文档、聊天记录、邮件等拥有一定动画的预设模板，并可再拓展其它模板；可以插入图片、视频、音频于文件中并可自定义排版，或者插入图片、视频、音频的超链接等内容。
3.4. 音视频文件：视频文件使用简单的播放器播放；音频播放器需要同时显示简介（存于头文件中）。
3.5. 聊天记录：类似于即时聊天软件的聊天记录文件，有一定动画效果。
3.6. 载入画面：压缩包中包含一个可以自定义的外部文件设定的加载动画，用于设置特殊的载入动画。
其它功能文件待定
4.用户及邮件系统
4.1. 初次使用会需要先注册一个新账户，包括用户名、密码等，新账户会收到一封邮件，即操作说明。
4.2. 用户系统会记录当前的权限等级（不同压缩包内的权限不通用），所获取的密码（再打开时自动解密直接阅读）内容。
4.3. 邮件系统：邮件本质上是一份特殊的文档文件，格式为邮件格式，平时为隐藏状态，触发邮件事件后一段时间（可自定）即收到邮件，邮件记录由用户系统收录，用户只能收邮件。

### ASSISTANT
# CRT风格阅读器软件设定文档——审阅与补充建议

你的设定文档整体框架已经相当完善，项目概念非常有创意——将SCP基金会的世界观与CRT终端风格结合，用于沉浸式阅读和文字冒险，这是一个很有潜力的方向。下面我从多个维度给出详细的补充和修改建议：

---

## 一、整体架构层面的补充

### 1. 建议增加「技术架构概述」章节

你的文档目前偏重功能描述，但缺少一个顶层的技术架构说明。考虑到你使用Godot v4.6开发，建议在文档开头增加：

- **目标平台**：Windows / Linux / macOS？是否考虑Web导出？
- **最低系统配置要求**：CRT shader对GPU有一定要求
- **Godot项目结构**：场景树的大致组织方式（主场景、UI层、CRT后处理层、音频管理器等）
- **数据流向图**：压缩包 → 解析 → 内存文件系统 → 渲染展示

### 2. 建议增加「存档与持久化」章节

你提到了用户系统会记录权限和密码，但没有明确说明数据如何持久化：

- 用户数据存储位置（建议使用 `user://` 路径，即Godot的用户数据目录）
- 存档格式（JSON / SQLite / 自定义二进制）
- 是否支持多用户切换
- 阅读进度是否保存（沉浸式阅读中很重要）

---

## 二、各功能模块的详细建议

### 1. 操作界面（第1节）

**现有内容的修改建议：**

- 1.3 中「显示该目前所在位置」→ 建议改为「显示当前所在目录路径」，表述更清晰

**建议补充：**

```
1.4. 命令行自动补全：输入命令或文件名时，按Tab键自动补全，
     这对于键盘操作为主的界面至关重要
1.5. 命令历史记录：按↑↓键切换历史命令（模拟真实终端行为）
1.6. 滚动缓冲区：文档内容超出屏幕时的滚动查看方式
     （PageUp/PageDown/方向键/Home/End）
1.7. 帮助系统：输入 help 或 ? 可查看所有可用命令及说明
1.8. 指令集初步设计建议（你说待定，我帮你拟一个基础框架）：
```

**建议的基础指令集：**

| 指令 | 功能 | 示例 |
|------|------|------|
| `ls` / `dir` | 列出当前目录文件 | `ls` |
| `cd <path>` | 切换目录 | `cd /level2/docs` |
| `open <file>` | 打开文件 | `open report_001.txt` |
| `back` | 返回上一级 | `back` |
| `mail` | 打开邮件系统 | `mail` |
| `mail read <id>` | 阅读指定邮件 | `mail read 3` |
| `status` | 查看用户状态/权限 | `status` |
| `passwd <密码>` | 输入密码解锁 | `passwd ALPHA-7` |
| `clear` / `cls` | 清屏 | `clear` |
| `settings` | 打开设置面板 | `settings` |
| `play <file>` | 播放音视频 | `play audio_log.ogg` |
| `exit` | 退出当前压缩包/软件 | `exit` |
| `logout` | 注销当前用户 | `logout` |

考虑到SCP主题，还可以加入一些彩蛋指令，如 `whoami`、`ping`、`sudo` 等，输入后返回一些有趣的或恐怖的回应。

### 2. 视听效果（第2节）

**现有内容的修改建议：**

- 2.5 「每个文件打开都需要时间」——建议明确这是**模拟延迟**而非真实加载，避免误解。可以改为：「每个文件打开时会有模拟加载延迟效果，通过进度条/百分比动画展示，增强复古沉浸感。加载时间可在头文件中自定义。」

**建议补充：**

```
2.6. 文字逐字/逐行显示动画：模拟老式终端的打字机效果，
     文字以可调速度逐字出现，配合打字音效。
     这是CRT终端阅读器最核心的视觉体验之一。
2.7. 屏幕闪烁/故障效果（Glitch Effect）：
     可由头文件触发器控制，在特定剧情节点触发
     屏幕撕裂、色彩偏移、雪花噪点等效果
2.8. 光标样式：闪烁的方块光标或下划线光标，可自定义闪烁频率
2.9. 启动动画：软件打开时模拟CRT显示器开机过程
     （屏幕从中心线扩展、磷光渐亮等）
2.10. 关机动画：退出时模拟CRT关机（画面收缩为中心白线后消失）
2.11. CRT Shader参数建议（供优化参考）：
      - 扫描线（Scanlines）密度与透明度
      - 像素栅格（RGB子像素模拟）
      - 屏幕曲面扭曲（Barrel Distortion）
      - 边缘渐暗（Vignette）
      - 色彩渗透（Chromatic Aberration）
      - 磷光余辉/拖影（Phosphor Persistence/Ghosting）
      - 屏幕闪烁频率（50Hz/60Hz模拟）
      - 亮度抖动（Brightness Jitter）
```

关于CRT效果的优化，你提到了参考 cool-retro-term，这是一个很好的方向 [1]。在Godot中，CRT后处理通常通过 `CanvasLayer` + `ColorRect` + 自定义 Shader 实现。建议将所有CRT参数暴露为可调变量，方便用户在设置中微调。

### 3. 文件结构（第3节）——这是最需要细化的部分

**3.1 压缩包格式**

建议明确：
```
3.1.1. 推荐压缩格式：ZIP（Godot原生支持通过ZIPReader读取）
3.1.2. 压缩包文件后缀：建议使用自定义后缀如 .scp / .crt / .ark
       以便系统关联和双击打开
3.1.3. 压缩包根目录必须包含一个 manifest 文件（清单文件），
       描述该内容包的元信息：
       - 包名称、作者、版本号
       - 所需阅读器最低版本
       - 入口点（首次打开时显示的内容）
       - 全局设置（默认配色方案、默认字体等）
```

**3.2 头文件格式需要规范化**

你提到头文件是txt格式、有特殊后缀，但建议进一步明确其语法规则：

```
建议文件名：.header 或 _meta.cfg
建议格式示例：

[folder]
name = "机密文件库-Alpha区"
description = "该区域存放Alpha级别机密文档"
required_level = 3
password = "CLEARANCE-ALPHA"

[media_passwords]
audio_log_01.ogg = "WHISPER"
video_evidence.mp4 = "REDACTED"

[triggers]
on_enter = "new_mail:mail_warning_001"
on_first_enter = "jumpscare:glitch_02"
on_open_file:secret.txt = "level_up:4"

[display]
loading_time = 3.5
loading_text = "正在解密文件..."
ambient_sound = "sfx/server_hum.ogg"
```

**3.3 自定义TXT类Markdown语言——建议制定正式规范**

这是你项目的核心特性之一。自定义标记语言是构建在TXT纯文本基础之上的，便于创作者编辑的同时又能被阅读器解析渲染 [1]。建议你给这门语言起个名字（比如 **CRT-ML** 或 **SCP-Script**），并制定以下规范：

```markdown
# CRT-ML 语法规范草案

## 文档头部（隐藏区域，不展示给读者）
---HEADER---
template: document | chat | email | report
password: XXXXX
style: green_terminal | amber_terminal | white_terminal
typewriter_speed: 50
---END_HEADER---

## 基本格式
# 一级标题（模拟终端中以高亮/大号字显示）
## 二级标题
**粗体文本**（以高亮色显示）
*斜体文本*（如果CRT风格不适合斜体，可改为下划线）
~~删除线~~（以[已编辑]样式显示，符合SCP风格）
||被遮蔽的文本||（鼠标悬停或特定命令后才显示，类似SCP黑条）

## 特殊SCP风格标记
[REDACTED] → 显示为黑色遮蔽条
[DATA EXPUNGED] → 显示为红色警告文本
[ACCESS DENIED: LEVEL X REQUIRED] → 权限不足时的占位符

## 多媒体插入
![image](images/photo_001.png "可选标题" width=300)
![video](media/evidence.mp4 autoplay=false)
![audio](audio/log_01.ogg display=inline)

## 超链接
[显示文本](link:文件路径) → 阅读器内跳转
[显示文本](url:https://...) → 外部链接

## 动画/效果标记
{typewriter speed=30}这段文字会以特殊速度显示{/typewriter}
{glitch intensity=0.8}这段文字会有故障效果{/glitch}
{delay time=2000}这里会暂停2秒{/delay}
{shake intensity=5 duration=1000}屏幕震动{/shake}
{sound src="sfx/alarm.ogg"}  → 读到此处时播放音效
{clear} → 清除之前的所有内容（新场景效果）

## 分页符
---PAGE--- → 翻页（按任意键继续）

## 聊天记录模板专用语法
@username [HH:MM]: 消息内容
@username [HH:MM] {typing delay=3000}: 显示"正在输入..."后出现消息
```

**3.4 音视频播放补充**

关于多媒体播放，在阅读器中集成视频播放器时需要注意格式兼容性。Godot 4.x原生支持的视频格式有限（主要是 Ogg Theora），音频支持 OGG Vorbis 和 WAV [2]。

```
3.4.1. 支持的音频格式：OGG Vorbis（推荐）、WAV、MP3（Godot 4.x支持）
3.4.2. 支持的视频格式：Ogg Theora（Godot原生）
       注意：如需支持MP4/H.264等格式，可能需要通过GDExtension
       引入FFmpeg，这会显著增加开发复杂度，
       建议初期阶段限制为Godot原生支持的格式
3.4.3. 视频播放器UI：极简风格，与CRT主题一致
       - 播放/暂停（空格键）
       - 进度条（左右方向键快进/快退）
       - 音量（上下方向键）
       - 退出（Esc或q）
3.4.4. 音频播放器UI：
       - 波形/频谱可视化（可选，但能极大提升沉浸感）
       - 显示来自头文件的简介信息
       - 进度条、音量控制
```

**3.5 聊天记录补充**

```
3.5.1. 聊天记录应支持多种消息类型：
       - 纯文本消息
       - [图片]消息（显示为缩略图，可打开查看）
       - [文件]消息（可点击打开）
       - 系统消息（某某已加入群组、已撤回一条消息等）
3.5.2. 时间戳显示
3.5.3. 不同说话人用不同颜色区分
3.5.4. 支持"实时回放"模式：消息按原始时间间隔逐条出现，
       配合打字指示器动画
```

### 4. 用户及邮件系统（第4节）

**现有内容的修改建议：**

- 4.2 「所获取的密码（再打开时自动解密直接阅读）」→ 建议改为「已获取的密码会被记录，再次访问时自动解锁，无需重复输入」

**建议补充：**

```
4.4. 用户数据结构设计建议：
{
    "username": "Dr.Chen",
    "created_at": "1987-03-15 08:00:00",  // 可以设为虚构日期增强沉浸感
    "archives": {
        "content_pack_001.scp": {
            "clearance_level": 3,
            "unlocked_passwords": ["ALPHA", "OMEGA"],
            "read_files": ["doc_001.txt", "doc_005.txt"],
            "current_path": "/sector-7/reports/",
            "mail_

### USER
好，帮我整合进我的设计书中，然后统一一下发给我

### ASSISTANT


### USER
把你的你的补充修改内容整合进我的设计书中，然后统合一下发给我

### ASSISTANT
# CRT风格阅读器软件开发设计文档

## 〇、项目概述

### 0.1 项目简介
一个模仿20世纪80-90年代命令行终端CRT显示屏效果的阅读器，可以实现一些动画效果、播放多媒体内容，具备一定可拓展性，支持即时读取外部压缩包文件以及自定义排版等，基本设定为SCP基金会同人，主要用于沉浸式阅读、文字冒险、视觉小说等领域。

### 0.2 开发环境
- 引擎：Godot v4.6 及对应语言（GDScript）
- 开发模式：开发者入门级别，需AI逐步协作完成

### 0.3 目标平台
- 主要平台：Windows、Linux
- 可选平台：macOS、Web导出（后期考虑）
- 最低配置要求：需支持OpenGL 3.3 / Vulkan的独立或集成显卡（CRT Shader对GPU有一定要求）

### 0.4 项目结构概述
```
主场景
├── CRT后处理层（CanvasLayer + Shader）
├── UI层
│   ├── 状态栏（顶部）
│   ├── 内容显示区（中部）
│   └── 命令输入框（底部）
├── 音频管理器（环境音、音效、媒体播放）
├── 文件系统管理器（压缩包读取与虚拟文件系统）
├── 用户系统管理器（账户、权限、存档）
└── 邮件系统管理器
```

### 0.5 数据流向
```
外部压缩包(.scp) → ZIPReader解析 → 内存虚拟文件系统 → 
头文件解析/文档解析/媒体解析 → 渲染展示
```

---

## 一、操作界面

### 1.1 交互方式
基本不使用鼠标，绝大部分交互通过键盘完成。鼠标仅可进行复制粘贴、打开外部超链接等有限交互。

### 1.2 命令行操作系统
通过底部输入框输入代码指令完成操作。指令集如下（基础指令集，后续可扩展）：

| 指令 | 功能 | 示例 |
|------|------|------|
| `ls` / `dir` | 列出当前目录文件 | `ls` |
| `cd <path>` | 切换目录 | `cd /level2/docs` |
| `open <file>` | 打开文件 | `open report_001.txt` |
| `back` | 返回上一级目录 | `back` |
| `mail` | 打开邮件列表 | `mail` |
| `mail read <id>` | 阅读指定邮件 | `mail read 3` |
| `status` | 查看用户状态与权限 | `status` |
| `passwd <密码>` | 输入密码解锁 | `passwd ALPHA-7` |
| `clear` / `cls` | 清屏 | `clear` |
| `settings` | 打开设置面板 | `settings` |
| `play <file>` | 播放音视频文件 | `play audio_log.ogg` |
| `help` / `?` | 查看所有可用命令及说明 | `help` |
| `whoami` | 查看当前用户信息 | `whoami` |
| `logout` | 注销当前用户 | `logout` |
| `exit` | 退出当前压缩包或软件 | `exit` |

可预留彩蛋指令（如 `ping`、`sudo` 等），输入后返回主题相关的趣味或恐怖回应。

### 1.3 状态栏
顶部状态栏显示以下信息：
- 左侧：当前所在目录路径、已打开的文件名称
- 右上角：邮件图标，有新邮件时显示提示标记（剧情功能）

### 1.4 命令行自动补全
输入命令或文件名时，按 `Tab` 键自动补全当前可匹配的命令或路径。

### 1.5 命令历史记录
按 `↑` `↓` 键切换已输入的历史命令，模拟真实终端行为。

### 1.6 滚动与翻页
文档内容超出屏幕时，支持以下方式滚动查看：
- `PageUp` / `PageDown`：翻页
- `↑` `↓` 方向键：逐行滚动
- `Home` / `End`：跳转至文档首部/尾部

### 1.7 帮助系统
输入 `help` 或 `?` 可查看所有可用命令、语法说明及简要描述。

---

## 二、视听效果

### 2.1 CRT显示屏效果
通过 `CanvasLayer` + `ColorRect` + 自定义 Shader 实现CRT后处理效果。目前已部分实现，需进一步优化。参考项目：[cool-retro-term](https://github.com/Swordfish90/cool-retro-term)。

Shader参数应全部暴露为可调变量，包括但不限于：
- 扫描线（Scanlines）：密度与透明度
- 像素栅格（RGB子像素模拟）
- 屏幕曲面扭曲（Barrel Distortion）
- 边缘渐暗（Vignette）
- 色彩渗透（Chromatic Aberration）
- 磷光余辉/拖影（Phosphor Persistence / Ghosting）
- 屏幕闪烁频率（50Hz / 60Hz模拟）
- 亮度抖动（Brightness Jitter）
- 雪花噪点

### 2.2 用户自定义外观
用户可在设置中自行切换：
- 终端颜色方案（绿色磷光、琥珀色、白色等）
- 背景样式
- CRT效果强度（或关闭）
- 字体大小

### 2.3 环境音效
操作过程中播放机械、电子声等音效，模拟老式设备运行噪音。包括：
- 键盘敲击音
- 硬盘读取声
- 风扇/电流底噪
- 命令执行反馈音

### 2.4 文字逐字显示动画
模拟老式终端的打字机效果，文字以可调速度逐字出现，配合打字音效。这是CRT终端阅读器最核心的视觉体验之一。速度可全局设定，也可在文档中局部覆盖。

### 2.5 模拟加载效果
每个文件打开时会有模拟加载延迟效果，通过进度条或百分比动画展示，增强复古沉浸感。加载时间可在头文件中为每个文件夹/文件自定义。

### 2.6 故障效果（Glitch Effect）
可由头文件触发器控制，在特定剧情节点触发：
- 屏幕撕裂
- 色彩偏移
- 雪花噪点爆发
- 文字乱码闪烁

### 2.7 光标样式
闪烁的方块光标或下划线光标，可自定义闪烁频率，默认模拟经典终端光标。

### 2.8 开关机动画
- **启动动画**：软件打开时模拟CRT显示器开机过程（屏幕从中心线扩展、磷光渐亮等）
- **关机动画**：退出时模拟CRT关机（画面收缩为中心白线后消失）

---

## 三、文件结构

### 3.1 压缩包（内容包）

#### 3.1.1 格式
使用ZIP格式压缩（Godot通过 `ZIPReader` 原生支持读取），自定义文件后缀为 `.scp`（或 `.crt` / `.ark`，待定），以便系统关联和双击打开。

#### 3.1.2 作用
将文档以及所有会使用的素材都打包在一起，在阅读器打开后作为虚拟根目录存在。

#### 3.1.3 清单文件（Manifest）
压缩包根目录必须包含一个 `manifest.cfg` 文件，描述该内容包的元信息：

```ini
[pack]
name = "SCP-Site-19 机密档案"
author = "Dr. ████"
version = "1.0.0"
min_reader_version = "0.1.0"
description = "Site-19相关的机密文件存档"

[entry]
# 首次打开时的入口点
start_path = "/"
welcome_message = "欢迎接入Site-19终端，请先完成身份注册。"

[defaults]
color_scheme = "green_terminal"
font = "default"
typewriter_speed = 50
```

### 3.2 头文件（Folder Meta）

#### 3.2.1 基本说明
每一层文件夹都包含一个头文件，格式为自定义的 `.meta.cfg`（在阅读器 `ls` 列表中隐藏，不展示给读者）。

#### 3.2.2 功能
- 设置该层文件夹打开时所需的权限等级
- 设置当前文件夹的访问密码
- 设置该层文件夹内各多媒体文件的独立密码
- 设置文件简介描述（用于音频播放器等场景的信息展示）
- 配置触发器：触发jumpscare、新邮件、权限升级等meta事件
- 自定义该文件夹的加载时间、加载文本、环境音等

#### 3.2.3 格式示例

```ini
[folder]
name = "机密文件库-Alpha区"
description = "该区域存放Alpha级别机密文档"
required_level = 3
password = "CLEARANCE-ALPHA"

[file_descriptions]
audio_log_01.ogg = "音频日志：Dr.Bright 的个人记录，日期不明"
report_final.txt = "最终事故报告——仅限4级以上人员查阅"

[media_passwords]
audio_log_01.ogg = "WHISPER"
video_evidence.mp4 = "REDACTED"

[triggers]
on_enter = "new_mail:mail_warning_001"
on_first_enter = "jumpscare:glitch_02"
on_open_file:secret.txt = "level_up:4"

[display]
loading_time = 3.5
loading_text = "正在解密文件..."
ambient_sound = "sfx/server_hum.ogg"
```

### 3.3 文档文件（CRT-ML格式）

#### 3.3.1 概述
使用自定义的TXT类Markdown语言，命名为 **CRT-ML**（CRT Markup Language），纯文本编写，可被阅读器解析并渲染为对应格式。

#### 3.3.2 文档头部（隐藏设置区域，不展示给读者）

```
---HEADER---
template: document
password: XXXXX
style: green_terminal
typewriter_speed: 50
---END_HEADER---
```

可用的 `template` 值：
- `document`：标准文档模板
- `chat`：聊天记录模板
- `email`：邮件模板
- `report`：SCP报告模板（带分类编号栏）
- 其它模板后续可扩展

#### 3.3.3 基本格式语法

```markdown
# 一级标题（高亮/大号字显示）
## 二级标题
### 三级标题

**粗体文本**（以高亮色显示）
__下划线文本__
~~删除线~~（以[已编辑]样式显示）
||被遮蔽的文本||（需特定命令或权限后才可显示，类似SCP黑条效果）

> 引用块（缩进显示，带竖线前缀）

- 无序列表
1. 有序列表

--- 水平分割线
```

#### 3.3.4 SCP风格特殊标记

```
[REDACTED]          → 显示为黑色遮蔽条
[DATA EXPUNGED]     → 显示为红色警告文本
[ACCESS DENIED: LEVEL X REQUIRED] → 权限不足时的占位符
```

#### 3.3.5 多媒体插入

```
![image](images/photo_001.png "可选标题" width=300)
![video](media/evidence.mp4 autoplay=false)
![audio](audio/log_01.ogg display=inline)
```

#### 3.3.6 超链接

```
[显示文本](link:文件路径)       → 阅读器内跳转到其它文件
[显示文本](url:https://...)    → 在外部浏览器打开
```

#### 3.3.7 动画与效果标记

```
{typewriter speed=30}这段文字会以特殊速度显示{/typewriter}
{glitch intensity=0.8}这段文字会有故障效果{/glitch}
{delay time=2000}此处暂停2秒后继续{/delay}
{shake intensity=5 duration=1000}触发屏幕震动{/shake}
{sound src="sfx/alarm.ogg"}     → 读到此处时播放音效
{clear}                         → 清除之前所有显示内容（转场效果）
```

#### 3.3.8 分页符

```
---PAGE---  → 翻页，显示"按任意键继续"提示，等待用户操作
```

### 3.4 音视频文件

#### 3.4.1 支持格式
- **音频**：OGG Vorbis（推荐）、WAV、MP3（God

### USER
继续补充3.4 音视频文件及之后的部分

### ASSISTANT
接续上文，从 3.4 继续：

---

### 3.4 音视频文件

#### 3.4.1 支持格式
- **音频**：OGG Vorbis（推荐）、WAV、MP3（Godot 4.x原生支持）
- **视频**：Ogg Theora（Godot原生支持）
- **注意**：MP4 / H.264等格式需通过GDExtension引入FFmpeg，开发复杂度较高，初期阶段建议限制为Godot原生支持的格式，后期视需求扩展

#### 3.4.2 视频播放器
极简风格UI，与CRT主题保持一致：
- `空格键`：播放 / 暂停
- `←` `→`：快退 / 快进
- `↑` `↓`：音量调节
- `Esc` 或 `q`：退出播放器返回文档
- 底部显示进度条（ASCII风格，如 `[=====>------] 45%`）
- 播放时CRT Shader效果依然覆盖，保持整体视觉统一

#### 3.4.3 音频播放器
- 同时显示来自头文件中的文件简介信息（标题、描述、时长等）
- 底部进度条与音量控制（键盘操作方式同视频播放器）
- 可选：简易波形/频谱可视化（ASCII字符风格或简单柱状图，增强沉浸感）
- 支持后台播放：如在头文件中设定了 `ambient_sound`，切换目录或阅读文档时环境音可持续播放

#### 3.4.4 图片查看器
- 图片在CRT效果下显示，保持后处理一致性
- 支持基本缩放（`+` `-` 键）与适应屏幕宽度
- `Esc` 或 `q` 关闭查看器返回文档
- 图片加载时同样有模拟加载动画（逐行扫描显示或逐渐清晰化）

### 3.5 聊天记录文件

#### 3.5.1 概述
类似即时聊天软件的聊天记录文件，使用CRT-ML的 `chat` 模板，拥有专属动画效果。

#### 3.5.2 聊天记录专用语法

```
---HEADER---
template: chat
title: "Alpha小组内部通讯记录"
date: "1987-11-23"
participants: Agent_A, Agent_B, SYSTEM
typewriter_speed: 40
---END_HEADER---

@Agent_A [08:31]: 我已经到达指定地点了
@Agent_B [08:32]: 收到，注意周围环境
@Agent_A [08:32] {typing delay=3000}: ……这里有点不对劲
@SYSTEM [08:33]: [Agent_A 的连接已中断]
@Agent_B [08:33]: Alpha？你还在吗？
@Agent_B [08:35]: Alpha，请回复
![image](img/last_photo.png "Agent_A 最后传回的照片")
@SYSTEM [08:40]: [通讯记录结束]
```

#### 3.5.3 支持的消息类型
- **纯文本消息**：普通对话内容
- **图片消息**：显示为缩略图描述（如 `[图片: last_photo.png]`），可按回车打开查看
- **文件消息**：显示为文件附件（如 `[文件: report.txt]`），可按回车打开
- **系统消息**：以特殊样式居中显示（如"某某已加入群组"、"已撤回一条消息"、"连接已中断"等）
- **音频消息**：显示为可播放的音频条（如 `[语音消息 0:15]`）

#### 3.5.4 动画效果
- 消息逐条出现，模拟实时聊天过程
- `{typing delay=3000}`：该条消息出现前先显示"对方正在输入..."动画，等待指定时长后消息才出现
- 不同说话人使用不同颜色区分
- 时间戳显示在用户名旁
- 支持"实时回放"模式：消息按原始时间间隔逐条出现；也支持"快速浏览"模式：按键逐条推进

### 3.6 载入画面

#### 3.6.1 默认载入画面
软件自身拥有默认的CRT风格启动画面（配合2.8中的CRT开机动画）。

#### 3.6.2 自定义载入画面
每个压缩包（内容包）中可以包含一个自定义载入画面配置文件（如 `loading.cfg`），用于设置该内容包专属的加载动画：

```ini
[loading]
type = "text"
# type可选值: text, image, animation

# 文字型载入画面
lines = [
    "正在连接至Site-19安全终端...",
    "验证加密通道...",
    "加载机密档案数据库...",
    "连接成功。"
]
line_delay = 1500
typewriter_speed = 30
sound = "sfx/modem_connect.ogg"

# 图片型载入画面（当type=image时生效）
# image_path = "assets/loading_screen.png"
# display_time = 3000

# 完成后的过渡效果
transition = "fade"
```

### 3.7 文件可见性规则

为保持沉浸感，以下文件类型在阅读器的 `ls` / `dir` 命令中默认隐藏，不向读者展示：
- 头文件（`.meta.cfg`）
- 清单文件（`manifest.cfg`）
- 载入画面配置文件（`loading.cfg`）
- 邮件源文件（在被触发并"收到"之前处于隐藏状态）
- 素材资源文件夹（如 `sfx/`、`assets/` 等纯资源目录，可在清单文件中配置隐藏）

---

## 四、用户系统与邮件系统

### 4.1 用户注册与登录

#### 4.1.1 初次使用
首次启动软件或首次打开一个新的内容包时，需要注册一个新账户：
- 输入用户名（在终端中显示的身份标识）
- 设置密码
- 注册完成后自动收到第一封邮件——操作说明书

#### 4.1.2 登录
非首次启动时进入登录界面，输入用户名和密码登录。支持多用户，可通过 `logout` 注销并切换账户。

#### 4.1.3 沉浸式设计
注册与登录界面本身也模拟终端交互风格，例如：
```
> 检测到新终端接入。
> 请创建操作员档案。
> 输入操作员代号: _
> 设置访问密码: _
> 档案创建完成。欢迎，Dr.Chen。
> 您有 1 封新邮件。
```

### 4.2 用户数据

#### 4.2.1 记录内容
用户系统为每个内容包独立记录以下数据（不同压缩包内的数据不通用）：
- 当前权限等级
- 已获取的密码列表（再次访问已解锁内容时自动解密，无需重复输入）
- 已读文件记录
- 当前所在目录路径（用于恢复阅读位置）
- 邮件收件箱数据
- 已触发的事件记录（防止重复触发一次性事件）

#### 4.2.2 数据存储
- 存储位置：使用Godot的 `user://` 路径（用户数据目录）
- 存储格式：JSON（初期简单实现）或 SQLite（后期数据量大时可迁移）
- 每个内容包对应一个独立的存档文件，以内容包名称或哈希值命名

#### 4.2.3 用户数据结构示例

```json
{
    "username": "Dr.Chen",
    "created_at": "1987-03-15 08:00:00",
    "archives": {
        "site19_archive.scp": {
            "clearance_level": 3,
            "unlocked_passwords": ["ALPHA", "OMEGA"],
            "read_files": [
                "/reports/doc_001.txt",
                "/reports/doc_005.txt"
            ],
            "current_path": "/sector-7/reports/",
            "triggered_events": [
                "mail_warning_001",
                "jumpscare_glitch_02"
            ],
            "last_access": "1987-05-22 14:30:00"
        }
    }
}
```

### 4.3 邮件系统

#### 4.3.1 邮件本质
邮件本质上是一份特殊的CRT-ML文档文件，使用 `email` 模板，平时处于隐藏状态存储在压缩包内。

#### 4.3.2 邮件触发机制
当头文件中配置的触发条件满足后（如进入某个目录、打开某个文件、达到某个权限等级），经过可自定义的延迟时间后，用户收到该邮件：
- 状态栏右上角邮件图标出现提示
- 终端中显示系统提示（如 `[SYSTEM] 您有 1 封新邮件`）
- 可配合提示音效

#### 4.3.3 邮件格式示例

```
---HEADER---
template: email
trigger: on_enter:/sector-7/
delay: 30000
priority: high
---END_HEADER---

发件人: O5-██
收件人: {username}
日期: 1987-██-██
主题: 【紧急】关于Sector-7的访问警告
优先级: 高

---

{username}，

我们注意到你已访问Sector-7的文件目录。
在此正式警告：该区域的部分文件包含认知危害内容。

请在阅读任何标注为██的文件前，确保已执行标准防护程序。

此致，
O5议会
```

其中 `{username}` 为动态变量，阅读器会自动替换为当前登录的用户名。

#### 4.3.4 邮件操作
- `mail`：查看收件箱列表，显示编号、发件人、主题、日期、已读/未读状态
- `mail read <id>`：阅读指定编号的邮件
- 用户只能收邮件，不可发送邮件
- 所有已接收的邮件由用户系统持久化记录，关闭软件后再次打开仍然保留

#### 4.3.5 邮件列表显示示例

```
收件箱 (3封邮件, 1封未读)
============================================
 #  状态   发件人         主题                   日期
--------------------------------------------
 1  [已读]  SYSTEM        操作说明               1987-03-15
 2  [已读]  Dr.████      关于实验日志的说明       1987-04-02
 3  [未读]  O5-██        【紧急】关于Sector-7...  1987-05-22
============================================
输入 mail read <编号> 阅读邮件
```

---

## 五、存档与持久化

### 5.1 存档策略
- **自动存档**：用户每次操作（切换目录、打开文件、收到邮件、获取密码等）后自动保存状态
- **无手动存档**：为保持沉浸感，不提供手动存档/读档功能，所有操作不可回退（符合终端操作的真实感）

### 5.2 存档文件管理
- 存档位置：`user://saves/`
- 用户账户数据：`user://saves/user_profile.json`
- 各内容包独立存档：`user://saves/<pack_hash>.json`
- 设置文件：`user://saves/settings.json`

### 5.3 设置持久化
用户在 `settings` 中修改的所有偏好设定独立存储，不随内容包变化：

```json
{
    "display": {
        "color_scheme": "green_terminal",
        "crt_enabled": true,
        "crt_intensity": 0.8,
        "scanline_opacity": 0.3,
        "curvature": 0.15,
        "font_size": 16
    },
    "audio": {
        "master_volume": 0.8,
        "sfx_volume": 0.7,
        "ambient_volume": 0.5,
        "typing_sound": true
    },
    "text": {
        "typewriter_speed": 50,
        "auto_scroll": true
    }
}
```

---

## 六、触发器系统

### 6.1 概述
触发器是头文件中定义的事件机制，用于在特定条件满足时自动执行预设动作，是实现剧情推进和沉浸式体验的核心系统。

### 6.2 触发条件类型

| 条件 | 说明 | 示例 |
|------|------|------|
| `on_enter` | 每次进入该目录时触发 | `on_enter = "sound:alarm.ogg"` |
| `on_first_enter` | 仅首次进入该目录时触发 | `on_first_enter = "jumpscare:glitch_02"` |
| `on_open_file:<文件名>` | 打开指定文件时触发 | `on_open_file:secret.txt = "level_up:4"` |
| `on_level_reach:<等级>` | 权限达到指定等级时触发 | `on_level_reach:5 = "new_mail:final_warning"` |
| `on_read_complete:<文件名>` | 读完指定文件时触发 | `on_read_complete:doc3.txt = "

### USER
继续补充六、触发器系统及之后的部分

### ASSISTANT
接续上文，从 6.2 触发条件类型表格继续：

---

### 6.2 触发条件类型

| 条件 | 说明 | 示例 |
|------|------|------|
| `on_enter` | 每次进入该目录时触发 | `on_enter = "sound:alarm.ogg"` |
| `on_first_enter` | 仅首次进入该目录时触发 | `on_first_enter = "jumpscare:glitch_02"` |
| `on_open_file:<文件名>` | 打开指定文件时触发 | `on_open_file:secret.txt = "level_up:4"` |
| `on_level_reach:<等级>` | 权限达到指定等级时触发 | `on_level_reach:5 = "new_mail:final_warning"` |
| `on_read_complete:<文件名>` | 读完指定文件（滚动到底部或翻到最后一页）时触发 | `on_read_complete:doc3.txt = "unlock_folder:/hidden/"` |
| `on_password_entered:<密码>` | 输入特定密码时触发（无论对错） | `on_password_entered:WRONG = "jumpscare:trap_01"` |
| `on_mail_read:<邮件ID>` | 阅读指定邮件后触发 | `on_mail_read:mail_003 = "level_up:3"` |
| `on_all_read` | 当前目录下所有可见文件全部读完时触发 | `on_all_read = "new_mail:congratulations"` |
| `on_idle:<秒数>` | 用户在该目录下无操作超过指定时间时触发 | `on_idle:60 = "glitch:subtle_01"` |
| `on_command:<命令>` | 用户输入特定命令时触发 | `on_command:ping = "text:连接被拒绝。它在监听。"` |

### 6.3 触发动作类型

| 动作 | 说明 | 语法 |
|------|------|------|
| `new_mail:<邮件ID>` | 延迟后发送一封新邮件 | `"new_mail:mail_warning_001"` |
| `new_mail:<邮件ID>:delay=<毫秒>` | 指定延迟时间发送邮件 | `"new_mail:mail_003:delay=5000"` |
| `level_up:<等级>` | 将用户权限提升到指定等级 | `"level_up:4"` |
| `jumpscare:<效果ID>` | 触发jumpscare效果 | `"jumpscare:glitch_02"` |
| `glitch:<效果ID>` | 触发屏幕故障效果（不含恐吓内容） | `"glitch:subtle_01"` |
| `sound:<文件路径>` | 播放一次性音效 | `"sound:sfx/alarm.ogg"` |
| `ambient:<文件路径>` | 切换当前环境音（循环播放） | `"ambient:sfx/deep_hum.ogg"` |
| `ambient:stop` | 停止当前环境音 | `"ambient:stop"` |
| `text:<内容>` | 在终端中输出一行系统文本 | `"text:[WARNING] 检测到异常活动"` |
| `unlock_folder:<路径>` | 解锁一个之前隐藏或锁定的文件夹 | `"unlock_folder:/hidden_sector/"` |
| `unlock_file:<路径>` | 解锁一个之前隐藏或锁定的文件 | `"unlock_file:/logs/erased_log.txt"` |
| `lock_folder:<路径>` | 重新锁定一个文件夹（剧情需要） | `"lock_folder:/sector-7/"` |
| `set_password:<路径>:<密码>` | 动态为某个文件/文件夹设置新密码 | `"set_password:/vault/:NEWPASS"` |
| `screen_off:<毫秒>` | 屏幕黑屏指定时长后恢复 | `"screen_off:3000"` |
| `reboot` | 模拟终端重启动画（黑屏→开机流程→回到当前状态） | `"reboot"` |
| `redirect:<路径>` | 强制跳转到指定目录或文件 | `"redirect:/emergency/notice.txt"` |
| `clear` | 清除当前屏幕所有内容 | `"clear"` |
| `color_scheme:<方案>` | 临时切换终端配色方案 | `"color_scheme:red_alert"` |
| `typewriter:<速度>` | 临时改变全局打字速度 | `"typewriter:10"` |

### 6.4 复合触发器
支持一个条件触发多个动作，动作按顺序执行，使用分号 `;` 分隔：

```ini
[triggers]
on_first_enter = "glitch:heavy_01; screen_off:2000; text:[SYSTEM] 安全协议已启动; sound:sfx/alarm.ogg; new_mail:emergency_001:delay=10000; color_scheme:red_alert"
```

执行顺序：触发故障效果 → 黑屏2秒 → 显示系统文本 → 播放警报音 → 10秒后收到紧急邮件 → 终端变为红色警戒配色。

### 6.5 条件触发器（高级功能，可后期实现）
支持在触发条件中附加前置判断：

```ini
[triggers]
# 仅当权限等级>=3时，进入目录才触发
on_enter:if_level>=3 = "text:高级权限已验证，欢迎访问。"
# 仅当权限等级<3时，进入目录触发不同效果
on_enter:if_level<3 = "text:[ACCESS DENIED]; redirect:/"

# 仅当已读过特定文件后才触发
on_enter:if_read:/logs/clue.txt = "unlock_file:/hidden/answer.txt"
```

### 6.6 一次性与可重复触发
- 默认情况下，带 `on_first_enter` 等带"first"的触发器为一次性触发，触发后记录到用户存档中的 `triggered_events` 列表，不会重复执行
- `on_enter`、`on_idle` 等触发器默认为可重复触发
- 可通过 `once=true` 参数将任何可重复触发器设为一次性：

```ini
[triggers]
on_open_file:report.txt:once=true = "new_mail:follow_up_001"
```

---

## 七、Jumpscare与特殊效果系统

### 7.1 概述
作为SCP主题阅读器的重要氛围元素，jumpscare和特殊效果由触发器系统调用，素材存储在压缩包内。该系统不应被滥用，应服务于叙事目的。

### 7.2 Jumpscare效果定义
每个jumpscare效果在压缩包内的 `effects/` 目录下有对应配置文件：

```ini
# effects/glitch_02.cfg
[jumpscare]
type = "image"
# type可选值: image, text, glitch, composite

# 图片型
image_path = "effects/res/face_01.png"
duration = 500
flash = true
sound = "effects/res/scream_01.ogg"

# 屏幕效果
screen_shake = true
shake_intensity = 10
glitch_before = 300
glitch_after = 500

# 触发后状态
after_effect = "screen_off:1000"
```

### 7.3 预设效果类型

| 类型 | 说明 |
|------|------|
| `image` | 全屏闪现一张图片，配合音效和屏幕震动 |
| `text` | 屏幕快速闪过大量乱码或恐怖文本 |
| `glitch` | 纯屏幕故障效果（撕裂、色偏、噪点），不含具体恐吓内容 |
| `composite` | 组合以上多种效果的复合型 |

### 7.4 效果强度分级
建议在设置中提供效果强度选项，让用户自行选择：
- **完整**：所有效果正常展示
- **温和**：移除突然的音效和闪烁图片，保留故障效果和文本
- **关闭**：跳过所有jumpscare，仅保留剧情文本提示

---

## 八、设置系统

### 8.1 进入方式
通过命令 `settings` 进入设置面板，设置面板本身也以终端风格呈现，通过数字编号选择选项或使用方向键导航。

### 8.2 设置分类

#### 8.2.1 显示设置
```
[1] 配色方案 ........... 绿色磷光 / 琥珀色 / 白色 / 冰蓝 / 红色警戒
[2] CRT效果 ............ 开启 / 关闭
[3] CRT效果强度 ........ [=========>-] 80%
[4] 扫描线浓度 ......... [======>----] 60%
[5] 屏幕曲率 ........... [===>-------] 30%
[6] 色彩渗透 ........... [=====>-----] 50%
[7] 磷光余辉 ........... [===>-------] 30%
[8] 亮度抖动 ........... [==>--------] 20%
[9] 字体大小 ........... 16px
```

#### 8.2.2 音频设置
```
[1] 主音量 ............. [========>--] 80%
[2] 音效音量 ........... [=======>---] 70%
[3] 环境音音量 ......... [=====>-----] 50%
[4] 媒体播放音量 ....... [========>--] 80%
[5] 打字音效 ........... 开启 / 关闭
[6] 操作反馈音 ......... 开启 / 关闭
```

#### 8.2.3 文本设置
```
[1] 打字机速度 ......... [=====>-----] 50 字/秒
[2] 自动滚动 ........... 开启 / 关闭
[3] 聊天回放模式 ....... 实时回放 / 手动推进
```

#### 8.2.4 效果与安全设置
```
[1] Jumpscare强度 ...... 完整 / 温和 / 关闭
[2] 屏幕闪烁效果 ....... 开启 / 关闭（光敏性癫痫用户建议关闭）
[3] 屏幕震动效果 ....... 开启 / 关闭
```

### 8.3 设置快捷操作
- `Esc`：返回上一级 / 退出设置
- `R`：重置当前分类为默认值
- 所有设置修改即时预览，即时保存

---

## 九、内容包（压缩包）完整目录结构示例

以下是一个完整内容包的推荐目录结构：

```
site19_archive.scp (ZIP格式)
│
├── manifest.cfg                  # 清单文件（必须）
├── loading.cfg                   # 自定义载入画面配置（可选）
│
├── .meta.cfg                     # 根目录头文件
├── welcome.txt                   # 欢迎/入口文档
│
├── mail/                         # 邮件源文件目录（整体隐藏）
│   ├── mail_welcome.txt          # 欢迎邮件
│   ├── mail_warning_001.txt      # 警告邮件
│   ├── mail_emergency_001.txt    # 紧急邮件
│   └── mail_final.txt            # 结局邮件
│
├── reports/                      # 报告文件夹
│   ├── .meta.cfg                 # 该层头文件
│   ├── scp_001.txt               # SCP文档
│   ├── scp_002.txt
│   └── incident_log.txt          # 事故记录
│
├── personnel/                    # 人员档案文件夹
│   ├── .meta.cfg
│   ├── dr_bright.txt
│   └── agent_a.txt
│
├── comms/                        # 通讯记录文件夹
│   ├── .meta.cfg
│   ├── alpha_team_chat.txt       # 聊天记录文件
│   └── radio_log.txt
│
├── media/                        # 多媒体文件目录
│   ├── audio/
│   │   ├── audio_log_01.ogg
│   │   └── ambient_hum.ogg
│   ├── video/
│   │   └── surveillance_01.ogv
│   └── images/
│       ├── site_map.png
│       ├── photo_001.png
│       └── last_photo.png
│
├── effects/                      # 特殊效果资源目录（隐藏）
│   ├── glitch_02.cfg
│   ├── trap_01.cfg
│   └── res/
│       ├── face_01.png
│       ├── scream_01.ogg
│       └── static_noise.ogg
│
├── sfx/                          # 音效资源目录（隐藏）
│   ├── alarm.ogg
│   ├── server_hum.ogg
│   ├── modem_connect.ogg
│   └── door_lock.ogg
│
└── hidden/                       # 隐藏目录（需触发器解锁才可见）
    ├── .meta.cfg
    └── truth.txt
```

---

## 十、错误处理与边界情况

### 10.1 文件系统相关
| 场景 | 处理方式 |
|------|----------|
| 压缩包格式损坏或无法读取 | 显示终端风格错误信息：`[

### USER
继续补充十、错误处理与边界情况

### ASSISTANT
接续上文，从 10.1 表格继续：

---

### 10.1 文件系统相关

| 场景 | 处理方式 |
|------|----------|
| 压缩包格式损坏或无法读取 | 显示终端风格错误信息：`[ERROR] 文件损坏，无法建立连接。请检查档案完整性。` |
| 压缩包缺少 `manifest.cfg` | 提示：`[ERROR] 未找到清单文件。该档案包可能不兼容当前终端版本。` |
| 头文件 `.meta.cfg` 缺失 | 该文件夹按无限制状态处理（无权限要求、无密码、无触发器），正常展示内容 |
| 文档中引用的图片/音视频不存在 | 在文档对应位置显示：`[MISSING FILE: <文件名>]`，不中断阅读流程 |
| 不支持的文件格式 | 提示：`[ERROR] 无法识别的文件格式: <后缀名>`，建议用户检查内容包 |
| 嵌套压缩包（压缩包内包含压缩包） | 初期不支持，提示：`[ERROR] 不支持嵌套档案包。` 后期可考虑扩展 |
| 文件名包含特殊字符或过长 | 自动截断显示，完整文件名可通过 `info <文件名>` 命令查看 |
| 压缩包内文件总大小超出内存限制 | 采用按需加载策略，仅在用户打开文件时读取该文件内容，不一次性加载全部 |
| 空文件夹（无任何可见文件） | 显示：`该目录为空。` 或按头文件中的自定义描述显示 |

### 10.2 用户操作相关

| 场景 | 处理方式 |
|------|----------|
| 输入不存在的命令 | 提示：`[ERROR] 未知指令: <命令>。输入 help 查看可用命令。` |
| 命令参数缺失或格式错误 | 提示该命令的正确用法，如：`用法: cd <目录路径>` |
| 尝试打开权限不足的文件/文件夹 | 提示：`[ACCESS DENIED] 当前权限等级不足。需要等级: <X>，当前等级: <Y>` |
| 输入错误密码 | 提示：`[ACCESS DENIED] 密码验证失败。` 可设定连续错误次数上限触发特殊事件 |
| 连续多次输入错误密码（如5次） | 可在头文件中配置惩罚机制：临时锁定（`[LOCKED] 终端已锁定，请等待 30 秒。`）、触发警报效果、或触发特定触发器 |
| 在文档阅读中输入命令 | 文档阅读模式下输入框功能受限，仅接受 `q` / `Esc` 退出、翻页快捷键等，其它输入忽略或提示 `[INFO] 阅读模式下不可执行命令，按 Esc 退出阅读。` |
| 快速连续按键（按键防抖） | 设定最小按键间隔（如50ms），防止打字机动画异常或触发器重复触发 |
| 在加载动画过程中操作 | 加载期间屏蔽所有用户输入，加载完成后恢复 |

### 10.3 CRT-ML解析相关

| 场景 | 处理方式 |
|------|----------|
| 文档头部 `---HEADER---` 格式错误 | 忽略头部设置，使用默认模板和参数渲染文档正文，在开发者模式下输出警告日志 |
| 未知的模板类型 | 回退使用 `document` 默认模板 |
| 标记语法不闭合（如 `{glitch}` 缺少 `{/glitch}`） | 效果应用到段落末尾自动闭合，不影响后续内容渲染 |
| 多媒体标记引用文件不存在 | 参照10.1，显示 `[MISSING FILE]` 占位符 |
| 文档编码不是UTF-8 | 尝试自动检测编码并转换，若失败则提示：`[ERROR] 文件编码无法识别，可能显示异常。` |
| 文档内容为空 | 显示：`[该文件无内容]` |
| 超大文档（数万行） | 分段加载渲染，每次渲染一屏内容，滚动时动态加载后续内容，防止卡顿 |

### 10.4 触发器相关

| 场景 | 处理方式 |
|------|----------|
| 触发器引用的效果文件不存在 | 跳过该触发动作，开发者模式下输出警告：`[WARN] 效果文件缺失: <路径>` |
| 触发器引用的邮件文件不存在 | 跳过邮件发送，开发者模式下输出警告 |
| 触发器语法格式错误 | 跳过该条触发器，不影响其它触发器正常工作 |
| 触发动作中引用的路径不存在 | 跳过该动作，如 `redirect` 目标不存在时提示：`[ERROR] 目标路径不存在。` |
| 循环触发（A触发B，B触发A） | 设定触发链最大深度（如10层），超过后强制中断并在开发者模式下输出警告：`[WARN] 触发链深度超出限制，已中断。` |
| 多个触发器同时满足条件 | 按头文件中的书写顺序依次执行 |

### 10.5 音视频播放相关

| 场景 | 处理方式 |
|------|----------|
| 音视频文件损坏无法播放 | 提示：`[ERROR] 文件损坏，无法播放: <文件名>` |
| 不支持的编码格式 | 提示：`[ERROR] 不支持的媒体格式。本终端支持: OGG/WAV/MP3(音频), OGV(视频)` |
| 播放过程中文件读取中断 | 停止播放，提示：`[ERROR] 播放中断，数据流异常。` |
| 多个音频同时播放冲突 | 环境音与媒体播放器可同时存在（环境音自动降低音量），但不可同时打开两个媒体播放器，新的播放会替换旧的 |

### 10.6 用户数据相关

| 场景 | 处理方式 |
|------|----------|
| 存档文件损坏或无法读取 | 提示：`[WARNING] 用户数据损坏，是否创建新档案？(Y/N)`，用户确认后重置该内容包的存档数据 |
| 存档文件被外部篡改导致数据异常 | 进行基本的数据校验（权限等级范围、路径有效性等），异常字段重置为默认值 |
| 磁盘空间不足无法保存 | 提示：`[ERROR] 存储空间不足，无法保存当前进度。` |
| 用户名重复注册 | 提示：`[ERROR] 该操作员代号已存在，请选择其它代号。` |
| 忘记密码 | 不提供找回密码功能（维持沉浸感），但可提供 `reset` 命令重置整个用户档案（需确认） |

---

## 十一、开发者/调试模式

### 11.1 概述
为方便内容创作者调试自己的内容包，以及软件开发过程中排查问题，提供一个隐藏的开发者模式。

### 11.2 进入方式
在登录界面或命令行中输入特定指令进入开发者模式：
```
> debug on
[SYSTEM] 开发者模式已启用。
```
退出：
```
> debug off
[SYSTEM] 开发者模式已关闭。
```

### 11.3 开发者模式下的额外功能

| 命令 | 功能 |
|------|------|
| `debug on` / `debug off` | 开启/关闭开发者模式 |
| `debug show_hidden` | 显示所有隐藏文件（头文件、邮件源文件、效果配置等） |
| `debug show_triggers` | 显示当前目录下所有触发器及其状态（已触发/未触发） |
| `debug set_level <等级>` | 手动设置当前权限等级 |
| `debug trigger <触发器>` | 手动触发一个指定的触发动作 |
| `debug reset_events` | 重置所有已触发事件记录（使一次性触发器可重新触发） |
| `debug reset_all` | 重置当前内容包的所有用户数据 |
| `debug reload` | 重新加载当前内容包（修改内容包文件后无需重启软件） |
| `debug info <文件名>` | 显示文件的完整元信息（来自头文件的密码、描述、触发器等） |
| `debug log` | 显示/隐藏实时日志面板（解析警告、触发器执行记录等） |
| `debug skip_loading` | 跳过所有模拟加载动画 |
| `debug skip_typewriter` | 跳过所有打字机效果，文字立即全部显示 |

### 11.4 日志输出
开发者模式下，屏幕底部（或侧边）显示实时日志面板，输出以下信息：
- 触发器执行记录
- 文件解析警告与错误
- CRT-ML语法警告
- 资源加载状态
- 用户数据读写操作

日志等级用颜色区分：
- `[INFO]`：灰色/暗色
- `[WARN]`：黄色
- `[ERROR]`：红色

---

## 十二、可扩展性与未来规划

### 12.1 模板扩展机制
除内置的 `document`、`chat`、`email`、`report` 模板外，支持内容包自定义模板：

```
templates/                        # 内容包内的自定义模板目录
├── interrogation.cfg             # 审讯记录模板
├── experiment_log.cfg            # 实验日志模板
└── radio_transcript.cfg          # 无线电通讯记录模板
```

自定义模板配置文件定义该模板的显示样式、专用语法标记和动画行为：

```ini
# templates/interrogation.cfg
[template]
name = "interrogation"
display_name = "审讯记录"
description = "审讯室对话记录模板，双方对话交替显示"

[style]
background_tint = "dark_red"
default_color = "#CCCCCC"
speaker_a_color = "#FFFFFF"
speaker_b_color = "#FF6666"
timestamp_visible = true
separator = "---"

[animation]
entry_effect = "glitch:light"
message_delay = 800
typewriter_speed = 35
```

### 12.2 主题包支持（远期）
未来可考虑支持独立于内容包的主题包，允许用户安装不同的视觉主题：
- 自定义CRT Shader参数预设
- 自定义配色方案
- 自定义字体
- 自定义UI音效包
- 自定义光标样式

### 12.3 插件/Mod系统（远期）
预留插件接口的可能性：
- 自定义命令扩展
- 自定义触发器动作类型
- 自定义CRT-ML标记类型
- 自定义媒体播放器界面

### 12.4 多语言支持（远期）
- 阅读器界面文本的国际化（i18n）
- 内容包内文档的多语言版本切换机制

### 12.5 内容包创作工具（远期）
考虑开发配套的内容包创作辅助工具：
- CRT-ML语法高亮编辑器（或为主流编辑器开发语法高亮插件）
- 内容包结构验证工具（检查清单文件、头文件语法、资源引用完整性等）
- 内容包打包工具（自动压缩并设置正确后缀）
- 效果预览工具

---

## 十三、开发阶段规划

### 阶段一：基础框架（MVP）
- [ ] Godot项目基础搭建、场景树结构
- [ ] 基础CRT Shader实现与渲染管线
- [ ] 命令行输入框与基础命令解析（`ls`、`cd`、`open`、`back`、`clear`、`help`、`exit`）
- [ ] ZIP文件读取与虚拟文件系统
- [ ] 基础TXT文件显示（纯文本，暂无CRT-ML解析）
- [ ] 打字机效果
- [ ] 状态栏

### 阶段二：核心功能
- [ ] CRT-ML解析器（基本格式：标题、粗体、分割线、分页）
- [ ] 用户注册/登录系统
- [ ] 存档与数据持久化
- [ ] 头文件解析（权限、密码）
- [ ] 清单文件解析
- [ ] 文件滚动与翻页
- [ ] 命令自动补全与历史记录
- [ ] 模拟加载动画

### 阶段三：多媒体与模板
- [ ] 图片查

### USER
继续补充阶段三：多媒体与模板，

### ASSISTANT
接续上文，从阶段三继续：

---

### 阶段三：多媒体与模板
- [ ] 图片查看器（CRT效果覆盖、缩放、逐行扫描加载动画）
- [ ] 音频播放器（播放控制、简介显示、进度条）
- [ ] 视频播放器（基础播放控制、CRT效果覆盖）
- [ ] 环境音系统（循环播放、跨目录持续、自动降低音量）
- [ ] CRT-ML多媒体标记解析（`![image]`、`![audio]`、`![video]`）
- [ ] CRT-ML超链接解析（内部跳转与外部链接）
- [ ] `document` 模板完善
- [ ] `email` 模板实现
- [ ] `chat` 聊天记录模板实现（逐条消息动画、打字指示器、多说话人颜色区分）
- [ ] `report` SCP报告模板实现
- [ ] 聊天记录回放模式（实时回放与手动推进两种模式）

### 阶段四：触发器与邮件系统
- [ ] 触发器系统核心实现（条件检测、动作执行、触发链）
- [ ] 基础触发条件实现（`on_enter`、`on_first_enter`、`on_open_file`）
- [ ] 基础触发动作实现（`new_mail`、`level_up`、`sound`、`text`、`redirect`）
- [ ] 高级触发条件实现（`on_level_reach`、`on_read_complete`、`on_idle`、`on_command`）
- [ ] 高级触发动作实现（`glitch`、`screen_off`、`reboot`、`color_scheme`、`lock_folder`、`unlock_folder`）
- [ ] 复合触发器（分号分隔多动作顺序执行）
- [ ] 一次性触发器与可重复触发器逻辑
- [ ] 触发链深度限制与循环检测
- [ ] 邮件系统实现（邮件触发、延迟投递、收件箱列表、邮件阅读）
- [ ] 邮件图标提示与系统通知
- [ ] 邮件中动态变量替换（`{username}` 等）

### 阶段五：特殊效果与沉浸感
- [ ] Jumpscare效果系统（图片闪现、屏幕震动、音效配合）
- [ ] Glitch故障效果系统（屏幕撕裂、色偏、噪点、文字乱码）
- [ ] CRT-ML内联效果标记实现（`{glitch}`、`{shake}`、`{delay}`、`{sound}`、`{clear}`）
- [ ] SCP风格特殊标记实现（`[REDACTED]`、`[DATA EXPUNGED]`、`||遮蔽文本||`）
- [ ] CRT开机动画（磷光渐亮、中心线扩展）
- [ ] CRT关机动画（画面收缩为白线消失）
- [ ] 操作音效体系（键盘敲击、硬盘读取、电流底噪、命令反馈音）
- [ ] 自定义载入画面系统（`loading.cfg` 解析与渲染）
- [ ] 效果强度分级设置（完整/温和/关闭）
- [ ] 光敏性癫痫安全选项（关闭闪烁效果）

### 阶段六：CRT效果优化与设置系统
- [ ] CRT Shader全面优化（参考cool-retro-term）
  - [ ] 扫描线精细调节
  - [ ] RGB子像素模拟
  - [ ] 屏幕曲面扭曲
  - [ ] 边缘渐暗
  - [ ] 色彩渗透
  - [ ] 磷光余辉/拖影
  - [ ] 屏幕闪烁频率模拟
  - [ ] 亮度抖动
- [ ] 设置系统完整实现（显示、音频、文本、效果与安全四大分类）
- [ ] 配色方案切换（绿色磷光、琥珀色、白色、冰蓝、红色警戒）
- [ ] 设置即时预览与即时保存
- [ ] 设置持久化存储

### 阶段七：调试工具与错误处理
- [ ] 开发者模式实现（`debug on/off`）
- [ ] 开发者命令集实现（`debug show_hidden`、`debug set_level`、`debug trigger` 等）
- [ ] 实时日志面板（分级着色输出）
- [ ] 全面错误处理覆盖
  - [ ] 文件系统错误（损坏、缺失、格式不支持）
  - [ ] 用户操作错误（命令错误、权限不足、密码错误）
  - [ ] CRT-ML解析错误（语法错误、引用缺失、编码异常）
  - [ ] 触发器错误（引用缺失、循环检测、深度限制）
  - [ ] 音视频播放错误（格式不支持、文件损坏）
  - [ ] 用户数据错误（存档损坏、磁盘空间不足）
- [ ] 错误密码惩罚机制（连续错误触发锁定或特殊事件）
- [ ] 超大文档分段加载渲染

### 阶段八：扩展与打磨
- [ ] 条件触发器实现（`if_level>=`、`if_read:` 等高级判断逻辑）
- [ ] 自定义模板机制（内容包内 `templates/` 目录支持）
- [ ] 内容包文件关联（双击 `.scp` 文件直接用阅读器打开）
- [ ] 鼠标交互完善（复制粘贴、超链接点击、图片点击放大）
- [ ] 命令行彩蛋指令（`ping`、`sudo`、`whoami` 等趣味/恐怖回应）
- [ ] 性能优化与内存管理
- [ ] 全面测试与Bug修复
- [ ] 用户体验打磨（动画节奏、音效时机、错误提示措辞）

### 阶段九：远期规划（视项目发展情况）
- [ ] 主题包系统（独立于内容包的视觉主题安装机制）
- [ ] 插件/Mod系统预留接口
- [ ] 多语言支持（阅读器界面i18n）
- [ ] CRT-ML语法高亮编辑器插件（VSCode等主流编辑器）
- [ ] 内容包结构验证与打包辅助工具
- [ ] macOS平台适配
- [ ] Web导出版本
- [ ] 社区内容包分享平台对接（远景）

---

## 十四、已知技术风险与注意事项

### 14.1 Godot相关

| 风险项 | 说明 | 应对策略 |
|--------|------|----------|
| ZIPReader内存占用 | Godot的 `ZIPReader` 在处理大型压缩包时可能产生较高内存占用 | 采用按需加载策略，不一次性解压全部文件；设定内容包推荐最大体积（如500MB） |
| 视频格式限制 | Godot 4.x原生仅支持Ogg Theora视频，该格式画质和压缩率不如H.264 | 初期接受此限制，在内容创作指南中明确说明；后期可通过GDExtension扩展 |
| Shader兼容性 | CRT Shader在不同GPU/驱动上可能表现不一致 | 提供CRT效果开关和强度调节；使用GLES3确保最大兼容性；多平台测试 |
| 大量文本渲染性能 | Godot的RichTextLabel在渲染大量文本时可能出现性能问题 | 实现分段渲染和虚拟滚动；限制单次渲染的文本量 |
| GDScript性能瓶颈 | CRT-ML解析器如果用纯GDScript实现，在处理大型文档时可能较慢 | 优化解析算法；必要时考虑用C#或GDExtension重写解析器核心 |

### 14.2 内容创作相关

| 风险项 | 说明 | 应对策略 |
|--------|------|----------|
| CRT-ML学习成本 | 自定义标记语言需要内容创作者学习 | 语法设计尽量贴近Markdown降低门槛；编写详细的创作者文档和示例 |
| 素材格式转换 | 创作者可能不熟悉Ogg Theora等格式的转换 | 提供格式转换指南；或开发自动转换打包工具 |
| 头文件/触发器配置复杂度 | 复杂的触发器逻辑可能导致配置错误 | 开发者模式提供充分的调试工具和日志输出 |
| 内容包体积控制 | 多媒体素材可能导致压缩包过大 | 在创作指南中给出素材优化建议（分辨率、码率、压缩参数等） |

### 14.3 用户体验相关

| 风险项 | 说明 | 应对策略 |
|--------|------|----------|
| 纯键盘操作门槛 | 部分用户可能不习惯命令行交互方式 | 首封邮件作为操作教程；`help` 命令随时可用；考虑在设置中提供简化操作模式 |
| CRT效果导致阅读疲劳 | 长时间阅读CRT效果屏幕可能引起眼睛不适 | 提供效果强度调节和完全关闭选项；建议用户适当休息 |
| 光敏性癫痫风险 | Jumpscare闪烁、Glitch效果可能对光敏性癫痫患者造成危险 | 首次启动时显示健康警告；提供效果分级设置；闪烁效果可完全关闭 |
| 恐怖内容接受度差异 | 不同用户对jumpscare等恐怖内容的接受程度不同 | 效果强度三级可调（完整/温和/关闭）；内容包清单文件中标注内容分级 |

---

## 十五、附录

### 附录A：CRT-ML完整语法速查表

```
文档头部:
  ---HEADER--- / ---END_HEADER---
  template: document | chat | email | report | <自定义>
  password: <密码>
  style: <配色方案>
  typewriter_speed: <数值>

标题:
  # 一级标题
  ## 二级标题
  ### 三级标题

文本格式:
  **粗体**
  __下划线__
  ~~删除线（已编辑样式）~~
  ||遮蔽文本（需解锁查看）||
  > 引用块

SCP特殊标记:
  [REDACTED]
  [DATA EXPUNGED]
  [ACCESS DENIED: LEVEL X REQUIRED]

列表:
  - 无序列表项
  1. 有序列表项

分隔与分页:
  ---              水平分割线
  ---PAGE---       翻页（等待用户操作）

多媒体:
  ![image](路径 "标题" width=数值)
  ![video](路径 autoplay=true|false)
  ![audio](路径 display=inline|block)

链接:
  [显示文本](link:内部文件路径)
  [显示文本](url:外部URL)

效果标记:
  {typewriter speed=数值}文本{/typewriter}
  {glitch intensity=数值}文本{/glitch}
  {delay time=毫秒数}
  {shake intensity=数值 duration=毫秒数}
  {sound src="音频路径"}
  {clear}

聊天记录专用（template: chat）:
  @用户名 [时间]: 消息内容
  @用户名 [时间] {typing delay=毫秒数}: 消息内容
  ![image](路径 "描述")
  系统消息直接书写，无@前缀，自动居中
```

### 附录B：头文件 `.meta.cfg` 完整字段参考

```ini
[folder]
name = "显示名称"
description = "文件夹描述文本"
required_level = 0          # 所需权限等级，0为无限制
password = ""               # 访问密码，空为无密码

[file_descriptions]
# 文件名 = "描述文本（用于音频播放器等）"
文件名.后缀 = "描述"

[media_passwords]
# 文件名 = "该文件的独立访问密码"
文件名.后缀 = "密码"

[triggers]
# 条件 = "动作"
# 支持的条件: on_enter, on_first_enter, on_open_file:<文件>,
#   on_level_reach:<等级>, on_read_complete:<文件>,
#   on_password_entered:<密码>, on_mail_read:<邮件ID>,
#   on_all_read, on_idle:<秒数>, on_command:<命令>
# 条件修饰符: :once=true, :if_level>=<等级>, :if_read:<文件路径>
# 支持的动作: new_mail, level_up, jumpscare, glitch, sound,
#   ambient, text, unlock_folder, unlock_file, lock_folder,
#   set_password, screen_off, reboot, redirect, clear,
#   color_scheme, typewriter
# 多动作用分号分隔

[display]
loading_time = 2.0          # 模拟加载时长（秒）
loading_text = "加载中..."   # 加载时显示的文

### USER
继续补充附录B：头文件 `.meta.cfg` 完整字段参考，并尽快完成

### ASSISTANT
接续上文，从附录B继续：

---

### 附录B：头文件 `.meta.cfg` 完整字段参考（续）

```ini
[display]
loading_time = 2.0              # 模拟加载时长（秒）
loading_text = "加载中..."       # 加载时显示的文本
ambient_sound = ""              # 进入该目录时自动播放的环境音路径
ambient_volume = 1.0            # 环境音音量（0.0-1.0）
color_scheme_override = ""      # 强制覆盖该目录下的配色方案（留空则使用用户设置）
typewriter_speed_override = 0   # 强制覆盖打字机速度（0为不覆盖）
empty_message = "该目录为空。"   # 目录无可见文件时的自定义提示文本
```

### 附录C：`manifest.cfg` 完整字段参考

```ini
[pack]
name = "内容包名称"
author = "作者"
version = "1.0.0"
min_reader_version = "0.1.0"
description = "内容包简介描述"
content_rating = "safe"         # 内容分级: safe / moderate / horror
                                # 首次打开时向用户提示

[entry]
start_path = "/"                # 首次打开时的入口目录
welcome_message = ""            # 首次进入时的终端欢迎文本
first_mail = "mail_welcome"     # 注册完成后自动发送的第一封邮件ID

[defaults]
color_scheme = "green_terminal" # 默认配色: green_terminal / amber / white / ice_blue
font = "default"                # 默认字体
typewriter_speed = 50           # 默认打字机速度
loading_time = 2.0              # 全局默认加载时长

[hidden_dirs]
# 在ls中隐藏的资源目录列表
dirs = ["sfx", "effects", "assets", "mail", "templates"]
```

### 附录D：触发器语法速查表

```
# === 基本语法 ===
条件 = "动作"
条件 = "动作1; 动作2; 动作3"          # 复合动作

# === 触发条件 ===
on_enter                               # 每次进入目录
on_first_enter                         # 仅首次进入
on_open_file:<文件名>                   # 打开指定文件
on_read_complete:<文件名>               # 读完指定文件
on_level_reach:<等级>                   # 权限达到指定等级
on_password_entered:<密码>              # 输入特定密码
on_mail_read:<邮件ID>                   # 阅读指定邮件后
on_all_read                            # 当前目录全部读完
on_idle:<秒数>                          # 无操作超时
on_command:<命令>                       # 输入特定命令

# === 条件修饰符 ===
:once=true                             # 仅触发一次
:if_level>=<等级>                       # 权限前置判断
:if_level<<等级>                        # 权限前置判断
:if_read:<文件路径>                     # 已读文件前置判断

# === 触发动作 ===
new_mail:<邮件ID>                       # 发送邮件（默认延迟）
new_mail:<邮件ID>:delay=<毫秒>          # 发送邮件（指定延迟）
level_up:<等级>                         # 提升权限
jumpscare:<效果ID>                      # 触发jumpscare
glitch:<效果ID>                         # 触发故障效果
sound:<文件路径>                        # 播放一次性音效
ambient:<文件路径>                      # 切换环境音
ambient:stop                           # 停止环境音
text:<内容>                             # 输出系统文本
unlock_folder:<路径>                    # 解锁文件夹
unlock_file:<路径>                      # 解锁文件
lock_folder:<路径>                      # 锁定文件夹
set_password:<路径>:<密码>              # 动态设置密码
screen_off:<毫秒>                       # 黑屏指定时长
reboot                                 # 模拟终端重启
redirect:<路径>                         # 强制跳转
clear                                  # 清屏
color_scheme:<方案>                     # 切换配色
typewriter:<速度>                       # 改变打字速度
```

### 附录E：内置配色方案参考值

| 方案名 | 前景色 | 背景色 | 高亮色 | 说明 |
|--------|--------|--------|--------|------|
| `green_terminal` | `#33FF33` | `#0A0A0A` | `#66FF66` | 经典绿色磷光终端 |
| `amber` | `#FFB000` | `#0A0A0A` | `#FFD966` | 琥珀色终端 |
| `white` | `#CCCCCC` | `#0A0A0A` | `#FFFFFF` | 白色终端 |
| `ice_blue` | `#66CCFF` | `#0A0A0A` | `#99DDFF` | 冰蓝色终端 |
| `red_alert` | `#FF3333` | `#1A0000` | `#FF6666` | 红色警戒（由触发器切换） |

### 附录F：支持的媒体格式汇总

| 类型 | 格式 | 后缀 | 说明 |
|------|------|------|------|
| 音频 | Ogg Vorbis | `.ogg` | 推荐格式，体积小质量好 |
| 音频 | WAV | `.wav` | 无压缩，适合短音效 |
| 音频 | MP3 | `.mp3` | Godot 4.x支持 |
| 视频 | Ogg Theora | `.ogv` | Godot原生支持的唯一视频格式 |
| 图片 | PNG | `.png` | 推荐，支持透明通道 |
| 图片 | JPG/JPEG | `.jpg` `.jpeg` | 照片类素材适用 |
| 图片 | WebP | `.webp` | Godot 4.x支持，压缩率优秀 |
| 图片 | SVG | `.svg` | 矢量图，适合图标类素材 |

### 附录G：内容创作者快速入门清单

```
1. 创建项目文件夹作为工作目录
2. 在根目录编写 manifest.cfg（必须）
3. 在根目录编写 .meta.cfg（推荐）
4. 按需创建子文件夹，每个文件夹编写 .meta.cfg
5. 使用CRT-ML语法编写 .txt 文档
6. 将多媒体素材放入对应目录（注意格式要求）
7. 编写邮件文件放入 mail/ 目录
8. 如需特殊效果，在 effects/ 目录创建效果配置
9. 如需自定义载入画面，编写 loading.cfg
10. 使用阅读器的开发者模式进行调试测试
11. 将整个工作目录打包为ZIP，修改后缀为 .scp
12. 分发给读者使用
```

---

**— 文档结束 —**

*文档版本：v0.1-draft*
*最后更新：2025年*
*状态：初稿，待开发过程中持续迭代*

### USER
好，按照你说的一步步来开始做，我已经建立好了godot项目文件，其它什么都没做。你需要照顾到我初学者的身份，一步一步细致地告诉我该怎么做，下面正式开始阶段一：
**阶段一：基础框架（MVP）**
*   Godot项目基础搭建、场景树结构
    
*   基础CRT Shader实现与渲染管线
    
*   命令行输入框与基础命令解析（ls、cd、open、back、clear、help、exit）
    
*   ZIP文件读取与虚拟文件系统
    
*   基础TXT文件显示（纯文本，暂无CRT-ML解析）
    
*   打字机效果
    
*   状态栏

### ASSISTANT
好的！我们一步一步来。阶段一内容较多，我会把它拆分成多个小步骤，每一步都确保你能跟上。

---

# 阶段一 · 步骤1：项目基础搭建与场景树结构

## 1.1 首先了解我们要搭建什么

我们的主场景结构如下（你可以先看一眼，后面会一步步建）：

```
Main (Control)                          ← 根节点，全屏容器
├── Background (ColorRect)              ← 纯黑背景
├── MainContent (VBoxContainer)         ← 主要内容纵向排列
│   ├── StatusBar (HBoxContainer)       ← 顶部状态栏
│   │   ├── PathLabel (Label)           ← 当前路径显示
│   │   └── MailIcon (Label)            ← 邮件图标
│   ├── OutputArea (ScrollContainer)    ← 中部内容显示区（可滚动）
│   │   └── OutputText (RichTextLabel)  ← 实际文本内容
│   └── InputArea (HBoxContainer)       ← 底部输入区
│       ├── Prompt (Label)              ← 命令提示符 "> "
│       └── InputField (LineEdit)       ← 命令输入框
└── CRTEffect (CanvasLayer)             ← CRT后处理层
    └── CRTShader (ColorRect)           ← 承载Shader的矩形
```

## 1.2 创建主场景

**操作步骤：**

1. 打开你的Godot项目
2. 在左上角「场景」面板中，点击「其他节点」（或按快捷键），搜索 `Control`，创建一个 Control 节点
3. 把这个节点**重命名**为 `Main`（在左侧场景树中双击节点名即可重命名）
4. 按 `Ctrl+S` 保存场景，保存为 `res://scenes/main.tscn`（如果 `scenes` 文件夹不存在，在保存对话框中新建它）

> **提示**：如果Godot问你要不要把这个场景设为主场景，选「是」。如果没有问，我们后面手动设置。

## 1.3 设置Main节点为全屏

选中 `Main` 节点后，在右侧「检查器」（Inspector）面板中：

1. 找到 **Layout** → **Anchors Preset**（或者在Control节点顶部的工具栏中）
2. 点击它，选择 **「整个矩形」（Full Rect）** —— 这会让它铺满整个窗口

或者你也可以在检查器中手动设置：
- `Layout` → `Anchor Preset` → 选 `Full Rect`

## 1.4 逐一添加子节点

现在我们按照场景树一个一个添加。**请严格按照顺序和层级来**：

### 步骤A：添加 Background

1. **右键点击 `Main` 节点** → 「添加子节点」
2. 搜索 `ColorRect`，创建它
3. 重命名为 `Background`
4. 选中它，在检查器中：
   - `Layout` → `Anchor Preset` → **Full Rect**（铺满整个屏幕）
   - `Color` → 设置为 **纯黑色** `#000000`

### 步骤B：添加 MainContent

1. **右键点击 `Main` 节点** → 「添加子节点」
2. 搜索 `VBoxContainer`，创建它
3. 重命名为 `MainContent`
4. 设置为 **Full Rect**
5. 在检查器中找到 `Theme Overrides` → `Constants` → `Separation`，设置为 `0`（子节点之间无间距，后面需要时再调）

### 步骤C：添加 StatusBar（状态栏）

1. **右键点击 `MainContent`** → 「添加子节点」
2. 搜索 `HBoxContainer`，创建它
3. 重命名为 `StatusBar`
4. 在检查器中：
   - `Layout/Container Sizing` → `Horizontal` → `Expand` 打勾，`Stretch Ratio` = `1`（让它横向铺满）
   - `Custom Minimum Size` → `y` 设置为 `30`（状态栏高度30像素）

### 步骤D：在StatusBar内添加 PathLabel 和 MailIcon

1. **右键点击 `StatusBar`** → 添加子节点 → `Label`，重命名为 `PathLabel`
   - 在检查器中：
     - `Text` 设置为 `[/root]`（临时显示文本，后面代码会控制）
     - `Layout/Container Sizing` → `Horizontal` → `Expand` 打勾（让它占据剩余空间）

2. **右键点击 `StatusBar`** → 添加子节点 → `Label`，重命名为 `MailIcon`
   - `Text` 设置为 `[✉]`
   - `Horizontal Alignment` → `Right`

### 步骤E：添加 OutputArea（输出滚动区域）

1. **右键点击 `MainContent`** → 添加子节点 → `ScrollContainer`
2. 重命名为 `OutputArea`
3. 在检查器中：
   - `Layout/Container Sizing` → `Vertical` → `Expand` 打勾，`Stretch Ratio` = `1`
   - 这让它占据 StatusBar 和 InputArea 之间的所有剩余空间

### 步骤F：在OutputArea内添加 OutputText

1. **右键点击 `OutputArea`** → 添加子节点 → `RichTextLabel`
2. 重命名为 `OutputText`
3. 在检查器中：
   - `Layout/Container Sizing` → `Horizontal` → `Expand` 打勾
   - `Layout/Container Sizing` → `Vertical` → `Expand` 打勾
   - `BBCode` → `Enabled` → **打勾**（启用BBCode支持，后续排版需要）
   - `Scroll Active` → **关掉**（我们用外层ScrollContainer控制滚动）
   - `Fit Content` → **打勾**（让高度自适应内容）
   - `Text` 设置为 `欢迎使用SCP终端系统。\n输入 help 查看可用命令。`（临时测试文本）

### 步骤G：添加 InputArea（输入区域）

1. **右键点击 `MainContent`** → 添加子节点 → `HBoxContainer`
2. 重命名为 `InputArea`
3. `Custom Minimum Size` → `y` 设置为 `30`

### 步骤H：在InputArea内添加 Prompt 和 InputField

1. **右键点击 `InputArea`** → 添加子节点 → `Label`，重命名为 `Prompt`
   - `Text` 设置为 `> `（一个大于号加一个空格）

2. **右键点击 `InputArea`** → 添加子节点 → `LineEdit`，重命名为 `InputField`
   - `Layout/Container Sizing` → `Horizontal` → `Expand` 打勾（占满剩余宽度）
   - `Placeholder Text` 设置为 `输入命令...`

### 步骤I：添加 CRT效果层

1. **右键点击 `Main` 节点**（注意是Main，不是MainContent）→ 添加子节点 → `CanvasLayer`
2. 重命名为 `CRTEffect`
3. 在检查器中，`Layer` 设置为 `10`（确保它渲染在所有内容之上）

4. **右键点击 `CRTEffect`** → 添加子节点 → `ColorRect`
5. 重命名为 `CRTShader`
6. 设置为 **Full Rect**
   - 但因为它在CanvasLayer里，需要手动设置大小：
   - `Anchor Preset` → **Full Rect**
   - 如果Full Rect在CanvasLayer里不生效，手动设置：
     - `Position` → `x: 0, y: 0`
     - `Size` → `x: 1152, y: 648`（匹配你的窗口分辨率，先用默认的）

> 暂时不给CRTShader添加Shader，先让它透明，确保基础结构正确。把它的 `Color` 设为完全透明：`#00000000`

## 1.5 最终检查场景树

你的场景树现在应该长这样：

```
Main (Control) [Full Rect]
├── Background (ColorRect) [Full Rect, 黑色]
├── MainContent (VBoxContainer) [Full Rect]
│   ├── StatusBar (HBoxContainer) [最小高度30]
│   │   ├── PathLabel (Label) [文本: "[/root]", 横向扩展]
│   │   └── MailIcon (Label) [文本: "[✉]"]
│   ├── OutputArea (ScrollContainer) [纵向扩展]
│   │   └── OutputText (RichTextLabel) [BBCode开启, 自适应内容]
│   └── InputArea (HBoxContainer) [最小高度30]
│       ├── Prompt (Label) [文本: "> "]
│       └── InputField (LineEdit) [横向扩展]
└── CRTEffect (CanvasLayer) [Layer: 10]
    └── CRTShader (ColorRect) [透明]
```

## 1.6 设置主场景

如果之前没有设置主场景：
1. 点击菜单栏 「项目」 → 「项目设置」
2. 在 `Application` → `Run` → `Main Scene` 中，选择 `res://scenes/main.tscn`

## 1.7 设置窗口

在「项目设置」中：
1. `Display` → `Window`:
   - `Viewport Width`: `1152`
   - `Viewport Height`: `648`
   - `Stretch` → `Mode`: `canvas_items`
   - `Stretch` → `Aspect`: `keep`

## 1.8 设置终端字体（重要！）

CRT终端需要等宽字体。我们先下载一个免费的等宽字体：

1. 下载字体：推荐 **Fira Code** 或 **Source Code Pro** 或 **JetBrains Mono**
   - 下载地址（任选一个）：
     - https://github.com/tonsky/FiraCode/releases （下载zip中的ttf文件）
     - https://github.com/JetBrains/JetBrainsMono/releases
2. 在项目的 `res://` 下创建 `fonts` 文件夹
3. 将下载的 `.ttf` 文件拖入 `res://fonts/` 目录

然后为各个文本节点设置字体：

**对以下每个节点都做同样操作**：`PathLabel`、`MailIcon`、`OutputText`、`Prompt`、`InputField`

1. 选中节点
2. 在检查器中找到 `Theme Overrides` → `Fonts` → `Font`（对于RichTextLabel是 `Normal Font`）
3. 点击旁边的 `<空>` → `加载`，选择你的 `.ttf` 字体文件
4. 在 `Theme Overrides` → `Font Sizes` → `Font Size` 设置为 `16`

**设置字体颜色**（实现绿色终端效果）：

对以下节点，在 `Theme Overrides` → `Colors` → `Font Color` 设置为绿色 `#33FF33`：
- `PathLabel`
- `MailIcon`
- `Prompt`
- `InputField`（`Font Color` 和 `Font Placeholder Color` 都设置）
- `OutputText`（`Default Color` 设为 `#33FF33`）

**设置InputField的样式**：
- 选中 `InputField`
- `Theme Overrides` → `Styles` → `Normal`：新建 `StyleBoxFlat`
  - `BG Color` → `#00000000`（透明背景）
  - `Border Width` → 全部设为 `0`（无边框）
- 同样设置 `Focus` 样式为透明无边框（否则聚焦时会有默认边框）
- `Caret` → `Caret Color` → `#33FF33`（光标也是绿色）

## 1.9 运行测试

按 `F5` 运行项目。你应该看到：
- 黑色背景
- 顶部有绿色的 `[/root]` 和 `[✉]`
- 中间显示绿色的欢迎文本
- 底部有 `>` 提示符和可输入的文本框

如果你看到了这些，说明基础结构搭建成功！

**按 `Ctrl+S` 保存场景。**

---

# 阶段一 · 步骤2：编写主脚本与基础命令系统

## 2.1 创建脚本文件

1. 在文件系统中创建 `res://scripts/` 文件夹
2. 选中场景树中的 `Main` 节点
3. 点击右上角的 **「附加脚本」** 图标（卷轴图标）
4. 路径改为 `res://scripts/main.gd`
5. 点击「创建」

## 2.2 编写主脚本

把 `main.gd` 的内容**完全替换**为以下代码：

```gdscript
extends Control

# ============================================================
# 节点引用
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea

# ============================================================
# 虚拟文件系统数据
# ============================================================
# 当前路径
var current_path: String = "/"
# 是否有新

### USER
在步骤1中，我使用的字体为SarasaMonoSC-Regular，完成后如图显示，[/root]和[✉]没有在顶部，偏下了很多

### ASSISTANT
我看到两个问题：

1. **`[/root]` 和状态栏偏下**：`MainContent` 的布局没有从顶部开始对齐
2. **`\n` 没有换行**：OutputText 中的 `\n` 被当作文字显示了，而不是换行符

让我们逐一修复。

---

## 修复1：状态栏偏下问题

问题原因是 `MainContent`（VBoxContainer）默认可能居中对齐了，或者上方有多余的边距。

**选中 `MainContent` 节点**，在检查器中检查并修改：

1. 确认 `Layout` → `Anchors Preset` 是 **Full Rect**
2. 关键步骤：找到 `Layout` → `Offset`（或在旧版叫 `Margin`），确保四个值全部为 `0`：
   - `Offset Left`: `0`
   - `Offset Top`: `0`
   - `Offset Right`: `0`
   - `Offset Bottom`: `0`

如果上面设置了还不行，**再检查 `StatusBar` 节点**：

1. 选中 `StatusBar`
2. 在检查器中找到 `Layout/Container Sizing` → `Vertical` → **确保 `Expand` 没有打勾**
3. `Custom Minimum Size` → `y` 确认为 `30`

**再检查 `OutputArea` 节点**：

1. 选中 `OutputArea`
2. `Layout/Container Sizing` → `Vertical` → `Expand` **打勾**，`Stretch Ratio` = `1`

**再检查 `InputArea` 节点**：

1. 选中 `InputArea`
2. `Layout/Container Sizing` → `Vertical` → **确保 `Expand` 没有打勾**
3. `Custom Minimum Size` → `y` 确认为 `30`

> **核心逻辑**：在VBoxContainer中，只有 `OutputArea` 应该设为纵向扩展（Expand），`StatusBar` 和 `InputArea` 都不要勾选纵向扩展，它们只保持自己的最小高度。这样 `StatusBar` 就会紧贴顶部，`InputArea` 紧贴底部，中间全部留给 `OutputArea`。

---

## 修复2：`\n` 没有换行

这是因为在Godot编辑器的 `Text` 属性框中直接输入 `\n` 会被当作两个字符（反斜杠和n），而不是换行符。

**解决方法**：选中 `OutputText` 节点，把 `Text` 属性清空（留空就行），我们后面全部用代码控制输出内容。如果你现在想看到测试文字，可以换成不含 `\n` 的文本，例如：

```
欢迎使用SCP终端系统。
```

或者直接清空，因为步骤2写脚本时会用代码输出欢迎文字，到时候代码中的 `\n` 是可以正确换行的。

---

## 修复完成后的检查

做完以上修改后，按 `Ctrl+S` 保存，然后 `F5` 运行，你应该看到：

- `[/root]` **紧贴在窗口最顶部左侧**
- `[✉]` **在最顶部右侧**
- 欢迎文本在中间区域的顶部
- `> 输入命令...` **紧贴在窗口最底部**

看起来应该类似这样：

```
[/root]                                                    [✉]
欢迎使用SCP终端系统。




                    （大片空白区域）




> 输入命令...
```

如果修复后还有问题，请再截图给我看，我帮你进一步排查。确认没问题后我们继续步骤2：编写主脚本与基础命令系统。

### USER
已修复完成，继续进行下一步，也就是你上面没说完的阶段一 · 步骤2：编写主脚本与基础命令系统

### ASSISTANT
好的，继续步骤2。这一步我们要编写主脚本，实现命令输入、解析和基础的虚拟文件系统。

---

# 阶段一 · 步骤2：编写主脚本与基础命令系统

## 2.1 创建脚本文件

如果你还没做这一步：

1. 在文件系统中创建 `res://scripts/` 文件夹
2. 选中场景树中的 `Main` 节点
3. 点击右上角的 **「附加脚本」** 图标（卷轴状图标）
4. 路径改为 `res://scripts/main.gd`
5. 语言选 `GDScript`，模板选 `空`
6. 点击「创建」

## 2.2 编写完整的主脚本

打开 `main.gd`，**清空所有内容**，然后把以下完整代码粘贴进去：

```gdscript
extends Control

# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea

# ============================================================
# 状态变量
# ============================================================
# 当前所在路径
var current_path: String = "/"
# 是否有新邮件
var has_new_mail: bool = false
# 命令历史记录
var command_history: Array[String] = []
# 当前在历史记录中的位置（-1表示不在历史中，正在输入新命令）
var history_index: int = -1
# 临时保存用户正在输入的文本（在翻阅历史时保留）
var current_input_backup: String = ""

# ============================================================
# 虚拟文件系统
# ============================================================
# 用字典模拟文件系统结构
# 每个键是路径名，值是一个字典：
#   "type": "folder" 或 "file"
#   "children": 子项数组（仅文件夹有）
#   "content": 文件内容文本（仅文件有）
var file_system: Dictionary = {}

# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
	# 初始化虚拟文件系统（内置测试数据，后续会替换为ZIP读取）
	_init_test_file_system()
	
	# 清空输出区域
	output_text.text = ""
	output_text.bbcode_enabled = true
	
	# 连接输入框的信号：当用户按回车时触发
	input_field.text_submitted.connect(_on_command_submitted)
	
	# 让输入框自动获得焦点（光标直接在输入框中闪烁）
	input_field.grab_focus()
	
	# 更新状态栏显示
	_update_status_bar()
	
	# 显示欢迎信息
	_show_welcome_message()


# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
	if event is InputEventKey and event.pressed:
		match event.keycode:
			KEY_UP:
				# 按↑键：翻阅上一条历史命令
				_history_previous()
				get_viewport().set_input_as_handled()
			KEY_DOWN:
				# 按↓键：翻阅下一条历史命令
				_history_next()
				get_viewport().set_input_as_handled()
			KEY_PAGEUP:
				# PageUp：向上滚动输出内容
				scroll_container.scroll_vertical -= 100
				get_viewport().set_input_as_handled()
			KEY_PAGEDOWN:
				# PageDown：向下滚动输出内容
				scroll_container.scroll_vertical += 100
				get_viewport().set_input_as_handled()
			KEY_TAB:
				# Tab键：自动补全（后续实现）
				_auto_complete()
				get_viewport().set_input_as_handled()


# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
	# 获取用户输入并去除首尾空格
	var raw_input := command_text.strip_edges()
	
	# 清空输入框
	input_field.clear()
	# 重新聚焦输入框
	input_field.grab_focus()
	
	# 如果输入为空，忽略
	if raw_input.is_empty():
		return
	
	# 将命令存入历史记录
	command_history.append(raw_input)
	history_index = -1
	
	# 在输出区域显示用户输入的命令（模拟终端回显）
	append_output("> " + raw_input)
	
	# 解析并执行命令
	_execute_command(raw_input)
	
	# 每次命令执行后滚动到底部
	await get_tree().process_frame
	scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value


# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
	# 将输入按空格分割为命令和参数
	var parts := raw_input.split(" ", false)
	if parts.is_empty():
		return
	
	# 第一个词是命令，转为小写
	var command := parts[0].to_lower()
	# 剩余部分是参数
	var args := parts.slice(1)
	
	# 根据命令分发执行
	match command:
		"help", "?":
			_cmd_help()
		"ls", "dir":
			_cmd_ls()
		"cd":
			_cmd_cd(args)
		"open", "cat":
			_cmd_open(args)
		"back":
			_cmd_back()
		"clear", "cls":
			_cmd_clear()
		"status":
			_cmd_status()
		"mail":
			_cmd_mail(args)
		"exit", "quit":
			_cmd_exit()
		"whoami":
			_cmd_whoami()
		_:
			# 未知命令
			append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]")
			append_output("输入 [color=#66FF66]help[/color] 查看可用命令。")


# ============================================================
# 各命令的具体实现
# ============================================================

# --- help 命令 ---
func _cmd_help() -> void:
	var help_text := """[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]
  [color=#66FF66]help[/color]          显示本帮助信息
  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹
  [color=#66FF66]cd <路径>[/color]     切换到指定目录
  [color=#66FF66]back[/color]          返回上一级目录
  [color=#66FF66]open <文件>[/color]   打开并显示文件内容
  [color=#66FF66]clear[/color]         清空屏幕
  [color=#66FF66]status[/color]        查看当前用户状态
  [color=#66FF66]mail[/color]          查看收件箱
  [color=#66FF66]whoami[/color]        查看当前用户信息
  [color=#66FF66]exit[/color]          退出终端
[color=#66FF66]═══════════════════════════════════════════════[/color]
[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]"""
	append_output(help_text)


# --- ls 命令 ---
func _cmd_ls() -> void:
	# 获取当前路径下的所有子项
	var items := _get_children_at_path(current_path)
	
	if items.is_empty():
		append_output("[color=#AAAAAA]该目录为空。[/color]")
		return
	
	append_output("[color=#66FF66]目录: " + current_path + "[/color]")
	append_output("")
	
	for item in items:
		var item_path := _join_path(current_path, item)
		var node := _get_node_at_path(item_path)
		if node == null:
			continue
		
		if node.type == "folder":
			# 文件夹用 [DIR] 标记，蓝色显示
			append_output("  [color=#6699FF][DIR]  " + item + "/[/color]")
		else:
			# 文件显示文件名
			append_output("  [color=#33FF33][FILE] " + item + "[/color]")
	
	append_output("")


# --- cd 命令 ---
func _cmd_cd(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
		return
	
	var target: String = args[0]
	var new_path: String
	
	# 处理特殊路径
	if target == "/":
		new_path = "/"
	elif target == "..":
		# 返回上一级
		new_path = _get_parent_path(current_path)
	elif target.begins_with("/"):
		# 绝对路径
		new_path = target
	else:
		# 相对路径
		new_path = _join_path(current_path, target)
	
	# 标准化路径
	new_path = _normalize_path(new_path)
	
	# 检查目标路径是否存在且是文件夹
	var node := _get_node_at_path(new_path)
	if node == null:
		append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
		return
	if node.type != "folder":
		append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
		return
	
	# 切换路径
	current_path = new_path
	_update_status_bar()
	append_output("已切换到: " + current_path)


# --- open 命令 ---
func _cmd_open(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
		return
	
	var filename: String = args[0]
	var file_path: String
	
	if filename.begins_with("/"):
		file_path = filename
	else:
		file_path = _join_path(current_path, filename)
	
	file_path = _normalize_path(file_path)
	
	var node := _get_node_at_path(file_path)
	if node == null:
		append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
		return
	if node.type != "file":
		append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
		return
	
	# 显示文件内容
	append_output("[color=#66FF66]══════════ " + filename + " ══════════[/color]")
	append_output("")
	append_output(node.content)
	append_output("")
	append_output("[color=#66FF66]══════════ 文件结束 ══════════[/color]")


# --- back 命令 ---
func _cmd_back() -> void:
	if current_path == "/":
		append_output("[color=#AAAAAA]已经在根目录了。[/color]")
		return
	
	current_path = _get_parent_path(current_path)
	_update_status_bar()
	append_output("已返回: " + current_path)


# --- clear 命令 ---
func _cmd_clear() -> void:
	output_text.text = ""


# --- status 命令 ---
func _cmd_status() -> void:
	var status_text := """[color=#66FF66]═══════════ 用户状态 ═══════════[/color]
  用户名:     [color=#66FF66]未登录[/color]
  权限等级:   [color=#FFB000]0[/color]
  当前路径:   [color=#66FF66]{path}[/color]
  已读文件:   [color=#66FF66]0[/color]
  已获取密码: [color=#66FF66]0[/color]
[color=#66FF66]════════════════════════════════[/color]"""
	status_text = status_text.replace("{path}", current_path)
	append_output(status_text)


# --- mail 命令 ---
func _cmd_mail(args: Array) -> void:
	append_output("[color=#AAAAAA]收件箱为空。[/color]")
	append_output("[color=#AAAAAA](邮件系统将在后续版本中实现)[/color]")


# --- exit 命令 ---
func _cmd_exit() -> void:
	append_output("[color=#AAAAAA]正在断开连接...[/color]")
	# 延迟1秒后退出
	await get_tree().create_timer(1.0).timeout
	get_tree().quit()


# --- whoami 命令 ---
func _cmd_whoami() -> void:
	append_output("[color=#66FF66]未登录用户[/color]")
	append_output("[color=#AAAAAA](用户系统将在后续版本中实现)[/color]")


# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
	if command_history.is_empty():
		return
	
	# 如果是第一次按↑，备份当前输入
	if history_index == -1:
		current_input_backup = input_field.text
		history_index = command_history.size() - 1
	elif history_index > 0:
		history_index -= 1
	
	input_field.text = command_history[history_index]
	# 将光标移到末尾
	input_field.caret_column = input_field.text.length()


func _history_next

### USER
继续完成你没写完的代码

### ASSISTANT
接续上面的代码，从 `_history_next` 函数继续。以下是 `main.gd` **剩余的全部代码**，请接在你已有代码的最后面：

```gdscript
func _history_next() -> void:
	if command_history.is_empty() or history_index == -1:
		return
	
	if history_index < command_history.size() - 1:
		history_index += 1
		input_field.text = command_history[history_index]
	else:
		# 已经到最新一条，恢复用户之前输入的内容
		history_index = -1
		input_field.text = current_input_backup
	
	# 将光标移到末尾
	input_field.caret_column = input_field.text.length()


# ============================================================
# 自动补全（基础版）
# ============================================================
func _auto_complete() -> void:
	var current_text := input_field.text.strip_edges()
	if current_text.is_empty():
		return
	
	# 将输入按空格分割
	var parts := current_text.split(" ", false)
	
	# 如果只有一个词，尝试补全命令
	if parts.size() == 1:
		var partial_cmd := parts[0].to_lower()
		var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
						"clear", "cls", "status", "mail", "whoami", "exit", "quit"]
		var matches: Array[String] = []
		for cmd in commands:
			if cmd.begins_with(partial_cmd):
				matches.append(cmd)
		
		if matches.size() == 1:
			# 唯一匹配，直接补全
			input_field.text = matches[0] + " "
			input_field.caret_column = input_field.text.length()
		elif matches.size() > 1:
			# 多个匹配，显示所有候选
			append_output("[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
	
	# 如果有两个词（命令+部分参数），尝试补全文件名/文件夹名
	elif parts.size() == 2:
		var cmd := parts[0].to_lower()
		var partial_name := parts[1]
		
		# 只对 cd、open、cat 命令补全文件名
		if cmd in ["cd", "open", "cat"]:
			var children := _get_children_at_path(current_path)
			var matches: Array[String] = []
			for child in children:
				if child.to_lower().begins_with(partial_name.to_lower()):
					matches.append(child)
			
			if matches.size() == 1:
				input_field.text = cmd + " " + matches[0]
				input_field.caret_column = input_field.text.length()
			elif matches.size() > 1:
				append_output("[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")


# ============================================================
# 输出工具函数
# ============================================================

# 向输出区域追加一行文本（支持BBCode）
func append_output(text: String) -> void:
	if output_text.text.length() > 0:
		output_text.append_text("\n")
	output_text.append_text(text)


# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
	path_label.text = "[" + current_path + "]"
	
	if has_new_mail:
		mail_icon.text = "[✉ NEW]"
	else:
		mail_icon.text = "[✉]"


# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
	var welcome := """[color=#66FF66]╔══════════════════════════════════════════════╗
║         SCP FOUNDATION TERMINAL v0.1         ║
║       SECURE - CONTAIN - PROTECT             ║
╚══════════════════════════════════════════════╝[/color]

[color=#AAAAAA]终端系统已启动。
输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]
"""
	output_text.append_text(welcome)


# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================

# 拼接路径
func _join_path(base: String, child: String) -> String:
	if base == "/":
		return "/" + child
	else:
		return base + "/" + child


# 获取父级路径
func _get_parent_path(path: String) -> String:
	if path == "/":
		return "/"
	
	# 去除末尾斜杠
	var clean_path := path.rstrip("/")
	var last_slash := clean_path.rfind("/")
	
	if last_slash <= 0:
		return "/"
	
	return clean_path.substr(0, last_slash)


# 标准化路径（去除多余斜杠、处理 .. 等）
func _normalize_path(path: String) -> String:
	# 确保以 / 开头
	if not path.begins_with("/"):
		path = "/" + path
	
	# 分割路径各段
	var parts := path.split("/", false)
	var resolved: Array[String] = []
	
	for part in parts:
		if part == "..":
			if resolved.size() > 0:
				resolved.pop_back()
		elif part == ".":
			continue
		else:
			resolved.append(part)
	
	if resolved.is_empty():
		return "/"
	
	return "/" + "/".join(resolved)


# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================

# 文件系统节点类（用于返回查询结果）
class FSNode:
	var type: String  # "folder" 或 "file"
	var content: String  # 文件内容（仅文件有）
	
	func _init(p_type: String, p_content: String = "") -> void:
		type = p_type
		content = p_content


# 在指定路径获取文件系统节点
func _get_node_at_path(path: String) -> FSNode:
	path = _normalize_path(path)
	
	# 根目录
	if path == "/":
		return FSNode.new("folder")
	
	# 在file_system字典中查找
	if file_system.has(path):
		var entry: Dictionary = file_system[path]
		return FSNode.new(entry.get("type", "file"), entry.get("content", ""))
	
	return null


# 获取指定路径下的所有子项名称
func _get_children_at_path(path: String) -> Array[String]:
	path = _normalize_path(path)
	var children: Array[String] = []
	
	# 确定需要匹配的前缀
	var prefix: String
	if path == "/":
		prefix = "/"
	else:
		prefix = path + "/"
	
	for key in file_system.keys():
		# 检查是否是直接子项（不是更深层的）
		if key.begins_with(prefix):
			var remainder := key.substr(prefix.length())
			# 直接子项不应包含 /（那表示是更深层的）
			if not remainder.contains("/"):
				children.append(remainder)
	
	children.sort()
	return children


# ============================================================
# 测试文件系统初始化
# ============================================================
func _init_test_file_system() -> void:
	# 构建一个测试用的虚拟文件系统
	# 后续会替换为从ZIP文件读取
	
	file_system = {
		# === 根目录下的文件夹 ===
		"/reports": {
			"type": "folder"
		},
		"/personnel": {
			"type": "folder"
		},
		"/comms": {
			"type": "folder"
		},
		
		# === 根目录下的文件 ===
		"/welcome.txt": {
			"type": "file",
			"content": """欢迎接入SCP基金会安全终端系统。

本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。

请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。

- 基金会信息安全部门"""
		},
		"/notice.txt": {
			"type": "file",
			"content": """[通知] 2024-01-15

所有站点人员注意：

由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。

如需紧急访问，请联系您的直属主管。

- Site-19 管理层"""
		},
		
		# === reports 文件夹下的文件 ===
		"/reports/scp_001.txt": {
			"type": "file",
			"content": """项目编号: SCP-001

项目等级: [DATA EXPUNGED]

特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]

描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
		},
		"/reports/scp_173.txt": {
			"type": "file",
			"content": """项目编号: SCP-173

项目等级: Euclid

特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。

描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
		},
		"/reports/incident_log.txt": {
			"type": "file",
			"content": """事故日志 #2024-0117

日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████

事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████

后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
		},
		
		# === personnel 文件夹下的文件 ===
		"/personnel/dr_bright.txt": {
			"type": "file",
			"content": """人员档案: Dr. Bright

安全等级: 4级
职位: 高级研究员
当前站点: Site-19

备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt

[警告: Dr. Bright的个人请求不应被认真对待]"""
		},
		"/personnel/agent_a.txt": {
			"type": "file",
			"content": """人员档案: Agent A

安全等级: 2级
职位: 外勤特工
当前站点: Site-19

状态: [color=#FF6666]失联[/color]

最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42

备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
		},
		
		# === comms 文件夹下的文件 ===
		"/comms/radio_log.txt": {
			"type": "file",
			"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17

[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
		}
	}
```

## 2.3 保存并运行测试

按 `Ctrl+S` 保存脚本和场景，然后按 `F5` 运行。

你现在应该可以测试以下功能：

**测试命令清单：**

```
help          → 应显示命令帮助列表
ls            → 应列出根目录下的3个文件夹和2个文件
cd reports    → 应切换到 /reports 目录，状态栏更新
ls            → 应列出 reports 下的3个文件
open scp_173.txt  → 应显示SCP-173的文档内容
back          → 应返回根目录
cd /personnel → 应切换到 /personnel（绝对路径）
cd ..         → 应返回根目录
clear         → 应清空屏幕
status        → 应显示用户状态
whoami        → 应显示用户信息
exit          → 应退出程序
```

还可以测试：
- 按 `↑` `↓` 翻阅历史命令
- 按 `Tab` 自动补全（输入 `he` 然后按Tab应补全为 `help`）
- 输入不存在的命令（应显示红色错误提示）
- `PageUp` / `PageDown` 滚动内容

---

运行后把结果告诉我（截图或描述），不管成功还是有报错都告诉我，我会帮你处理。确认没问题后我们继续 **步骤3：CRT Shader效果**。

### USER
发生了报错，为这一行
var remainder := key.substr(prefix.length())
报错为：
ERROR: res://scripts/main.gd:551 - Parse Error: Cannot infer the type of "remainder" variable because the value doesn't have a set type.

### ASSISTANT
这个错误是因为 `substr()` 在某些情况下返回类型不够明确，Godot的类型推断失败了。修复很简单，把 `:=` 改为显式声明类型即可。

## 修复方法

找到 `main.gd` 中大约第551行，把这一行：

```gdscript
var remainder := key.substr(prefix.length())
```

改为：

```gdscript
var remainder: String = key.substr(prefix.length())
```

就是把 `:=`（自动推断类型）改成了 `: String =`（手动指定类型为String）。

---

## 顺便检查同类问题

在同一个文件中搜索一下，把所有可能出现同类问题的 `:=` 也预防性地修改一下。找到以下几处（如果有的话）：

**`_on_command_submitted` 函数中：**
```gdscript
# 原来
var raw_input := command_text.strip_edges()
# 改为
var raw_input: String = command_text.strip_edges()
```

**`_execute_command` 函数中：**
```gdscript
# 原来
var command := parts[0].to_lower()
# 改为
var command: String = parts[0].to_lower()
```

**`_auto_complete` 函数中：**
```gdscript
# 原来
var current_text := input_field.text.strip_edges()
# 改为
var current_text: String = input_field.text.strip_edges()

# 原来
var partial_cmd := parts[0].to_lower()
# 改为
var partial_cmd: String = parts[0].to_lower()

# 原来
var partial_name := parts[1]
# 改为
var partial_name: String = parts[1]
```

**`_get_parent_path` 函数中：**
```gdscript
# 原来
var clean_path := path.rstrip("/")
var last_slash := clean_path.rfind("/")
# 改为
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
```

---

**简单总结规则**：在GDScript中，当你对一个变量的类型很确定时，用 `var x: 类型 = 值` 比 `var x := 值` 更安全，可以避免类型推断失败的问题。

修改完成后 `Ctrl+S` 保存，`F5` 运行，看看是否还有报错。

### USER
出现了问题，命令只能输入一次，无法输入第二次

### ASSISTANT
这个问题是因为 `_input` 函数中捕获了键盘事件后，`input_field` 失去了焦点或者按键事件被拦截了。让我们修复。

## 修复方法

找到 `main.gd` 中的 `_input` 函数，把整个函数替换为：

```gdscript
func _input(event: InputEvent) -> void:
	# 只在输入框有焦点时处理特殊按键
	if not input_field.has_focus():
		# 如果输入框没有焦点，任意按键都让它重新获得焦点
		if event is InputEventKey and event.pressed:
			input_field.grab_focus()
		return
	
	if event is InputEventKey and event.pressed:
		match event.keycode:
			KEY_UP:
				_history_previous()
				get_viewport().set_input_as_handled()
			KEY_DOWN:
				_history_next()
				get_viewport().set_input_as_handled()
			KEY_PAGEUP:
				scroll_container.scroll_vertical -= 100
				get_viewport().set_input_as_handled()
			KEY_PAGEDOWN:
				scroll_container.scroll_vertical += 100
				get_viewport().set_input_as_handled()
			KEY_TAB:
				_auto_complete()
				get_viewport().set_input_as_handled()
```

然后找到 `_on_command_submitted` 函数，确认里面有重新聚焦的代码，并且把滚动到底部的逻辑也稍微调整一下。把整个函数替换为：

```gdscript
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	
	# 清空输入框
	input_field.clear()
	
	# 如果输入为空，忽略
	if raw_input.is_empty():
		input_field.grab_focus()
		return
	
	# 将命令存入历史记录
	command_history.append(raw_input)
	history_index = -1
	
	# 在输出区域显示用户输入的命令（模拟终端回显）
	append_output("> " + raw_input)
	
	# 解析并执行命令
	_execute_command(raw_input)
	
	# 滚动到底部并重新聚焦输入框
	_scroll_to_bottom()


# 滚动到底部（独立函数，方便复用）
func _scroll_to_bottom() -> void:
	# 等待一帧让内容渲染完成
	await get_tree().process_frame
	scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value
	# 确保输入框始终获得焦点
	input_field.grab_focus()
```

注意这里新增了一个 `_scroll_to_bottom()` 函数，你可以把它放在 `_on_command_submitted` 的下方。

最后，在 `_ready` 函数的末尾补一个保险措施，确保点击屏幕任意位置后焦点也会回到输入框。找到 `_ready` 函数，在最后面（`_show_welcome_message()` 之后）加上这一段：

```gdscript
	# 点击屏幕任意位置都让输入框获得焦点
	gui_input.connect(_on_main_clicked)


func _on_main_clicked(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		input_field.grab_focus()
```

---

## 总结一下改了什么

1. **`_input` 函数**：加了焦点检测，没焦点时自动恢复焦点
2. **`_on_command_submitted` 函数**：把滚动逻辑提取为独立函数 `_scroll_to_bottom()`，在滚动完成后确保重新聚焦
3. **`_ready` 函数末尾**：加了鼠标点击事件，点击任何地方都恢复输入框焦点

保存后 `F5` 运行，试试连续输入多条命令是否正常。

### USER
发生了报错错误 (155, 29)： Identifier "command_text" not declared in the current scope.

### ASSISTANT
这个错误说明函数参数名对不上了。可能是替换时函数签名出了问题。

## 修复方法

找到 `_on_command_submitted` 函数，确认函数的完整写法是这样的：

```gdscript
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
```

如果你看到的是类似这样（缺少参数）：

```gdscript
func _on_command_submitted() -> void:
	var raw_input: String = command_text.strip_edges()
```

那就是参数丢失了。

---

## 最稳妥的做法

请把整个 `_on_command_submitted` 和 `_scroll_to_bottom` 这两个函数找到，**整体删除**，然后用下面的代码替换：

```gdscript
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	
	# 清空输入框
	input_field.clear()
	
	# 如果输入为空，忽略
	if raw_input.is_empty():
		input_field.grab_focus()
		return
	
	# 将命令存入历史记录
	command_history.append(raw_input)
	history_index = -1
	
	# 在输出区域显示用户输入的命令（模拟终端回显）
	append_output("> " + raw_input)
	
	# 解析并执行命令
	_execute_command(raw_input)
	
	# 滚动到底部并重新聚焦输入框
	_scroll_to_bottom()


func _scroll_to_bottom() -> void:
	await get_tree().process_frame
	scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value
	input_field.grab_focus()
```

**关键检查点**：确认第一行 `func _on_command_submitted(command_text: String) -> void:` 括号里面有 `command_text: String` 这个参数。

保存后 `F5` 运行试试。

### USER
又报错
错误 (157, 29)： Identifier "command_text" not declared in the current scope.
下面是完整代码，你仔细检查一下，然后把需要更正好的那部分代码给我
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
# ============================================================
# 状态变量
# ============================================================
# 当前所在路径
var current_path: String = "/"
# 是否有新邮件
var has_new_mail: bool = false
# 命令历史记录
var command_history: Array[String] = []
# 当前在历史记录中的位置（-1表示不在历史中，正在输入新命令）
var history_index: int = -1
# 临时保存用户正在输入的文本（在翻阅历史时保留）
var current_input_backup: String = ""
# ============================================================
# 虚拟文件系统
# ============================================================
# 用字典模拟文件系统结构
# 每个键是路径名，值是一个字典：
#   "type": "folder" 或 "file"
#   "children": 子项数组（仅文件夹有）
#   "content": 文件内容文本（仅文件有）
var file_system: Dictionary = {}
# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
# 初始化虚拟文件系统（内置测试数据，后续会替换为ZIP读取）
_init_test_file_system()
# 清空输出区域
output_text.text = ""
output_text.bbcode_enabled = true
# 连接输入框的信号：当用户按回车时触发
input_field.text_submitted.connect(_on_command_submitted)
# 让输入框自动获得焦点（光标直接在输入框中闪烁）
input_field.grab_focus()
# 更新状态栏显示
_update_status_bar()
# 显示欢迎信息
_show_welcome_message()
# 点击屏幕任意位置都让输入框获得焦点
gui_input.connect(_on_main_clicked)
func _on_main_clicked(event: InputEvent) -> void:
if event is InputEventMouseButton and event.pressed:
input_field.grab_focus()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 只在输入框有焦点时处理特殊按键
if not input_field.has_focus():
# 如果输入框没有焦点，任意按键都让它重新获得焦点
if event is InputEventKey and event.pressed:
input_field.grab_focus()
return
if event is InputEventKey and event.pressed:
match event.keycode:
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
if event is InputEventKey and event.pressed:
match event.keycode:
KEY_UP:
# 按↑键：翻阅上一条历史命令
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
# 按↓键：翻阅下一条历史命令
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
# PageUp：向上滚动输出内容
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
# PageDown：向下滚动输出内容
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
# Tab键：自动补全（后续实现）
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
# 清空输入框
input_field.clear()
# 如果输入为空，忽略
if raw_input.is_empty():
input_field.grab_focus()
return
# 将命令存入历史记录
command_history.append(raw_input)
history_index = -1
# 在输出区域显示用户输入的命令（模拟终端回显）
append_output("> " + raw_input)
# 解析并执行命令
_execute_command(raw_input)
# 滚动到底部并重新聚焦输入框
_scroll_to_bottom()
func _scroll_to_bottom() -> void:
await get_tree().process_frame
scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value
input_field.grab_focus()
# 等待一帧让内容渲染完成
await get_tree().process_frame
scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value
# 确保输入框始终获得焦点
input_field.grab_focus()
# 获取用户输入并去除首尾空格
var raw_input: String = command_text.strip_edges()
# 清空输入框
input_field.clear()
# 重新聚焦输入框
input_field.grab_focus()
# 如果输入为空，忽略
if raw_input.is_empty():
return
# 将命令存入历史记录
command_history.append(raw_input)
history_index = -1
# 在输出区域显示用户输入的命令（模拟终端回显）
append_output("> " + raw_input)
# 解析并执行命令
_execute_command(raw_input)
# 每次命令执行后滚动到底部
await get_tree().process_frame
scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
# 将输入按空格分割为命令和参数
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
# 第一个词是命令，转为小写
var command: String = parts[0].to_lower()
# 剩余部分是参数
var args := parts.slice(1)
# 根据命令分发执行
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
_cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
_cmd_exit()
"whoami":
_cmd_whoami()
_:
# 未知命令
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]")
append_output("输入 [color=#66FF66]help[/color] 查看可用命令。")
# ============================================================
# 各命令的具体实现
# ============================================================
# --- help 命令 ---
func _cmd_help() -> void:
var help_text := """[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]
  [color=#66FF66]help[/color]          显示本帮助信息
  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹
  [color=#66FF66]cd <路径>[/color]     切换到指定目录
  [color=#66FF66]back[/color]          返回上一级目录
  [color=#66FF66]open <文件>[/color]   打开并显示文件内容
  [color=#66FF66]clear[/color]         清空屏幕
  [color=#66FF66]status[/color]        查看当前用户状态
  [color=#66FF66]mail[/color]          查看收件箱
  [color=#66FF66]whoami[/color]        查看当前用户信息
  [color=#66FF66]exit[/color]          退出终端
[color=#66FF66]═══════════════════════════════════════════════[/color]
[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]"""
append_output(help_text)
# --- ls 命令 ---
func _cmd_ls() -> void:
# 获取当前路径下的所有子项
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
append_output("[color=#66FF66]目录: " + current_path + "[/color]")
append_output("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
if node.type == "folder":
# 文件夹用 [DIR] 标记，蓝色显示
append_output("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
# 文件显示文件名
append_output("  [color=#33FF33][FILE] " + item + "[/color]")
append_output("")
# --- cd 命令 ---
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
# 处理特殊路径
if target == "/":
new_path = "/"
elif target == "..":
# 返回上一级
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
# 绝对路径
new_path = target
else:
# 相对路径
new_path = _join_path(current_path, target)
# 标准化路径
new_path = _normalize_path(new_path)
# 检查目标路径是否存在且是文件夹
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
# 切换路径
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path)
# --- open 命令 ---
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 显示文件内容
append_output("[color=#66FF66]══════════ " + filename + " ══════════[/color]")
append_output("")
append_output(node.content)
append_output("")
append_output("[color=#66FF66]══════════ 文件结束 ══════════[/color]")
# --- back 命令 ---
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path)
# --- clear 命令 ---
func _cmd_clear() -> void:
output_text.text = ""
# --- status 命令 ---
func _cmd_status() -> void:
var status_text := """[color=#66FF66]═══════════ 用户状态 ═══════════[/color]
  用户名:     [color=#66FF66]未登录[/color]
  权限等级:   [color=#FFB000]0[/color]
  当前路径:   [color=#66FF66]{path}[/color]
  已读文件:   [color=#66FF66]0[/color]
  已获取密码: [color=#66FF66]0[/color]
[color=#66FF66]════════════════════════════════[/color]"""
status_text = status_text.replace("{path}", current_path)
append_output(status_text)
# --- mail 命令 ---
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。[/color]")
append_output("[color=#AAAAAA](邮件系统将在后续版本中实现)[/color]")
# --- exit 命令 ---
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
# 延迟1秒后退出
await get_tree().create_timer(1.0).timeout
get_tree().quit()
# --- whoami 命令 ---
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]")
append_output("[color=#AAAAAA](用户系统将在后续版本中实现)[/color]")
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
# 如果是第一次按↑，备份当前输入
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
# 将光标移到末尾
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
# 已经到最新一条，恢复用户之前输入的内容
history_index = -1
input_field.text = current_input_backup
# 将光标移到末尾
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（基础版）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text.strip_edges()
if current_text.is_empty():
return
# 将输入按空格分割
var parts := current_text.split(" ", false)
# 如果只有一个词，尝试补全命令
if parts.size() == 1:
var partial_cmd: String = parts[0].to_lower()
var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
# 唯一匹配，直接补全
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
# 多个匹配，显示所有候选
append_output("[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
# 如果有两个词（命令+部分参数），尝试补全文件名/文件夹名
elif parts.size() == 2:
var cmd := parts[0].to_lower()
var partial_name: String = parts[1]
# 只对 cd、open、cat 命令补全文件名
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
append_output("[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
# ============================================================
# 输出工具函数
# ============================================================
# 向输出区域追加一行文本（支持BBCode）
func append_output(text: String) -> void:
if output_text.text.length() > 0:
output_text.append_text("\n")
output_text.append_text(text)
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
path_label.text = "[" + current_path + "]"
if has_new_mail:
mail_icon.text = "[✉ NEW]"
else:
mail_icon.text = "[✉]"
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var welcome := """[color=#66FF66]╔══════════════════════════════════════════════╗
║         SCP FOUNDATION TERMINAL v0.1         ║
║       SECURE - CONTAIN - PROTECT             ║
╚══════════════════════════════════════════════╝[/color]
[color=#AAAAAA]终端系统已启动。
输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]
"""
output_text.append_text(welcome)
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
# 拼接路径
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
# 获取父级路径
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
# 去除末尾斜杠
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
# 标准化路径（去除多余斜杠、处理 .. 等）
func _normalize_path(path: String) -> String:
# 确保以 / 开头
if not path.begins_with("/"):
path = "/" + path
# 分割路径各段
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
# 文件系统节点类（用于返回查询结果）
class FSNode:
var type: String  # "folder" 或 "file"
var content: String  # 文件内容（仅文件有）
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
# 在指定路径获取文件系统节点
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
# 根目录
if path == "/":
return FSNode.new("folder")
# 在file_system字典中查找
if file_system.has(path):
var entry: Dictionary = file_system[path]
return FSNode.new(entry.get("type", "file"), entry.get("content", ""))
return null
# 获取指定路径下的所有子项名称
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
# 确定需要匹配的前缀
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
# 检查是否是直接子项（不是更深层的）
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
# 直接子项不应包含 /（那表示是更深层的）
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 测试文件系统初始化
# ============================================================
func _init_test_file_system() -> void:
# 构建一个测试用的虚拟文件系统
# 后续会替换为从ZIP文件读取
file_system = {
# === 根目录下的文件夹 ===
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
# === 根目录下的文件 ===
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
# === reports 文件夹下的文件 ===
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
# === personnel 文件夹下的文件 ===
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
# === comms 文件夹下的文件 ===
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
我看到问题了。你的代码中有**重复的代码块**混在一起，导致结构混乱。`_scroll_to_bottom` 函数后面紧跟着一堆不属于任何函数的散落代码（是旧版 `_on_command_submitted` 的残留），还有 `_input` 函数里有两段重复的 `match` 块。

我给你**整个文件的完整修正版代码**，请把 `main.gd` 的内容**全部删除**，然后粘贴以下代码：

```gdscript
extends Control

# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea

# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""

# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}

# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
	_init_test_file_system()
	
	output_text.text = ""
	output_text.bbcode_enabled = true
	
	input_field.text_submitted.connect(_on_command_submitted)
	input_field.grab_focus()
	
	_update_status_bar()
	_show_welcome_message()
	
	gui_input.connect(_on_main_clicked)


func _on_main_clicked(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		input_field.grab_focus()


# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
	if not input_field.has_focus():
		if event is InputEventKey and event.pressed:
			input_field.grab_focus()
		return
	
	if event is InputEventKey and event.pressed:
		match event.keycode:
			KEY_UP:
				_history_previous()
				get_viewport().set_input_as_handled()
			KEY_DOWN:
				_history_next()
				get_viewport().set_input_as_handled()
			KEY_PAGEUP:
				scroll_container.scroll_vertical -= 100
				get_viewport().set_input_as_handled()
			KEY_PAGEDOWN:
				scroll_container.scroll_vertical += 100
				get_viewport().set_input_as_handled()
			KEY_TAB:
				_auto_complete()
				get_viewport().set_input_as_handled()


# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	
	input_field.clear()
	
	if raw_input.is_empty():
		input_field.grab_focus()
		return
	
	command_history.append(raw_input)
	history_index = -1
	
	append_output("> " + raw_input)
	
	_execute_command(raw_input)
	
	_scroll_to_bottom()


func _scroll_to_bottom() -> void:
	await get_tree().process_frame
	scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value
	input_field.grab_focus()


# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
	var parts := raw_input.split(" ", false)
	if parts.is_empty():
		return
	
	var command: String = parts[0].to_lower()
	var args := parts.slice(1)
	
	match command:
		"help", "?":
			_cmd_help()
		"ls", "dir":
			_cmd_ls()
		"cd":
			_cmd_cd(args)
		"open", "cat":
			_cmd_open(args)
		"back":
			_cmd_back()
		"clear", "cls":
			_cmd_clear()
		"status":
			_cmd_status()
		"mail":
			_cmd_mail(args)
		"exit", "quit":
			_cmd_exit()
		"whoami":
			_cmd_whoami()
		_:
			append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]")
			append_output("输入 [color=#66FF66]help[/color] 查看可用命令。")


# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_help() -> void:
	var help_text := """[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]
  [color=#66FF66]help[/color]          显示本帮助信息
  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹
  [color=#66FF66]cd <路径>[/color]     切换到指定目录
  [color=#66FF66]back[/color]          返回上一级目录
  [color=#66FF66]open <文件>[/color]   打开并显示文件内容
  [color=#66FF66]clear[/color]         清空屏幕
  [color=#66FF66]status[/color]        查看当前用户状态
  [color=#66FF66]mail[/color]          查看收件箱
  [color=#66FF66]whoami[/color]        查看当前用户信息
  [color=#66FF66]exit[/color]          退出终端
[color=#66FF66]═══════════════════════════════════════════════[/color]
[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]"""
	append_output(help_text)


func _cmd_ls() -> void:
	var items := _get_children_at_path(current_path)
	
	if items.is_empty():
		append_output("[color=#AAAAAA]该目录为空。[/color]")
		return
	
	append_output("[color=#66FF66]目录: " + current_path + "[/color]")
	append_output("")
	
	for item in items:
		var item_path := _join_path(current_path, item)
		var node := _get_node_at_path(item_path)
		if node == null:
			continue
		
		if node.type == "folder":
			append_output("  [color=#6699FF][DIR]  " + item + "/[/color]")
		else:
			append_output("  [color=#33FF33][FILE] " + item + "[/color]")
	
	append_output("")


func _cmd_cd(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
		return
	
	var target: String = args[0]
	var new_path: String
	
	if target == "/":
		new_path = "/"
	elif target == "..":
		new_path = _get_parent_path(current_path)
	elif target.begins_with("/"):
		new_path = target
	else:
		new_path = _join_path(current_path, target)
	
	new_path = _normalize_path(new_path)
	
	var node := _get_node_at_path(new_path)
	if node == null:
		append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
		return
	if node.type != "folder":
		append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
		return
	
	current_path = new_path
	_update_status_bar()
	append_output("已切换到: " + current_path)


func _cmd_open(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
		return
	
	var filename: String = args[0]
	var file_path: String
	
	if filename.begins_with("/"):
		file_path = filename
	else:
		file_path = _join_path(current_path, filename)
	
	file_path = _normalize_path(file_path)
	
	var node := _get_node_at_path(file_path)
	if node == null:
		append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
		return
	if node.type != "file":
		append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
		return
	
	append_output("[color=#66FF66]══════════ " + filename + " ══════════[/color]")
	append_output("")
	append_output(node.content)
	append_output("")
	append_output("[color=#66FF66]══════════ 文件结束 ══════════[/color]")


func _cmd_back() -> void:
	if current_path == "/":
		append_output("[color=#AAAAAA]已经在根目录了。[/color]")
		return
	
	current_path = _get_parent_path(current_path)
	_update_status_bar()
	append_output("已返回: " + current_path)


func _cmd_clear() -> void:
	output_text.text = ""


func _cmd_status() -> void:
	var status_text := """[color=#66FF66]═══════════ 用户状态 ═══════════[/color]
  用户名:     [color=#66FF66]未登录[/color]
  权限等级:   [color=#FFB000]0[/color]
  当前路径:   [color=#66FF66]{path}[/color]
  已读文件:   [color=#66FF66]0[/color]
  已获取密码: [color=#66FF66]0[/color]
[color=#66FF66]════════════════════════════════[/color]"""
	status_text = status_text.replace("{path}", current_path)
	append_output(status_text)


func _cmd_mail(args: Array) -> void:
	append_output("[color=#AAAAAA]收件箱为空。[/color]")
	append_output("[color=#AAAAAA](邮件系统将在后续版本中实现)[/color]")


func _cmd_exit() -> void:
	append_output("[color=#AAAAAA]正在断开连接...[/color]")
	await get_tree().create_timer(1.0).timeout
	get_tree().quit()


func _cmd_whoami() -> void:
	append_output("[color=#66FF66]未登录用户[/color]")
	append_output("[color=#AAAAAA](用户系统将在后续版本中实现)[/color]")


# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
	if command_history.is_empty():
		return
	
	if history_index == -1:
		current_input_backup = input_field.text
		history_index = command_history.size() - 1
	elif history_index > 0:
		history_index -= 1
	
	input_field.text = command_history[history_index]
	input_field.caret_column = input_field.text.length()


func _history_next() -> void:
	if command_history.is_empty() or history_index == -1:
		return
	
	if history_index < command_history.size() - 1:
		history_index += 1
		input_field.text = command_history[history_index]
	else:
		history_index = -1
		input_field.text = current_input_backup
	
	input_field.caret_column = input_field.text.length()


# ============================================================
# 自动补全（基础版）
# ============================================================
func _auto_complete() -> void:
	var current_text: String = input_field.text.strip_edges()
	if current_text.is_empty():
		return
	
	var parts := current_text.split(" ", false)
	
	if parts.size() == 1:
		var partial_cmd: String = parts[0].to_lower()
		var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
						"clear", "cls", "status", "mail", "whoami", "exit", "quit"]
		var matches: Array[String] = []
		for cmd in commands:
			if cmd.begins_with(partial_cmd):
				matches.append(cmd)
		
		if matches.size() == 1:
			input_field.text = matches[0] + " "
			input_field.caret_column = input_field.text.length()
		elif matches.size() > 1:
			append_output("[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
	
	elif parts.size() == 2:
		var cmd: String = parts[0].to_lower()
		var partial_name: String = parts[1]
		
		if cmd in ["cd", "open", "cat"]:
			var children := _get_children_at_path(current_path)
			var matches: Array[String] = []
			for child in children:
				if child.to_lower().begins_with(partial_name.to_lower()):
					matches.append(child)
			
			if matches.size() == 1:
				input_field.text = cmd + " " + matches[0]
				input_field.caret_column = input_field.text.length()
			elif matches.size() > 1:
				append_output("[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")


# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String) -> void:
	if output_text.text.length() > 0:
		output_text.append_text("\n")
	output_text.append_text(text)


# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
	path_label.text = "[" + current_path + "]"
	
	if has_new_mail:
		mail_icon.text = "[✉ NEW]"
	else:
		mail_icon.text = "[✉]"


# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
	var welcome := """[color=#66FF66

### USER
继续补充完成

### ASSISTANT
接续上面代码，从 `_show_welcome_message` 函数继续，把以下代码接在最后面：

```gdscript
func _show_welcome_message() -> void:
	var welcome := """[color=#66FF66]╔══════════════════════════════════════════════╗
║         SCP FOUNDATION TERMINAL v0.1         ║
║       SECURE - CONTAIN - PROTECT             ║
╚══════════════════════════════════════════════╝[/color]

[color=#AAAAAA]终端系统已启动。
输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]
"""
	output_text.append_text(welcome)


# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
	if base == "/":
		return "/" + child
	else:
		return base + "/" + child


func _get_parent_path(path: String) -> String:
	if path == "/":
		return "/"
	
	var clean_path: String = path.rstrip("/")
	var last_slash: int = clean_path.rfind("/")
	
	if last_slash <= 0:
		return "/"
	
	return clean_path.substr(0, last_slash)


func _normalize_path(path: String) -> String:
	if not path.begins_with("/"):
		path = "/" + path
	
	var parts := path.split("/", false)
	var resolved: Array[String] = []
	
	for part in parts:
		if part == "..":
			if resolved.size() > 0:
				resolved.pop_back()
		elif part == ".":
			continue
		else:
			resolved.append(part)
	
	if resolved.is_empty():
		return "/"
	
	return "/" + "/".join(resolved)


# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
	var type: String
	var content: String
	
	func _init(p_type: String, p_content: String = "") -> void:
		type = p_type
		content = p_content


func _get_node_at_path(path: String) -> FSNode:
	path = _normalize_path(path)
	
	if path == "/":
		return FSNode.new("folder")
	
	if file_system.has(path):
		var entry: Dictionary = file_system[path]
		return FSNode.new(entry.get("type", "file"), entry.get("content", ""))
	
	return null


func _get_children_at_path(path: String) -> Array[String]:
	path = _normalize_path(path)
	var children: Array[String] = []
	
	var prefix: String
	if path == "/":
		prefix = "/"
	else:
		prefix = path + "/"
	
	for key in file_system.keys():
		if key.begins_with(prefix):
			var remainder: String = key.substr(prefix.length())
			if not remainder.contains("/"):
				children.append(remainder)
	
	children.sort()
	return children


# ============================================================
# 测试文件系统初始化
# ============================================================
func _init_test_file_system() -> void:
	file_system = {
		"/reports": {
			"type": "folder"
		},
		"/personnel": {
			"type": "folder"
		},
		"/comms": {
			"type": "folder"
		},
		"/welcome.txt": {
			"type": "file",
			"content": """欢迎接入SCP基金会安全终端系统。

本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。

请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。

- 基金会信息安全部门"""
		},
		"/notice.txt": {
			"type": "file",
			"content": """[通知] 2024-01-15

所有站点人员注意：

由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。

如需紧急访问，请联系您的直属主管。

- Site-19 管理层"""
		},
		"/reports/scp_001.txt": {
			"type": "file",
			"content": """项目编号: SCP-001

项目等级: [DATA EXPUNGED]

特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]

描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
		},
		"/reports/scp_173.txt": {
			"type": "file",
			"content": """项目编号: SCP-173

项目等级: Euclid

特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。

描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
		},
		"/reports/incident_log.txt": {
			"type": "file",
			"content": """事故日志 #2024-0117

日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████

事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████

后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
		},
		"/personnel/dr_bright.txt": {
			"type": "file",
			"content": """人员档案: Dr. Bright

安全等级: 4级
职位: 高级研究员
当前站点: Site-19

备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt

[警告: Dr. Bright的个人请求不应被认真对待]"""
		},
		"/personnel/agent_a.txt": {
			"type": "file",
			"content": """人员档案: Agent A

安全等级: 2级
职位: 外勤特工
当前站点: Site-19

状态: [color=#FF6666]失联[/color]

最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42

备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
		},
		"/comms/radio_log.txt": {
			"type": "file",
			"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17

[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
		}
	}
```

---

**注意**：请确认你的文件中原来那个不完整的 `_show_welcome_message` 函数（以 `"""[color=#66FF66` 截断的那行）已经**删除**，用上面完整的版本替换。不要出现两个 `_show_welcome_message`。

保存后 `Ctrl+S`，然后 `F5` 运行测试。按照之前的测试清单逐一测试：

```
help       → 帮助列表
ls         → 列出文件
cd reports → 进入目录
ls         → 列出子文件
open scp_173.txt → 打开文件
back       → 返回上级
clear      → 清屏
status     → 用户状态
exit       → 退出
```

确认一切正常后告诉我，我们继续**步骤3：CRT Shader效果**。

### USER
功能基本正常，但是还有两个问题：
1.输入完指令按回车发送后，要想再次输入指令必须还要再按一下回车。需要改成可以直接输入的
2.如图，展示出来的内容挤在一起了，不是按照一次一行的规律展示。需要修改

### ASSISTANT
我看到了两个问题，让我们逐一修复。

## 问题1：按回车后需要再按一次才能输入

这是因为 `LineEdit` 的默认行为——按回车提交后它会失去焦点或进入某种状态。我们需要在提交后延迟一帧再聚焦。

## 问题2：ls 的输出挤在一行

这是因为 `append_output` 函数使用 `append_text` 追加BBCode时，`\n` 换行在BBCode模式下需要特殊处理。`append_text` 不会自动换行，我们需要改用其他方式。

---

## 修复方法

找到以下两个函数，**整体替换**为新版本：

### 替换 `append_output` 函数

找到原来的：
```gdscript
func append_output(text: String) -> void:
	if output_text.text.length() > 0:
		output_text.append_text("\n")
	output_text.append_text(text)
```

替换为：
```gdscript
func append_output(text: String) -> void:
	# 如果已有内容，先换行
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text(text)
```

这个改动不大，主要问题其实在 `_cmd_ls` 函数。`ls` 命令中每个文件都调用了一次 `append_output`，但BBCode模式下换行可能出问题。让我们改成**一次性拼接好所有内容再输出**。

### 替换 `_cmd_ls` 函数

找到原来的 `_cmd_ls`，**整体替换**为：

```gdscript
func _cmd_ls() -> void:
	var items := _get_children_at_path(current_path)
	
	if items.is_empty():
		append_output("[color=#AAAAAA]该目录为空。[/color]")
		return
	
	# 拼接所有行到一个字符串中，用换行符分隔
	var lines: Array[String] = []
	lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
	lines.append("")
	
	for item in items:
		var item_path := _join_path(current_path, item)
		var node := _get_node_at_path(item_path)
		if node == null:
			continue
		
		if node.type == "folder":
			lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
		else:
			lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
	
	lines.append("")
	
	# 一次性输出，用换行符连接
	append_output("\n".join(lines))
```

### 替换 `_cmd_help` 函数

同理，把 help 也确保格式正确：

```gdscript
func _cmd_help() -> void:
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
	lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
	lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
	lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
	lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
	lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
	lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
	lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
	lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
	lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
	lines.append("  [color=#66FF66]exit[/color]          退出终端")
	lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
	lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
	append_output("\n".join(lines))
```

### 替换 `_cmd_status` 函数

```gdscript
func _cmd_status() -> void:
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
	lines.append("  用户名:     [color=#66FF66]未登录[/color]")
	lines.append("  权限等级:   [color=#FFB000]0[/color]")
	lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
	lines.append("  已读文件:   [color=#66FF66]0[/color]")
	lines.append("  已获取密码: [color=#66FF66]0[/color]")
	lines.append("[color=#66FF66]════════════════════════════════[/color]")
	append_output("\n".join(lines))
```

### 替换 `_cmd_open` 函数

```gdscript
func _cmd_open(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
		return
	
	var filename: String = args[0]
	var file_path: String
	
	if filename.begins_with("/"):
		file_path = filename
	else:
		file_path = _join_path(current_path, filename)
	
	file_path = _normalize_path(file_path)
	
	var node := _get_node_at_path(file_path)
	if node == null:
		append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
		return
	if node.type != "file":
		append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
		return
	
	var lines: Array[String] = []
	lines.append("[color=#66FF66]══════════ " + filename + " ══════════[/color]")
	lines.append("")
	lines.append(node.content)
	lines.append("")
	lines.append("[color=#66FF66]══════════ 文件结束 ══════════[/color]")
	append_output("\n".join(lines))
```

### 替换 `_scroll_to_bottom` 函数（修复焦点问题）

```gdscript
func _scroll_to_bottom() -> void:
	await get_tree().process_frame
	scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value
	# 延迟两帧确保输入框可以正常接收输入
	await get_tree().process_frame
	input_field.grab_focus()
	# 确保光标在最前面，准备接收新输入
	input_field.caret_column = 0
```

### 替换 `_on_command_submitted` 函数（增强焦点恢复）

```gdscript
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	
	input_field.clear()
	
	if raw_input.is_empty():
		input_field.grab_focus()
		return
	
	command_history.append(raw_input)
	history_index = -1
	
	append_output("> " + raw_input)
	
	_execute_command(raw_input)
	
	_scroll_to_bottom()
	
	# 额外保险：确保输入框可编辑并聚焦
	input_field.editable = true
	input_field.grab_focus()
```

---

## 总结修改清单

| 函数 | 修改内容 |
|------|----------|
| `append_output` | 用 `get_parsed_text()` 判断是否有内容 |
| `_cmd_ls` | 改为数组拼接后一次性输出 |
| `_cmd_help` | 改为数组拼接后一次性输出 |
| `_cmd_status` | 改为数组拼接后一次性输出 |
| `_cmd_open` | 改为数组拼接后一次性输出 |
| `_scroll_to_bottom` | 增加双帧等待，确保焦点恢复 |
| `_on_command_submitted` | 末尾增加额外的焦点恢复保险 |

保存后 `Ctrl+S`，`F5` 运行，测试：
1. 输入 `help` 回车 → 应该每行独立显示
2. 输入 `ls` 回车 → 应该每个文件独占一行
3. 回车后应该可以**直接输入**下一条命令，无需再按一次回车

测试完告诉我结果！

### USER
每行独立显示的问题解决了，但排版有点丑，需要在每一次命令反馈结束后空一行；
现在仍然无法直接输入下一条命令，需要解决。
下面是我目前的完整代码，你检查一下，把需要修改的部分反馈给我。注意：不要全部发给我，这样你一次发不全！
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
_init_test_file_system()
output_text.text = ""
output_text.bbcode_enabled = true
input_field.text_submitted.connect(_on_command_submitted)
input_field.grab_focus()
_update_status_bar()
_show_welcome_message()
gui_input.connect(_on_main_clicked)
func _on_main_clicked(event: InputEvent) -> void:
if event is InputEventMouseButton and event.pressed:
input_field.grab_focus()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
if not input_field.has_focus():
if event is InputEventKey and event.pressed:
input_field.grab_focus()
return
if event is InputEventKey and event.pressed:
match event.keycode:
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
input_field.grab_focus()
return
command_history.append(raw_input)
history_index = -1
append_output("> " + raw_input)
_execute_command(raw_input)
_scroll_to_bottom()
# 额外保险：确保输入框可编辑并聚焦
input_field.editable = true
input_field.grab_focus()
func _scroll_to_bottom() -> void:
await get_tree().process_frame
scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value
# 延迟两帧确保输入框可以正常接收输入
await get_tree().process_frame
input_field.grab_focus()
# 确保光标在最前面，准备接收新输入
input_field.caret_column = 0
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
_cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
_cmd_exit()
"whoami":
_cmd_whoami()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]")
append_output("输入 [color=#66FF66]help[/color] 查看可用命令。")
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines))
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
if node.type == "folder":
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines))
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
var lines: Array[String] = []
lines.append("[color=#66FF66]══════════ " + filename + " ══════════[/color]")
lines.append("")
lines.append(node.content)
lines.append("")
lines.append("[color=#66FF66]══════════ 文件结束 ══════════[/color]")
append_output("\n".join(lines))
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path)
func _cmd_clear() -> void:
output_text.text = ""
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名:     [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]0[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]0[/color]")
lines.append("  已获取密码: [color=#66FF66]0[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines))
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。[/color]")
append_output("[color=#AAAAAA](邮件系统将在后续版本中实现)[/color]")
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]")
append_output("[color=#AAAAAA](用户系统将在后续版本中实现)[/color]")
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（基础版）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text.strip_edges()
if current_text.is_empty():
return
var parts := current_text.split(" ", false)
if parts.size() == 1:
var partial_cmd: String = parts[0].to_lower()
var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
append_output("[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
append_output("[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String) -> void:
# 如果已有内容，先换行
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text(text)
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
path_label.text = "[" + current_path + "]"
if has_new_mail:
mail_icon.text = "[✉ NEW]"
else:
mail_icon.text = "[✉]"
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var welcome := """[color=#66FF66]╔══════════════════════════════════════════════╗
║         SCP FOUNDATION TERMINAL v0.1         ║
║       SECURE - CONTAIN - PROTECT             ║
╚══════════════════════════════════════════════╝[/color]
[color=#AAAAAA]终端系统已启动。
输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]
"""
output_text.append_text(welcome)
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
return FSNode.new(entry.get("type", "file"), entry.get("content", ""))
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 测试文件系统初始化
# ============================================================
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
我看到了问题所在。只需要修改以下两处：

## 修改1：`append_output` 函数 —— 每次输出后多加一个空行

找到：
```gdscript
func append_output(text: String) -> void:
	# 如果已有内容，先换行
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text(text)
```

替换为：
```gdscript
func append_output(text: String) -> void:
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text(text)
	# 每次输出后追加一个空行，让命令之间有间隔
	output_text.append_text("\n")
```

## 修改2：`_on_command_submitted` 函数 —— 彻底解决焦点问题

问题的根本原因是：`LineEdit` 在 `text_submitted` 信号触发后，内部会处理回车键事件，导致焦点状态异常。我们需要用 `call_deferred` 延迟聚焦，而不是在信号回调中立即聚焦。

找到：
```gdscript
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	
	input_field.clear()
	
	if raw_input.is_empty():
		input_field.grab_focus()
		return
	
	command_history.append(raw_input)
	history_index = -1
	
	append_output("> " + raw_input)
	
	_execute_command(raw_input)
	
	_scroll_to_bottom()
	
	# 额外保险：确保输入框可编辑并聚焦
	input_field.editable = true
	input_field.grab_focus()
```

替换为：
```gdscript
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	
	input_field.clear()
	
	if raw_input.is_empty():
		# 用 call_deferred 延迟到当前帧处理完毕后再聚焦
		input_field.call_deferred("grab_focus")
		return
	
	command_history.append(raw_input)
	history_index = -1
	
	append_output("> " + raw_input)
	
	_execute_command(raw_input)
	
	_scroll_to_bottom()
```

## 修改3：`_scroll_to_bottom` 函数 —— 同样用 `call_deferred`

找到：
```gdscript
func _scroll_to_bottom() -> void:
	await get_tree().process_frame
	scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value
	# 延迟两帧确保输入框可以正常接收输入
	await get_tree().process_frame
	input_field.grab_focus()
	# 确保光标在最前面，准备接收新输入
	input_field.caret_column = 0
```

替换为：
```gdscript
func _scroll_to_bottom() -> void:
	await get_tree().process_frame
	scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value
	# 用 call_deferred 确保在所有内部事件处理完毕后再聚焦
	input_field.call_deferred("grab_focus")
```

---

**总结**：核心修复就是把所有 `input_field.grab_focus()` 改为 `input_field.call_deferred("grab_focus")`。这样Godot会在当前帧的所有事件处理完毕后再执行聚焦，避免和 `LineEdit` 内部的回车键处理冲突。

保存后 `Ctrl+S`，`F5` 运行测试：输入 `help` 回车后应该可以**直接输入**下一条命令，且每条命令的输出之间会有空行间隔。

### USER
现在有了空行间隔，但仍然存在问题，目前还是不能直接输入下一条命令。
而且从第三次输入命令开始，反馈输出不会自动滚到最下方；第四次输入后可以滚到最下方；第五次又不滚了；第六次又滚到最下方了…….以此循环。

### ASSISTANT
这两个问题的根本原因是一样的：`_scroll_to_bottom` 里的 `await` 导致了异步执行顺序不可控。让我们彻底换一种方案，不用 `await`。

## 修改1：删除 `_scroll_to_bottom` 函数

找到整个 `_scroll_to_bottom` 函数，**删除它**：

```gdscript
# 删除这整个函数
func _scroll_to_bottom() -> void:
	await get_tree().process_frame
	scroll_container.scroll_vertical = scroll_container.get_v_scroll_bar().max_value
	input_field.call_deferred("grab_focus")
```

## 修改2：替换 `_on_command_submitted` 函数

找到整个 `_on_command_submitted`，替换为：

```gdscript
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	
	input_field.clear()
	
	if raw_input.is_empty():
		return
	
	command_history.append(raw_input)
	history_index = -1
	
	append_output("> " + raw_input)
	
	_execute_command(raw_input)
```

## 修改3：替换 `append_output` 函数

找到整个 `append_output`，替换为：

```gdscript
func append_output(text: String) -> void:
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text(text)
	output_text.append_text("\n")
	
	# 用 set_deferred 确保在渲染完成后滚动到底部
	var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
	v_scroll.set_deferred("value", v_scroll.max_value)
```

## 修改4：替换 `_ready` 函数

找到整个 `_ready`，替换为：

```gdscript
func _ready() -> void:
	_init_test_file_system()
	
	output_text.text = ""
	output_text.bbcode_enabled = true
	
	input_field.text_submitted.connect(_on_command_submitted)
	
	# 关键：让 LineEdit 按回车后不会释放焦点
	input_field.focus_mode = Control.FOCUS_ALL
	input_field.grab_focus()
	
	_update_status_bar()
	_show_welcome_message()
	
	gui_input.connect(_on_main_clicked)
```

## 修改5：替换 `_input` 函数

找到整个 `_input`，替换为：

```gdscript
func _input(event: InputEvent) -> void:
	if event is InputEventKey and event.pressed:
		# 如果输入框没焦点，先抢回焦点
		if not input_field.has_focus():
			input_field.grab_focus()
			# 如果按的不是特殊键，直接返回让输入框处理
			if event.keycode not in [KEY_UP, KEY_DOWN, KEY_PAGEUP, KEY_PAGEDOWN, KEY_TAB]:
				return
		
		match event.keycode:
			KEY_UP:
				_history_previous()
				get_viewport().set_input_as_handled()
			KEY_DOWN:
				_history_next()
				get_viewport().set_input_as_handled()
			KEY_PAGEUP:
				scroll_container.scroll_vertical -= 100
				get_viewport().set_input_as_handled()
			KEY_PAGEDOWN:
				scroll_container.scroll_vertical += 100
				get_viewport().set_input_as_handled()
			KEY_TAB:
				_auto_complete()
				get_viewport().set_input_as_handled()
```

## 修改6：替换 `_on_main_clicked` 函数

找到原来的，替换为：

```gdscript
func _on_main_clicked(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		input_field.grab_focus()
```

然后**新增**一个 `_process` 函数（放在 `_on_main_clicked` 后面）：

```gdscript
# 每帧确保输入框始终持有焦点
func _process(_delta: float) -> void:
	if not input_field.has_focus():
		input_field.grab_focus()
```

---

## 总结

| 操作 | 说明 |
|------|------|
| 删除 `_scroll_to_bottom` | 去掉 `await` 造成的异步问题 |
| 修改 `append_output` | 用 `set_deferred` 滚动，不依赖 `await` |
| 简化 `_on_command_submitted` | 去掉手动聚焦代码 |
| 新增 `_process` | 每帧检查并恢复焦点，彻底解决输入问题 |
| 修改 `_ready` | 设置 `focus_mode` |
| 修改 `_input` | 简化焦点恢复逻辑 |

保存 `Ctrl+S`，`F5` 运行测试。这次应该可以连续输入命令，并且每次输出都会自动滚到底部。

### USER
还是没有解决，无法连续输入命令，且输出不会自动回滚到底部，我给出我的完整代码，你仔细检查并给出需要修改的部分。注意：不要把全部代码给我，否则会回复不全！
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
_init_test_file_system()
output_text.text = ""
output_text.bbcode_enabled = true
input_field.text_submitted.connect(_on_command_submitted)
# 关键：让 LineEdit 按回车后不会释放焦点
input_field.focus_mode = Control.FOCUS_ALL
input_field.grab_focus()
_update_status_bar()
_show_welcome_message()
gui_input.connect(_on_main_clicked)
func _on_main_clicked(event: InputEvent) -> void:
if event is InputEventMouseButton and event.pressed:
input_field.grab_focus()
# 每帧确保输入框始终持有焦点
func _process(_delta: float) -> void:
if not input_field.has_focus():
input_field.grab_focus()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
if event is InputEventKey and event.pressed:
# 如果输入框没焦点，先抢回焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果按的不是特殊键，直接返回让输入框处理
if event.keycode not in [KEY_UP, KEY_DOWN, KEY_PAGEUP, KEY_PAGEDOWN, KEY_TAB]:
return
match event.keycode:
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
command_history.append(raw_input)
history_index = -1
append_output("> " + raw_input)
_execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
_cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
_cmd_exit()
"whoami":
_cmd_whoami()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]")
append_output("输入 [color=#66FF66]help[/color] 查看可用命令。")
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines))
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
if node.type == "folder":
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines))
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
var lines: Array[String] = []
lines.append("[color=#66FF66]══════════ " + filename + " ══════════[/color]")
lines.append("")
lines.append(node.content)
lines.append("")
lines.append("[color=#66FF66]══════════ 文件结束 ══════════[/color]")
append_output("\n".join(lines))
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path)
func _cmd_clear() -> void:
output_text.text = ""
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名:     [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]0[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]0[/color]")
lines.append("  已获取密码: [color=#66FF66]0[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines))
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。[/color]")
append_output("[color=#AAAAAA](邮件系统将在后续版本中实现)[/color]")
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]")
append_output("[color=#AAAAAA](用户系统将在后续版本中实现)[/color]")
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（基础版）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text.strip_edges()
if current_text.is_empty():
return
var parts := current_text.split(" ", false)
if parts.size() == 1:
var partial_cmd: String = parts[0].to_lower()
var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
append_output("[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
append_output("[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String) -> void:
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text(text)
output_text.append_text("\n")
# 用 set_deferred 确保在渲染完成后滚动到底部
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
v_scroll.set_deferred("value", v_scroll.max_value)
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
path_label.text = "[" + current_path + "]"
if has_new_mail:
mail_icon.text = "[✉ NEW]"
else:
mail_icon.text = "[✉]"
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var welcome := """[color=#66FF66]╔══════════════════════════════════════════════╗
║         SCP FOUNDATION TERMINAL v0.1         ║
║       SECURE - CONTAIN - PROTECT             ║
╚══════════════════════════════════════════════╝[/color]
[color=#AAAAAA]终端系统已启动。
输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]
"""
output_text.append_text(welcome)
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
return FSNode.new(entry.get("type", "file"), entry.get("content", ""))
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 测试文件系统初始化
# ============================================================
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
我仔细分析了你的代码，问题出在两个地方：

1. **无法连续输入**：`_process` 中每帧 `grab_focus()` 与 `LineEdit` 内部回车处理冲突。真正的原因是 Godot 的 `LineEdit` 在 `text_submitted` 后会内部处理回车键，我们需要换一种方式监听输入。

2. **滚动不到底部**：`set_deferred` 执行时 `max_value` 还没更新，因为RichTextLabel的内容高度要到下一帧才能计算好。

## 修改1：替换 `_ready` 函数

找到原来的 `_ready`，替换为：

```gdscript
func _ready() -> void:
	_init_test_file_system()
	
	output_text.text = ""
	output_text.bbcode_enabled = true
	
	# 不再用 text_submitted 信号，改为手动监听回车键
	input_field.grab_focus()
	
	_update_status_bar()
	_show_welcome_message()
```

## 修改2：删除 `_on_main_clicked` 和 `_process`

找到以下两个函数，**全部删除**：

```gdscript
# 删除这个
func _on_main_clicked(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		input_field.grab_focus()

# 删除这个
func _process(_delta: float) -> void:
	if not input_field.has_focus():
		input_field.grab_focus()
```

## 修改3：替换 `_input` 函数

找到原来的 `_input`，替换为：

```gdscript
func _input(event: InputEvent) -> void:
	if not event is InputEventKey or not event.pressed:
		return
	
	# 点击任何键都确保输入框有焦点
	if not input_field.has_focus():
		input_field.grab_focus()
	
	match event.keycode:
		KEY_ENTER, KEY_KP_ENTER:
			# 手动处理回车键提交命令
			var command_text: String = input_field.text
			input_field.clear()
			_on_command_submitted(command_text)
			# 阻止 LineEdit 内部再处理这个回车
			get_viewport().set_input_as_handled()
		KEY_UP:
			_history_previous()
			get_viewport().set_input_as_handled()
		KEY_DOWN:
			_history_next()
			get_viewport().set_input_as_handled()
		KEY_PAGEUP:
			scroll_container.scroll_vertical -= 100
			get_viewport().set_input_as_handled()
		KEY_PAGEDOWN:
			scroll_container.scroll_vertical += 100
			get_viewport().set_input_as_handled()
		KEY_TAB:
			_auto_complete()
			get_viewport().set_input_as_handled()
```

## 修改4：替换 `_on_command_submitted` 函数

找到原来的，替换为：

```gdscript
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	
	if raw_input.is_empty():
		return
	
	command_history.append(raw_input)
	history_index = -1
	
	append_output("> " + raw_input)
	
	_execute_command(raw_input)
```

## 修改5：替换 `append_output` 函数

找到原来的，替换为：

```gdscript
var _needs_scroll: bool = false

func append_output(text: String) -> void:
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text(text)
	output_text.append_text("\n")
	
	# 标记需要滚动，在下一帧处理
	if not _needs_scroll:
		_needs_scroll = true
		_do_scroll.call_deferred()


func _do_scroll() -> void:
	# 等待两帧确保RichTextLabel内容高度已更新
	await get_tree().process_frame
	await get_tree().process_frame
	var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
	scroll_container.scroll_vertical = int(v_scroll.max_value)
	_needs_scroll = false
```

注意 `var _needs_scroll: bool = false` 这一行是**成员变量**，要放在文件顶部的状态变量区域。找到：

```gdscript
var current_input_backup: String = ""
```

在它下面加一行：

```gdscript
var _needs_scroll: bool = false
```

---

## 总结修改清单

| 操作 | 说明 |
|------|------|
| 修改 `_ready` | 移除 `text_submitted` 信号连接和 `gui_input` 连接 |
| 删除 `_on_main_clicked` | 不再需要 |
| 删除 `_process` | 不再每帧强制聚焦 |
| 重写 `_input` | 手动拦截回车键，阻止 LineEdit 内部处理 |
| 简化 `_on_command_submitted` | 移除焦点相关代码 |
| 重写 `append_output` | 用两帧等待确保滚动正确 |
| 新增 `_do_scroll` 函数 | 专门处理延迟滚动 |
| 新增 `_needs_scroll` 变量 | 防止重复触发滚动 |

保存 `Ctrl+S`，`F5` 测试。这次回车是被我们手动拦截处理的，不再经过 LineEdit 的内部逻辑，所以焦点不会丢失。

### USER
解决了，非常感谢。
在**阶段一：基础框架（MVP）**里，
*   Godot项目基础搭建、场景树结构
    
*   基础CRT Shader实现与渲染管线
    
*   命令行输入框与基础命令解析（ls、cd、open、back、clear、help、exit）
    
*   ZIP文件读取与虚拟文件系统
    
*   基础TXT文件显示（纯文本，暂无CRT-ML解析）
    
*   打字机效果
    
*   状态栏
    
下一步我该干什么？帮我给出一个适当的工作流程，我明天再来继续

### ASSISTANT
太好了！让我帮你梳理一下进度和接下来的工作流程。

---

## 当前完成情况

| 项目 | 状态 |
|------|------|
| ✅ Godot项目基础搭建、场景树结构 | 已完成 |
| ✅ 命令行输入框与基础命令解析 | 已完成（ls、cd、open、back、clear、help、exit、status、mail、whoami） |
| ✅ 状态栏 | 已完成（路径显示、邮件图标） |
| ⬜ 基础CRT Shader实现与渲染管线 | 未开始 |
| ⬜ ZIP文件读取与虚拟文件系统 | 未开始（目前用内置测试数据） |
| ⬜ 基础TXT文件显示 | 部分完成（能显示，但没有打字机效果） |
| ⬜ 打字机效果 | 未开始 |

---

## 建议的后续工作流程

明天按这个顺序来做，每一步都是独立的小目标：

```
步骤3：CRT Shader效果
  └── 给 CRTShader 节点编写着色器
  └── 实现扫描线、屏幕弯曲、磷光、噪点等效果
  └── 预计工作量：★★☆ 中等

步骤4：打字机效果
  └── 文字逐字显示，模拟终端输出
  └── 修改 append_output 函数，加入逐字动画
  └── 打字机速度可调
  └── 预计工作量：★★☆ 中等

步骤5：ZIP文件读取与虚拟文件系统
  └── 读取 .scp（实际是zip）文件
  └── 解析 manifest.cfg
  └── 将ZIP内容映射为虚拟文件系统（替换当前的测试数据）
  └── 预计工作量：★★★ 较重

步骤6：基础TXT文件显示完善
  └── 纯文本正确显示（编码处理、换行处理）
  └── 从ZIP中读取的txt正确渲染
  └── 预计工作量：★☆☆ 轻量
```

---

## 建议明天的目标

**如果时间充裕**：完成步骤3（CRT Shader）+ 步骤4（打字机效果）

**如果时间有限**：先完成步骤3（CRT Shader），因为它对视觉效果影响最大，做完后成就感最强

---

## 明天开始前的准备

不需要做任何准备，明天来了直接说 **"继续步骤3：CRT Shader效果"** 就行，我会像今天一样一步一步带你做。

今天做得很好，核心框架已经跑起来了！👍

### USER
继续步骤3：CRT Shader效果

### ASSISTANT
好的，开始步骤3！CRT Shader会让整个终端看起来像老式CRT显示器。

---

# 阶段一 · 步骤3：CRT Shader效果

## 3.1 创建Shader文件

1. 在文件系统中创建 `res://shaders/` 文件夹
2. 在该文件夹中右键 → `新建资源` → 搜索不到也没关系，我们直接新建文件
3. 右键 `res://shaders/` → `新建` → `Shader`，命名为 `crt_effect.gdshader`

或者更简单的方法：
1. 在Godot编辑器中，选中场景树里的 **`CRTShader`** 节点（在CRTEffect下面的那个ColorRect）
2. 在检查器中找到 `Material` 属性
3. 点击 `<空>` → `新建 ShaderMaterial`
4. 点击刚创建的 ShaderMaterial 展开它
5. 找到 `Shader` 属性，点击 `<空>` → `新建 Shader`
6. 点击刚创建的 Shader，会打开底部的Shader编辑器

## 3.2 编写CRT Shader代码

在底部打开的Shader编辑器中，**清空所有内容**，粘贴以下代码：

```glsl
shader_type canvas_item;

// ============================================================
// CRT 效果参数 - 可在检查器中实时调节
// ============================================================

// --- 扫描线 ---
uniform float scanline_intensity : hint_range(0.0, 1.0) = 0.15;
uniform float scanline_frequency : hint_range(100.0, 800.0) = 300.0;
uniform float scanline_speed : hint_range(0.0, 5.0) = 1.0;

// --- 屏幕弯曲 ---
uniform float curvature : hint_range(0.0, 10.0) = 2.5;

// --- 色差/色散 ---
uniform float chromatic_aberration : hint_range(0.0, 5.0) = 0.8;

// --- 暗角 ---
uniform float vignette_intensity : hint_range(0.0, 2.0) = 0.4;
uniform float vignette_size : hint_range(0.0, 1.0) = 0.6;

// --- 闪烁 ---
uniform float flicker_intensity : hint_range(0.0, 0.2) = 0.03;
uniform float flicker_speed : hint_range(0.0, 20.0) = 8.0;

// --- 噪点 ---
uniform float noise_intensity : hint_range(0.0, 0.5) = 0.04;

// --- 磷光/辉光 ---
uniform float glow_intensity : hint_range(0.0, 1.0) = 0.15;

// --- 亮度 ---
uniform float brightness : hint_range(0.5, 2.0) = 1.1;
uniform float contrast : hint_range(0.5, 2.0) = 1.1;

// ============================================================
// 工具函数
// ============================================================

// 伪随机数生成
float random(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

// 屏幕弯曲变形 UV
vec2 curve_uv(vec2 uv) {
    vec2 centered = uv * 2.0 - 1.0;
    float dist = dot(centered, centered);
    centered *= 1.0 + dist * curvature * 0.02;
    return centered * 0.5 + 0.5;
}

// ============================================================
// 主片段着色器
// ============================================================
void fragment() {
    // --- 1. 屏幕弯曲 ---
    vec2 uv = curve_uv(SCREEN_UV);

    // 超出屏幕范围的部分显示为黑色（弯曲后的边角）
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        COLOR = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }

    // --- 2. 色差（RGB通道微小偏移）---
    float aberration = chromatic_aberration * 0.001;
    float r = texture(SCREEN_TEXTURE, vec2(uv.x + aberration, uv.y)).r;
    float g = texture(SCREEN_TEXTURE, uv).g;
    float b = texture(SCREEN_TEXTURE, vec2(uv.x - aberration, uv.y)).b;
    vec3 col = vec3(r, g, b);

    // --- 3. 扫描线 ---
    float scanline_y = uv.y * scanline_frequency + TIME * scanline_speed;
    float scanline = sin(scanline_y * 3.14159) * 0.5 + 0.5;
    scanline = pow(scanline, 1.5);
    col *= 1.0 - scanline_intensity * (1.0 - scanline);

    // --- 4. 移动扫描线（模拟CRT刷新）---
    float rolling_line = sin(uv.y * 3.0 + TIME * 0.5) * 0.5 + 0.5;
    rolling_line = pow(rolling_line, 20.0);
    col += col * rolling_line * 0.02;

    // --- 5. 噪点 ---
    float noise = random(uv * TIME) * noise_intensity;
    col += noise;

    // --- 6. 闪烁 ---
    float flicker = 1.0 + sin(TIME * flicker_speed) * flicker_intensity;
    col *= flicker;

    // --- 7. 暗角 ---
    vec2 vig_uv = uv * (1.0 - uv);
    float vig = vig_uv.x * vig_uv.y * 15.0;
    vig = pow(vig, vignette_intensity);
    vig = mix(vignette_size, 1.0, vig);
    col *= vig;

    // --- 8. 磷光/辉光 ---
    vec3 glow = texture(SCREEN_TEXTURE, uv).rgb;
    float glow_amount = dot(glow, vec3(0.299, 0.587, 0.114));
    col += col * glow_amount * glow_intensity;

    // --- 9. 亮度和对比度 ---
    col = (col - 0.5) * contrast + 0.5;
    col *= brightness;

    // --- 10. 钳制颜色范围 ---
    col = clamp(col, 0.0, 1.0);

    COLOR = vec4(col, 1.0);
}
```

## 3.3 设置CRTShader节点

现在需要让这个Shader能"看到"整个屏幕。选中 **`CRTShader`** 节点（CRTEffect/CRTShader），在检查器中：

1. **确认 Material 已设置**：应该能看到我们刚才创建的 ShaderMaterial

2. **设置全屏覆盖**：
   - `Position` → `x: 0, y: 0`
   - `Size` → `x: 1152, y: 648`（匹配你的窗口大小）
   - `Color` → 设为白色 `#FFFFFF`（不要透明，否则Shader不渲染）

3. **关键设置 —— 让Shader能采样屏幕**：
   - 选中 `CRTShader` 节点
   - 在检查器顶部找到 `Material` → 点开 ShaderMaterial
   - 往下看有没有报错

如果Shader编辑器底部显示红色错误提到 `SCREEN_TEXTURE`，说明Godot 4.x需要用不同方式获取屏幕纹理。让我们修改。

## 3.4 适配Godot 4.x的屏幕纹理

在Godot 4.x中，`SCREEN_TEXTURE` 需要声明为 `sampler2D`。把Shader代码最顶部（`shader_type canvas_item;` 的下面）加上这一行：

找到：
```glsl
shader_type canvas_item;

// ============================================================
// CRT 效果参数 - 可在检查器中实时调节
```

替换为：
```glsl
shader_type canvas_item;

// Godot 4.x 需要显式声明屏幕纹理
uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

// ============================================================
// CRT 效果参数 - 可在检查器中实时调节
```

## 3.5 设置CanvasLayer确保覆盖层正确

选中 **`CRTEffect`** 节点（CanvasLayer）：

1. 检查器中 `Layer` 设置为 `10`

然后选中 **`CRTShader`** 节点，我们需要确保它的大小跟随窗口。在检查器中：

1. 点开 `Material` → 点开 `ShaderMaterial` → 你应该能看到所有uniform参数，可以实时调节

## 3.6 让CRTShader自动适配窗口大小

我们需要写一小段脚本让CRTShader始终铺满屏幕。

1. 选中 **`CRTShader`** 节点
2. 点击「附加脚本」
3. 路径设为 `res://scripts/crt_shader.gd`
4. 模板选「空」
5. 写入以下代码：

```gdscript
extends ColorRect

func _ready() -> void:
	# 初始化大小为窗口大小
	_update_size()
	# 监听窗口大小变化
	get_tree().root.size_changed.connect(_update_size)


func _update_size() -> void:
	var viewport_size: Vector2 = get_viewport_rect().size
	position = Vector2.ZERO
	size = viewport_size
```

## 3.7 保存并运行测试

按 `Ctrl+S` 保存所有文件，`F5` 运行。

你应该看到：
- 屏幕有轻微的**弯曲效果**（边缘略微弯曲）
- 可以看到细密的**扫描线**在缓缓移动
- 屏幕**四角略暗**（暗角效果）
- 有轻微的**闪烁**
- 文字有轻微的**色差**（RGB边缘分离）
- 有细微的**噪点**

## 3.8 调节参数

如果效果太强或太弱，可以这样调：

1. 选中 `CRTShader` 节点
2. 检查器中点开 `Material` → 点开 `ShaderMaterial`
3. 下面会列出所有 `Shader Parameters`，每个参数都有滑块可以拖动
4. **运行中也可以调**：运行游戏时在编辑器中修改参数会实时预览

**推荐初始值**（如果默认效果不满意可以调整）：

| 参数 | 轻微效果 | 中等效果（默认） | 强烈效果 |
|------|---------|-----------------|---------|
| scanline_intensity | 0.08 | 0.15 | 0.3 |
| curvature | 1.0 | 2.5 | 5.0 |
| chromatic_aberration | 0.3 | 0.8 | 2.0 |
| vignette_intensity | 0.2 | 0.4 | 0.8 |
| flicker_intensity | 0.01 | 0.03 | 0.08 |
| noise_intensity | 0.02 | 0.04 | 0.1 |
| glow_intensity | 0.05 | 0.15 | 0.3 |

---

## 3.9 故障排查

**如果屏幕全黑**：
- 检查 `CRTShader` 的 `Color` 是否为白色（不是透明）
- 检查 `CRTEffect` 的 `Layer` 是否为正数

**如果没有任何效果（看起来和之前一样）**：
- 检查 `CRTShader` 的 `Material` 是否正确设置了 ShaderMaterial
- 检查 ShaderMaterial 中的 Shader 是否关联了 crt_effect.gdshader
- 在Shader编辑器底部看是否有红色编译错误

**如果Shader编译报错**：
- 把错误信息告诉我，我帮你修

---

运行测试后告诉我结果（截图最好），不管成功还是有问题我都帮你处理。确认没问题后我们继续**步骤4：打字机效果**。

### USER
crt shader代码报错
第 63 行存在错误： “return”在“fragment”处理器函数中的使用不正确。

### ASSISTANT
这个错误是因为在 `fragment` 函数中，`return` 前面的分支返回了 `vec4`，但函数本身没有返回值类型（void函数不能用 `return` 提前退出后面有赋值的情况）。我们需要改写逻辑，用 `else` 包裹剩余代码。

## 修复方法

找到Shader代码中的这一段（大约第55-65行）：

```glsl
    // 超出屏幕范围的部分显示为黑色（弯曲后的边角）
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        COLOR = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }

    // --- 2. 色差（RGB通道微小偏移）---
```

把从 `if` 开始到整个 `fragment` 函数结尾，**全部替换**为：

```glsl
    // 超出屏幕范围的部分显示为黑色（弯曲后的边角）
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        COLOR = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
        // --- 2. 色差（RGB通道微小偏移）---
        float aberration = chromatic_aberration * 0.001;
        float r = texture(SCREEN_TEXTURE, vec2(uv.x + aberration, uv.y)).r;
        float g = texture(SCREEN_TEXTURE, uv).g;
        float b = texture(SCREEN_TEXTURE, vec2(uv.x - aberration, uv.y)).b;
        vec3 col = vec3(r, g, b);

        // --- 3. 扫描线 ---
        float scanline_y = uv.y * scanline_frequency + TIME * scanline_speed;
        float scanline = sin(scanline_y * 3.14159) * 0.5 + 0.5;
        scanline = pow(scanline, 1.5);
        col *= 1.0 - scanline_intensity * (1.0 - scanline);

        // --- 4. 移动扫描线（模拟CRT刷新）---
        float rolling_line = sin(uv.y * 3.0 + TIME * 0.5) * 0.5 + 0.5;
        rolling_line = pow(rolling_line, 20.0);
        col += col * rolling_line * 0.02;

        // --- 5. 噪点 ---
        float noise = random(uv * TIME) * noise_intensity;
        col += noise;

        // --- 6. 闪烁 ---
        float flicker = 1.0 + sin(TIME * flicker_speed) * flicker_intensity;
        col *= flicker;

        // --- 7. 暗角 ---
        vec2 vig_uv = uv * (1.0 - uv);
        float vig = vig_uv.x * vig_uv.y * 15.0;
        vig = pow(vig, vignette_intensity);
        vig = mix(vignette_size, 1.0, vig);
        col *= vig;

        // --- 8. 磷光/辉光 ---
        vec3 glow = texture(SCREEN_TEXTURE, uv).rgb;
        float glow_amount = dot(glow, vec3(0.299, 0.587, 0.114));
        col += col * glow_amount * glow_intensity;

        // --- 9. 亮度和对比度 ---
        col = (col - 0.5) * contrast + 0.5;
        col *= brightness;

        // --- 10. 钳制颜色范围 ---
        col = clamp(col, 0.0, 1.0);

        COLOR = vec4(col, 1.0);
    }
}
```

**注意**：替换时要确保最后的 `}` 正确闭合。替换后整个 `fragment` 函数结构变成了：

```
void fragment() {
    // 1. 弯曲
    vec2 uv = curve_uv(SCREEN_UV);
    
    if (超出范围) {
        COLOR = 黑色;
    } else {
        // 2~10 所有效果
        COLOR = 最终颜色;
    }
}
```

保存后检查Shader编辑器底部是否还有红色报错，没有的话 `F5` 运行测试。

### USER
第 67 行存在错误： SCREEN_TEXTURE 已被移除，请改用 hint_screen_texture 和 uniform。
为了保持最小的代码改动，你可以在着色器顶部附近添加“uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;”。

### ASSISTANT
这个很简单，只需要在Shader代码最顶部加一行声明。

## 修复方法

找到Shader代码的第一行：

```glsl
shader_type canvas_item;
```

在它**下面**加上这一行：

```glsl
uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;
```

加完后顶部看起来像这样：

```glsl
shader_type canvas_item;
uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;

// ============================================================
// CRT 效果参数 - 可在检查器中实时调节
// ============================================================
```

保存后检查底部是否还有报错，没有的话 `F5` 运行测试。

### USER
目前有效果了，但看起来比较暗，没有https://github.com/Swordfish90/cool-retro-term中那种背景荧光和文字发光的效果，请你调整一下。下面是目前的shader代码，请把需要修改的地方反馈回我，不要全部代码一起发，会导致对话卡死。
shader_type canvas_item;
// Godot 4.x 需要显式声明屏幕纹理
uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap;
// ============================================================
// CRT 效果参数 - 可在检查器中实时调节
// ============================================================
// --- 扫描线 ---
uniform float scanline_intensity : hint_range(0.0, 1.0) = 0.15;
uniform float scanline_frequency : hint_range(100.0, 800.0) = 300.0;
uniform float scanline_speed : hint_range(0.0, 5.0) = 1.0;
// --- 屏幕弯曲 ---
uniform float curvature : hint_range(0.0, 10.0) = 2.5;
// --- 色差/色散 ---
uniform float chromatic_aberration : hint_range(0.0, 5.0) = 0.8;
// --- 暗角 ---
uniform float vignette_intensity : hint_range(0.0, 2.0) = 0.4;
uniform float vignette_size : hint_range(0.0, 1.0) = 0.6;
// --- 闪烁 ---
uniform float flicker_intensity : hint_range(0.0, 0.2) = 0.03;
uniform float flicker_speed : hint_range(0.0, 20.0) = 8.0;
// --- 噪点 ---
uniform float noise_intensity : hint_range(0.0, 0.5) = 0.04;
// --- 磷光/辉光 ---
uniform float glow_intensity : hint_range(0.0, 1.0) = 0.15;
// --- 亮度 ---
uniform float brightness : hint_range(0.5, 2.0) = 1.1;
uniform float contrast : hint_range(0.5, 2.0) = 1.1;
// ============================================================
// 工具函数
// ============================================================
// 伪随机数生成
float random(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}
// 屏幕弯曲变形 UV
vec2 curve_uv(vec2 uv) {
    vec2 centered = uv * 2.0 - 1.0;
    float dist = dot(centered, centered);
    centered _= 1.0 + dist_ curvature * 0.02;
    return centered * 0.5 + 0.5;
}
// ============================================================
// 主片段着色器
// ============================================================
void fragment() {
    // --- 1. 屏幕弯曲 ---
    vec2 uv = curve_uv(SCREEN_UV);
    // 超出屏幕范围的部分显示为黑色（弯曲后的边角）
        // 超出屏幕范围的部分显示为黑色（弯曲后的边角）
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        COLOR = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
        // --- 2. 色差（RGB通道微小偏移）---
        float aberration = chromatic_aberration * 0.001;
        float r = texture(SCREEN_TEXTURE, vec2(uv.x + aberration, uv.y)).r;
        float g = texture(SCREEN_TEXTURE, uv).g;
        float b = texture(SCREEN_TEXTURE, vec2(uv.x - aberration, uv.y)).b;
        vec3 col = vec3(r, g, b);
        // --- 3. 扫描线 ---
        float scanline_y = uv.y _scanline_frequency + TIME_ scanline_speed;
        float scanline = sin(scanline_y _3.14159)_ 0.5 + 0.5;
        scanline = pow(scanline, 1.5);
        col _= 1.0 - scanline_intensity_ (1.0 - scanline);
        // --- 4. 移动扫描线（模拟CRT刷新）---
        float rolling_line = sin(uv.y _3.0 + TIME_ 0.5) * 0.5 + 0.5;
        rolling_line = pow(rolling_line, 20.0);
        col += col _rolling_line_ 0.02;
        // --- 5. 噪点 ---
        float noise = random(uv _TIME)_ noise_intensity;
        col += noise;
        // --- 6. 闪烁 ---
        float flicker = 1.0 + sin(TIME _flicker_speed)_ flicker_intensity;
        col *= flicker;
        // --- 7. 暗角 ---
        vec2 vig_uv = uv * (1.0 - uv);
        float vig = vig_uv.x _vig_uv.y_ 15.0;
        vig = pow(vig, vignette_intensity);
        vig = mix(vignette_size, 1.0, vig);
        col *= vig;
        // --- 8. 磷光/辉光 ---
        vec3 glow = texture(SCREEN_TEXTURE, uv).rgb;
        float glow_amount = dot(glow, vec3(0.299, 0.587, 0.114));
        col += col _glow_amount_ glow_intensity;
        // --- 9. 亮度和对比度 ---
        col = (col - 0.5) * contrast + 0.5;
        col *= brightness;
        // --- 10. 钳制颜色范围 ---
        col = clamp(col, 0.0, 1.0);
        COLOR = vec4(col, 1.0);
    }
}

### ASSISTANT
我看到你的代码中有一些格式问题（`*` 被吞掉变成了 `_`），我先帮你确认这个，然后再加上发光效果。

## 修改1：修改参数默认值（让画面更亮更有荧光感）

找到参数定义区域，修改以下几个参数的默认值：

找到：
```glsl
uniform float scanline_intensity : hint_range(0.0, 1.0) = 0.15;
```
改为：
```glsl
uniform float scanline_intensity : hint_range(0.0, 1.0) = 0.08;
```

找到：
```glsl
uniform float vignette_intensity : hint_range(0.0, 2.0) = 0.4;
uniform float vignette_size : hint_range(0.0, 1.0) = 0.6;
```
改为：
```glsl
uniform float vignette_intensity : hint_range(0.0, 2.0) = 0.25;
uniform float vignette_size : hint_range(0.0, 1.0) = 0.75;
```

找到：
```glsl
uniform float glow_intensity : hint_range(0.0, 1.0) = 0.15;
```
改为：
```glsl
uniform float glow_intensity : hint_range(0.0, 2.0) = 0.6;
```

找到：
```glsl
uniform float brightness : hint_range(0.5, 2.0) = 1.1;
uniform float contrast : hint_range(0.5, 2.0) = 1.1;
```
改为：
```glsl
uniform float brightness : hint_range(0.5, 3.0) = 1.4;
uniform float contrast : hint_range(0.5, 2.0) = 1.15;
```

## 修改2：添加新的发光参数

在 `uniform float glow_intensity` 那一行**下面**，添加以下新参数：

```glsl
uniform float bloom_spread : hint_range(0.0, 10.0) = 3.0;
uniform float bloom_intensity : hint_range(0.0, 2.0) = 0.5;
uniform vec3 phosphor_color : source_color = vec3(0.1, 1.0, 0.3);
uniform float phosphor_boost : hint_range(0.0, 2.0) = 0.35;
```

## 修改3：替换 else 块中第8步和第9步

找到从 `// --- 8. 磷光/辉光 ---` 开始到 `// --- 10.` 之前的部分：

```glsl
        // --- 8. 磷光/辉光 ---
        vec3 glow = texture(SCREEN_TEXTURE, uv).rgb;
        float glow_amount = dot(glow, vec3(0.299, 0.587, 0.114));
        col += col * glow_amount * glow_intensity;

        // --- 9. 亮度和对比度 ---
        col = (col - 0.5) * contrast + 0.5;
        col *= brightness;
```

替换为：

```glsl
        // --- 8. 模拟Bloom（多次采样模糊发光）---
        vec3 bloom = vec3(0.0);
        float pixel_size_x = bloom_spread / float(textureSize(SCREEN_TEXTURE, 0).x);
        float pixel_size_y = bloom_spread / float(textureSize(SCREEN_TEXTURE, 0).y);
        for (int x = -2; x <= 2; x++) {
            for (int y = -2; y <= 2; y++) {
                vec2 offset = vec2(float(x) * pixel_size_x, float(y) * pixel_size_y);
                bloom += texture(SCREEN_TEXTURE, uv + offset).rgb;
            }
        }
        bloom /= 25.0;
        col += bloom * bloom_intensity;

        // --- 9. 磷光色调叠加 ---
        float luma = dot(col, vec3(0.299, 0.587, 0.114));
        col += phosphor_color * luma * phosphor_boost;
        col += col * luma * glow_intensity;

        // --- 10. 亮度和对比度 ---
        col = (col - 0.5) * contrast + 0.5;
        col *= brightness;
```

## 修改4：修改最后的钳制步骤编号

找到：
```glsl
        // --- 10. 钳制颜色范围 ---
```
改为：
```glsl
        // --- 11. 钳制颜色范围 ---
```

---

## 总结改了什么

| 修改 | 效果 |
|------|------|
| 降低 scanline_intensity | 扫描线不那么暗 |
| 降低 vignette | 四角不那么暗 |
| 提高 brightness/contrast | 整体更亮 |
| 新增 bloom | 文字周围有发光模糊效果 |
| 新增 phosphor_color/boost | 绿色磷光色调，模拟CRT荧光屏 |
| 提高 glow_intensity | 亮色文字发光更明显 |

保存后 `F5` 运行。如果觉得绿色磷光太强或太弱，可以在检查器中调节 `phosphor_boost`（0就是关闭，0.35是默认，0.7是很强的绿色荧光感）。

### USER
目前效果很好，请进行下一步

### ASSISTANT
很好！继续步骤4：打字机效果。

---

# 阶段一 · 步骤4：打字机效果

让文字像真正的终端一样逐字显示出来，而不是一瞬间全部出现。

## 4.1 修改 `main.gd` —— 添加打字机相关变量

找到状态变量区域中的：

```gdscript
var _needs_scroll: bool = false
```

在它**下面**添加：

```gdscript
# 打字机效果
var _typewriter_queue: Array[String] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.01        # 每个字符的间隔（秒），越小越快
var _typewriter_instant: bool = false       # 是否跳过动画立即显示
```

## 4.2 替换 `append_output` 函数和 `_do_scroll` 函数

找到原来的 `append_output` 和 `_do_scroll`，**全部删除**，替换为以下代码：

```gdscript
func append_output(text: String) -> void:
	# 将文本加入队列
	_typewriter_queue.append(text)
	# 如果没有正在打字，启动打字流程
	if not _is_typing:
		_process_typewriter_queue()


func _process_typewriter_queue() -> void:
	if _typewriter_queue.is_empty():
		_is_typing = false
		return
	
	_is_typing = true
	var text: String = _typewriter_queue.pop_front()
	
	# 如果已有内容，先换行
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	
	if _typewriter_instant:
		# 跳过动画，直接显示
		output_text.append_text(text)
		output_text.append_text("\n")
		_do_scroll()
		# 继续处理队列中的下一条
		_process_typewriter_queue()
	else:
		# 逐字显示
		_typewrite_text(text)


func _typewrite_text(text: String) -> void:
	# 解析BBCode：我们需要逐字显示纯文本部分，但BBCode标签要整体添加
	var i: int = 0
	var length: int = text.length()
	
	while i < length:
		# 检查是否是BBCode标签的开始
		if text[i] == "[":
			# 找到标签结束的 ]
			var close_bracket: int = text.find("]", i)
			if close_bracket != -1:
				# 整个标签一次性添加（不逐字）
				var tag: String = text.substr(i, close_bracket - i + 1)
				output_text.append_text(tag)
				i = close_bracket + 1
				continue
		
		# 普通字符，逐字添加
		output_text.append_text(text[i])
		i += 1
		
		# 等待一小段时间
		if not _typewriter_instant:
			await get_tree().create_timer(_typewriter_speed).timeout
			# 每输出几个字符滚动一次
			if i % 10 == 0:
				_do_scroll()
	
	# 当前文本打完，加换行
	output_text.append_text("\n")
	_do_scroll()
	
	# 继续处理队列
	_process_typewriter_queue()


func _do_scroll() -> void:
	var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
	scroll_container.scroll_vertical = int(v_scroll.max_value)
```

## 4.3 修改 `_on_command_submitted` —— 输入命令时跳过打字动画

用户输入命令后的回显（`> help` 这种）应该立即显示，而命令的输出结果用打字机效果。

找到 `_on_command_submitted`，替换为：

```gdscript
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	
	input_field.clear()
	
	if raw_input.is_empty():
		return
	
	command_history.append(raw_input)
	history_index = -1
	
	# 命令回显用即时显示（不走打字机）
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text("> " + raw_input)
	output_text.append_text("\n")
	
	# 执行命令（命令输出走打字机效果）
	_execute_command(raw_input)
```

## 4.4 修改 `_input` 函数 —— 按任意键跳过打字动画

找到 `_input` 函数中 `match event.keycode:` 这一行的**上面**，在 match 之前插入一段跳过逻辑：

找到：

```gdscript
	match event.keycode:
		KEY_ENTER, KEY_KP_ENTER:
```

在它**前面**加上：

```gdscript
	# 如果正在打字，按空格或回车跳过动画
	if _is_typing and event.keycode in [KEY_SPACE, KEY_ENTER, KEY_KP_ENTER, KEY_ESCAPE]:
		_typewriter_instant = true
		get_viewport().set_input_as_handled()
		return
	
```

## 4.5 修改 `_execute_command` —— 每次执行命令前重置打字机状态

找到 `_execute_command` 函数的开头：

```gdscript
func _execute_command(raw_input: String) -> void:
	var parts := raw_input.split(" ", false)
```

在 `var parts` 这行**前面**加上：

```gdscript
	# 重置打字机为动画模式
	_typewriter_instant = false
```

## 4.6 修改 `_cmd_clear` —— 清屏时也清空打字队列

找到：

```gdscript
func _cmd_clear() -> void:
	output_text.text = ""
```

替换为：

```gdscript
func _cmd_clear() -> void:
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false
```

## 4.7 欢迎信息用即时显示

找到 `_show_welcome_message` 函数，在它的 `output_text.append_text(welcome)` **前面**加一行：

找到：
```gdscript
	output_text.append_text(welcome)
```

不需要改，因为欢迎信息已经是直接用 `append_text` 而不是走 `append_output`，所以不受打字机影响，保持原样即可。

---

## 总结改了什么

| 修改 | 说明 |
|------|------|
| 新增4个打字机变量 | 队列、状态、速度、跳过标记 |
| 重写 `append_output` | 文本进入队列，逐字显示 |
| 新增 `_process_typewriter_queue` | 队列处理器 |
| 新增 `_typewrite_text` | 逐字输出核心逻辑，智能跳过BBCode标签 |
| 重写 `_do_scroll` | 简化为直接滚动 |
| 修改 `_on_command_submitted` | 命令回显即时显示 |
| 修改 `_input` | 按空格/回车/ESC跳过打字动画 |
| 修改 `_execute_command` | 每次命令重置打字机状态 |
| 修改 `_cmd_clear` | 清屏时清空打字队列 |

保存 `Ctrl+S`，`F5` 运行测试：

1. 输入 `help` → 文字应该**逐字打出来**
2. 打字过程中按**空格**或**回车** → 应该**立刻显示完**
3. 输入 `ls` → 逐字打出文件列表
4. 输入 `clear` → 清屏

如果打字速度太快或太慢，修改 `_typewriter_speed` 的值：
- `0.005` = 很快
- `0.01` = 默认
- `0.03` = 较慢，更有终端感

测试后告诉我结果！

### USER
目前效果很好，但需要优化一下：
1.打字时有一顿一顿的顿挫感更好，你想办法实现一下。
2.在后续文档中，有没有可能实现局部控制打字速度。
3.在打开文件时，加入一个进度条，进度条长度一定，但速度根据文件大小变化，而且可以自定义进度条速度。

### ASSISTANT
很好的想法！让我逐一实现。

## 修改1：添加新的打字机变量

找到打字机变量区域：

```gdscript
var _typewriter_speed: float = 0.01
var _typewriter_instant: bool = false
```

替换为：

```gdscript
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
```

## 修改2：替换 `_typewrite_text` 函数

找到整个 `_typewrite_text` 函数，**删除**，替换为：

```gdscript
func _typewrite_text(text: String) -> void:
	var i: int = 0
	var length: int = text.length()
	_current_char_speed = _typewriter_speed
	
	while i < length:
		# 如果中途切换为即时模式，把剩余文本一次性输出
		if _typewriter_instant:
			output_text.append_text(text.substr(i))
			break
		
		# 检查是否是BBCode标签
		if text[i] == "[":
			var close_bracket: int = text.find("]", i)
			if close_bracket != -1:
				var tag: String = text.substr(i, close_bracket - i + 1)
				
				# 检查是否是自定义速度标签 [speed=0.05]
				if tag.begins_with("[speed="):
					var speed_str: String = tag.substr(7, tag.length() - 8)
					_current_char_speed = speed_str.to_float()
					i = close_bracket + 1
					continue
				elif tag == "[/speed]":
					_current_char_speed = _typewriter_speed
					i = close_bracket + 1
					continue
				elif tag.begins_with("[pause="):
					# 自定义暂停标签 [pause=0.5]
					var pause_str: String = tag.substr(7, tag.length() - 8)
					var pause_time: float = pause_str.to_float()
					await get_tree().create_timer(pause_time).timeout
					i = close_bracket + 1
					continue
				
				# 普通BBCode标签，整体添加
				output_text.append_text(tag)
				i = close_bracket + 1
				continue
		
		# 普通字符
		var ch: String = text[i]
		output_text.append_text(ch)
		i += 1
		
		# 根据字符类型决定延迟
		var delay: float = _current_char_speed
		
		# 标点符号额外停顿（制造顿挫感）
		if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
			delay += _typewriter_period_pause
		elif ch in ["、", "—", "-", "…"]:
			delay += _typewriter_comma_pause
		elif ch == "\n":
			delay += _typewriter_period_pause
		else:
			# 随机顿挫：有一定概率额外停顿
			if randf() < _typewriter_pause_chance:
				delay += _typewriter_pause_duration
		
		await get_tree().create_timer(delay).timeout
		
		# 每隔几个字符滚动一次
		if i % 8 == 0:
			_do_scroll()
	
	# 当前文本打完
	output_text.append_text("\n")
	_do_scroll()
	
	# 继续处理队列
	_process_typewriter_queue()
```

## 修改3：添加进度条函数

在 `_do_scroll` 函数的**下面**，添加一个新函数：

```gdscript
# 显示文件加载进度条
# file_size: 文件内容长度，影响进度条速度
# speed_override: 速度倍率覆盖，-1表示用默认
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
	var bar_width: int = 30  # 进度条总长度（字符数）
	var speed: float = _progress_bar_speed
	if speed_override > 0.0:
		speed = speed_override
	
	# 文件越大，每格停顿越长（但有上下限）
	var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
	base_delay /= speed
	
	# 起始行
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text("[color=#66FF66]加载中 [[/color]")
	
	for i in range(bar_width):
		if _typewriter_instant:
			# 跳过动画，直接填满
			var remaining: int = bar_width - i
			output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
			break
		
		output_text.append_text("[color=#33FF33]█[/color]")
		_do_scroll()
		
		# 随机波动让进度条不匀速，更真实
		var jitter: float = randf_range(0.7, 1.5)
		await get_tree().create_timer(base_delay * jitter).timeout
	
	output_text.append_text("[color=#66FF66]] 完成[/color]\n")
	_do_scroll()
```

## 修改4：修改 `_cmd_open` 函数，加入进度条

找到 `_cmd_open` 函数中的最后部分，原来是：

```gdscript
	var lines: Array[String] = []
	lines.append("[color=#66FF66]══════════ " + filename + " ══════════[/color]")
	lines.append("")
	lines.append(node.content)
	lines.append("")
	lines.append("[color=#66FF66]══════════ 文件结束 ══════════[/color]")
	append_output("\n".join(lines))
```

替换为：

```gdscript
	# 先显示进度条（根据文件大小调节速度）
	var content_size: int = node.content.length()
	await _show_progress_bar(content_size)
	
	# 进度条完成后显示文件内容
	var lines: Array[String] = []
	lines.append("[color=#66FF66]══════════ " + filename + " ══════════[/color]")
	lines.append("")
	lines.append(node.content)
	lines.append("")
	lines.append("[color=#66FF66]══════════ 文件结束 ══════════[/color]")
	append_output("\n".join(lines))
```

## 修改5：修改 `_input` 中跳过逻辑，也能跳过进度条

找到 `_input` 函数中的：

```gdscript
	# 如果正在打字，按空格或回车跳过动画
	if _is_typing and event.keycode in [KEY_SPACE, KEY_ENTER, KEY_KP_ENTER, KEY_ESCAPE]:
		_typewriter_instant = true
		get_viewport().set_input_as_handled()
		return
```

替换为：

```gdscript
	# 如果正在打字或加载，按空格或ESC跳过动画
	if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
		_typewriter_instant = true
		get_viewport().set_input_as_handled()
		return
```

（把回车键从跳过列表中移除，避免跳过后误触发命令提交）

---

## 自定义速度标签用法（为后续文档准备）

在文件内容中可以使用这些自定义标签：

```
这是正常速度的文字。
[speed=0.05]这段文字会非常缓慢地出现...[/speed]
[speed=0.002]这段文字会很快闪过。[/speed]
[pause=1.0]（这里会暂停1秒钟再继续）
正常速度恢复。
```

| 标签 | 用法 | 示例 |
|------|------|------|
| `[speed=数值]` | 设置打字速度（秒/字符） | `[speed=0.05]慢速文字[/speed]` |
| `[/speed]` | 恢复默认速度 | |
| `[pause=数值]` | 暂停指定秒数 | `[pause=2.0]` 暂停2秒 |

---

## 总结

| 新功能 | 说明 |
|------|------|
| 随机顿挫 | 8%概率随机停顿，有打字机的机械感 |
| 标点停顿 | 逗号、句号后自动多停一下 |
| `[speed=]` 标签 | 局部控制打字速度 |
| `[pause=]` 标签 | 在任意位置插入暂停 |
| 文件进度条 | 打开文件时显示加载动画，速度随文件大小变化 |
| 进度条随机波动 | 速度不匀，更真实 |

保存 `Ctrl+S`，`F5` 运行测试：

1. `help` → 文字逐字打出，标点处有明显停顿
2. `open welcome.txt` → 先显示进度条，再显示内容
3. 打字过程中按**空格**或**ESC** → 立刻显示完
4. `open scp_173.txt`（较长文件） → 进度条速度会稍慢

### USER
目前很好，但我在输入命令的时候发现只有命令可以补全，能否实现文件名也能自动补全的功能？下面是目前所有的main.gd代码，请添加这个功能，并检查一下有没有埋坑的地方或者可以优化的地方。请把需要修改的地方反馈给我，不要把代码全部发过来，会导致对话中断。

### ASSISTANT
我仔细看了你的代码，有几个需要修改和优化的地方。

## 修改1：修复文件名自动补全

你的 `_auto_complete` 函数中其实已经有文件名补全的逻辑（`elif parts.size() == 2` 那部分），但问题是 `Tab` 键被 `LineEdit` 本身拦截用于切换焦点了，导致补全在某些情况下不生效。另外需要让补全支持不输入命令直接补全文件名。

找到整个 `_auto_complete` 函数，**替换为**：

```gdscript
func _auto_complete() -> void:
	var current_text: String = input_field.text
	if current_text.strip_edges().is_empty():
		return
	
	var parts := current_text.split(" ", false)
	
	# 只输入了一个词：补全命令
	if parts.size() == 1:
		# 检查是否已经是完整命令，后面有空格表示要补全参数
		if current_text.ends_with(" "):
			# 命令已输入完，补全文件名（无前缀匹配，列出所有）
			var cmd: String = parts[0].to_lower()
			if cmd in ["cd", "open", "cat"]:
				var children := _get_children_at_path(current_path)
				if children.size() > 0:
					var display: Array[String] = []
					for child in children:
						var child_path := _join_path(current_path, child)
						var node := _get_node_at_path(child_path)
						if node == null:
							continue
						# cd只补全文件夹，open/cat只补全文件
						if cmd == "cd" and node.type == "folder":
							display.append(child + "/")
						elif cmd in ["open", "cat"] and node.type == "file":
							display.append(child)
						elif cmd not in ["cd"]:
							display.append(child)
					if display.size() > 0:
						append_output("[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
		else:
			# 补全命令名
			var partial_cmd: String = parts[0].to_lower()
			var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
							"clear", "cls", "status", "mail", "whoami", "exit", "quit"]
			var matches: Array[String] = []
			for cmd in commands:
				if cmd.begins_with(partial_cmd):
					matches.append(cmd)
			
			if matches.size() == 1:
				input_field.text = matches[0] + " "
				input_field.caret_column = input_field.text.length()
			elif matches.size() > 1:
				append_output("[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
	
	# 两个词：命令 + 部分文件名
	elif parts.size() == 2:
		var cmd: String = parts[0].to_lower()
		var partial_name: String = parts[1]
		
		if cmd in ["cd", "open", "cat"]:
			var children := _get_children_at_path(current_path)
			var matches: Array[String] = []
			for child in children:
				if child.to_lower().begins_with(partial_name.to_lower()):
					var child_path := _join_path(current_path, child)
					var node := _get_node_at_path(child_path)
					if node == null:
						continue
					# cd只匹配文件夹，open/cat只匹配文件
					if cmd == "cd" and node.type == "folder":
						matches.append(child)
					elif cmd in ["open", "cat"] and node.type == "file":
						matches.append(child)
			
			if matches.size() == 1:
				input_field.text = cmd + " " + matches[0]
				input_field.caret_column = input_field.text.length()
			elif matches.size() > 1:
				# 找公共前缀，补全到最长公共部分
				var common: String = _find_common_prefix(matches)
				if common.length() > partial_name.length():
					input_field.text = cmd + " " + common
					input_field.caret_column = input_field.text.length()
				append_output("[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
```

## 修改2：添加公共前缀查找函数

在 `_auto_complete` 函数的**下面**，添加：

```gdscript
# 查找多个字符串的最长公共前缀
func _find_common_prefix(strings: Array[String]) -> String:
	if strings.is_empty():
		return ""
	if strings.size() == 1:
		return strings[0]
	
	var prefix: String = strings[0]
	for i in range(1, strings.size()):
		while not strings[i].to_lower().begins_with(prefix.to_lower()):
			prefix = prefix.substr(0, prefix.length() - 1)
			if prefix.is_empty():
				return ""
	return prefix
```

## 修改3：确保 Tab 键不被 LineEdit 吞掉

找到 `_ready` 函数中的：

```gdscript
	input_field.focus_mode = Control.FOCUS_ALL
	input_field.grab_focus()
```

在这两行**之间**插入一行：

```gdscript
	input_field.focus_mode = Control.FOCUS_ALL
	# 阻止Tab键切换焦点，让我们自己处理
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
	input_field.grab_focus()
```

## 修改4：优化 —— `_cmd_open` 的 await 可能导致问题

你的 `_cmd_open` 中有 `await _show_progress_bar()`，但 `_execute_command` 调用它后不会等待。这会导致进度条还没结束文件内容就开始打字了。

找到 `_execute_command` 中的：

```gdscript
		"open", "cat":
			_cmd_open(args)
```

替换为：

```gdscript
		"open", "cat":
			await _cmd_open(args)
```

同样，`exit` 命令也有 `await`：

找到：
```gdscript
		"exit", "quit":
			_cmd_exit()
```

替换为：
```gdscript
		"exit", "quit":
			await _cmd_exit()
```

然后把 `_execute_command` 的函数签名也改一下，找到：

```gdscript
func _execute_command(raw_input: String) -> void:
```

不需要改签名，GDScript的 `void` 函数中可以使用 `await`，但为了安全，确认 `_on_command_submitted` 中调用 `_execute_command` 的地方也加上 `await`：

找到 `_on_command_submitted` 中的：

```gdscript
	_execute_command(raw_input)
```

替换为：

```gdscript
	await _execute_command(raw_input)
```

## 修改5：优化 —— 防止打字过程中输入命令干扰

找到 `_input` 函数中处理回车的部分：

```gdscript
		KEY_ENTER, KEY_KP_ENTER:
			var command_text: String = input_field.text
			input_field.clear()
			_on_command_submitted(command_text)
			get_viewport().set_input_as_handled()
```

替换为：

```gdscript
		KEY_ENTER, KEY_KP_ENTER:
			# 如果正在打字，忽略回车（防止干扰）
			if _is_typing:
				get_viewport().set_input_as_handled()
			else:
				var command_text: String = input_field.text
				input_field.clear()
				_on_command_submitted(command_text)
				get_viewport().set_input_as_handled()
```

---

## 总结

| 修改 | 说明 |
|------|------|
| 重写 `_auto_complete` | cd只补全文件夹，open只补全文件，支持公共前缀补全 |
| 新增 `_find_common_prefix` | 多个匹配时补全到最长公共部分 |
| Tab键修复 | 阻止焦点切换 |
| `await` 修复 | 进度条和打字机的执行顺序正确 |
| 打字中禁止回车 | 防止打字过程中误提交命令 |

保存 `Ctrl+S`，`F5` 测试：

1. 输入 `cd ` 按 Tab → 应列出所有文件夹
2. 输入 `open n` 按 Tab → 应补全为 `open notice.txt`
3. 输入 `cd r` 按 Tab → 应补全为 `cd reports`
4. 输入 `open scp` 按 Tab → 如果在 reports 目录下应补全公共前缀 `scp_`

### USER
我找不到修改3部分中的input_field.focus_mode = Control.FOCUS_ALL，但是有input_field.grab_focus()

### ASSISTANT
没关系，那说明之前那行没加上。直接在 `_ready` 函数中找到：

```gdscript
	input_field.grab_focus()
```

在它**前面**加上这三行：

```gdscript
	input_field.focus_mode = Control.FOCUS_ALL
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
```

加完后这一段看起来像这样：

```gdscript
	input_field.focus_mode = Control.FOCUS_ALL
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
	input_field.grab_focus()
```

保存后继续其他修改。

### USER
已完成，表现良好，非常感谢。我们进行下一步吧

### ASSISTANT
很好！让我们看看阶段一还剩什么。

---

## 当前完成情况

| 项目 | 状态 |
|------|------|
| ✅ Godot项目基础搭建、场景树结构 | 已完成 |
| ✅ 命令行输入框与基础命令解析 | 已完成 |
| ✅ 状态栏 | 已完成 |
| ✅ 基础CRT Shader效果 | 已完成 |
| ✅ 打字机效果 | 已完成（含顿挫感、局部速度控制、进度条） |
| ⬜ ZIP文件读取与虚拟文件系统 | **下一步** |
| ⬜ 基础TXT文件显示完善 | 与ZIP一起完成 |

---

# 阶段一 · 步骤5：ZIP文件读取与虚拟文件系统

目标：从 `.scp` 文件（实际是ZIP）中读取文件结构和内容，替换掉目前的硬编码测试数据。

## 5.1 创建测试用的SCP剧本包

先在电脑上准备一个测试ZIP文件。

1. 在你的电脑上创建一个文件夹，命名为 `test_story`
2. 在里面创建以下文件结构：

```
test_story/
├── manifest.cfg
├── welcome.txt
├── notice.txt
├── reports/
│   ├── scp_173.txt
│   └── incident_log.txt
├── personnel/
│   └── agent_a.txt
└── comms/
    └── radio_log.txt
```

3. **manifest.cfg** 内容（用记事本创建，保存为UTF-8编码）：

```
[story]
title=SCP-Site19 事故调查
author=测试作者
version=1.0
description=一个关于Site-19的测试剧本

[settings]
start_path=/
typing_speed=0.008
```

4. **welcome.txt** 内容：

```
欢迎接入SCP基金会安全终端系统。

本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。

请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。

- 基金会信息安全部门
```

5. 其他txt文件可以沿用你代码中已有的测试内容，或随便写几行。

6. **打包成ZIP**：选中 `test_story` 文件夹里的所有文件（不是文件夹本身），右键压缩为ZIP，然后把后缀名从 `.zip` 改为 `.scp`

7. 把这个 `.scp` 文件放到项目的 `res://stories/` 文件夹中（需要新建这个文件夹）

## 5.2 创建ZIP读取脚本

1. 在 `res://scripts/` 下新建脚本文件 `story_loader.gd`
2. 写入以下内容：

```gdscript
class_name StoryLoader
extends RefCounted

# 加载结果
var file_system: Dictionary = {}
var manifest: Dictionary = {}
var error_message: String = ""

# 从 .scp (ZIP) 文件加载剧本
func load_story(path: String) -> bool:
	file_system.clear()
	manifest.clear()
	error_message = ""
	
	# 打开ZIP文件
	var reader := ZIPReader.new()
	var err := reader.open(path)
	if err != OK:
		error_message = "无法打开文件: " + path
		return false
	
	# 获取ZIP内所有文件路径
	var files := reader.get_files()
	
	# 第一遍：收集所有文件夹路径
	var folders: Dictionary = {}
	folders["/"] = true
	
	for file_path in files:
		# 跳过空路径
		if file_path.strip_edges().is_empty():
			continue
		
		# 标准化路径：确保以 / 开头
		var clean_path: String = _clean_zip_path(file_path)
		
		# 收集所有父级文件夹
		var parts := clean_path.split("/", false)
		var current := ""
		for i in range(parts.size() - 1):
			current += "/" + parts[i]
			folders[current] = true
		
		# 如果路径本身以 / 结尾，它是文件夹
		if file_path.ends_with("/"):
			folders[clean_path.rstrip("/")] = true
	
	# 注册所有文件夹
	for folder_path in folders.keys():
		if folder_path == "/":
			continue
		file_system[folder_path] = {
			"type": "folder"
		}
	
	# 第二遍：读取所有文件内容
	for file_path in files:
		if file_path.strip_edges().is_empty():
			continue
		if file_path.ends_with("/"):
			continue
		
		var clean_path: String = _clean_zip_path(file_path)
		
		# 读取文件内容
		var content_bytes := reader.read_file(file_path)
		if content_bytes == null:
			continue
		
		var content: String = content_bytes.get_string_from_utf8()
		
		# 检查是否是 manifest.cfg
		var filename: String = clean_path.get_file()
		if filename == "manifest.cfg":
			_parse_manifest(content)
			continue
		
		# 注册为文件
		file_system[clean_path] = {
			"type": "file",
			"content": content
		}
	
	reader.close()
	return true


# 清理ZIP内部路径，统一为 /开头 的格式
func _clean_zip_path(zip_path: String) -> String:
	# 去除开头的 ./
	var path: String = zip_path
	if path.begins_with("./"):
		path = path.substr(2)
	
	# 去除末尾的 /
	path = path.rstrip("/")
	
	# 确保以 / 开头
	if not path.begins_with("/"):
		path = "/" + path
	
	return path


# 解析 manifest.cfg
func _parse_manifest(content: String) -> void:
	var current_section: String = ""
	
	for line in content.split("\n"):
		line = line.strip_edges()
		
		# 跳过空行和注释
		if line.is_empty() or line.begins_with("#") or line.begins_with(";"):
			continue
		
		# 段落标记 [section]
		if line.begins_with("[") and line.ends_with("]"):
			current_section = line.substr(1, line.length() - 2)
			if not manifest.has(current_section):
				manifest[current_section] = {}
			continue
		
		# 键值对 key=value
		var eq_pos: int = line.find("=")
		if eq_pos > 0 and not current_section.is_empty():
			var key: String = line.substr(0, eq_pos).strip_edges()
			var value: String = line.substr(eq_pos + 1).strip_edges()
			manifest[current_section][key] = value
```

## 5.3 修改 `main.gd` —— 添加剧本加载功能

### 5.3a 添加变量

找到变量区域中的：

```gdscript
var file_system: Dictionary = {}
```

在它**下面**加上：

```gdscript
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
```

### 5.3b 修改 `_ready` 函数

找到 `_ready` 中的：

```gdscript
	_init_test_file_system()
```

替换为：

```gdscript
	# 尝试加载剧本，如果失败则用测试数据
	if not _try_load_story():
		_init_test_file_system()
```

### 5.3c 添加剧本加载函数

在 `_init_test_file_system` 函数的**前面**，添加：

```gdscript
# 尝试从 stories 目录加载第一个 .scp 文件
func _try_load_story() -> bool:
	var stories_dir := "res://stories/"
	
	# 检查目录是否存在
	if not DirAccess.dir_exists_absolute(stories_dir):
		print("[StoryLoader] stories 目录不存在，使用测试数据")
		return false
	
	# 遍历目录找 .scp 文件
	var dir := DirAccess.open(stories_dir)
	if dir == null:
		print("[StoryLoader] 无法打开 stories 目录")
		return false
	
	dir.list_dir_begin()
	var file_name := dir.get_next()
	while file_name != "":
		if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
			var full_path: String = stories_dir + file_name
			return _load_story_file(full_path)
		file_name = dir.get_next()
	
	print("[StoryLoader] 未找到 .scp 剧本文件，使用测试数据")
	return false


func _load_story_file(path: String) -> bool:
	story_loader = StoryLoader.new()
	
	if not story_loader.load_story(path):
		print("[StoryLoader] 加载失败: " + story_loader.error_message)
		return false
	
	# 应用加载的数据
	file_system = story_loader.file_system
	story_manifest = story_loader.manifest
	current_story_path = path
	
	# 应用 manifest 中的设置
	if story_manifest.has("settings"):
		var settings: Dictionary = story_manifest["settings"]
		if settings.has("start_path"):
			current_path = settings["start_path"]
		if settings.has("typing_speed"):
			_typewriter_speed = settings["typing_speed"].to_float()
	
	var title: String = "未知剧本"
	if story_manifest.has("story") and story_manifest["story"].has("title"):
		title = story_manifest["story"]["title"]
	
	print("[StoryLoader] 成功加载: " + title)
	print("[StoryLoader] 文件数量: " + str(file_system.size()))
	return true
```

### 5.3d 修改欢迎信息，显示剧本名称

找到 `_show_welcome_message` 函数，**替换为**：

```gdscript
func _show_welcome_message() -> void:
	var title: String = "SCP FOUNDATION TERMINAL v0.1"
	var subtitle: String = "SECURE - CONTAIN - PROTECT"
	
	# 如果加载了剧本，显示剧本标题
	if story_manifest.has("story"):
		var story_info: Dictionary = story_manifest["story"]
		if story_info.has("title"):
			subtitle = story_info["title"]
	
	var welcome := "[color=#66FF66]╔══════════════════════════════════════════════╗\n"
	welcome += "║         " + title + "         ║\n"
	welcome += "║       " + subtitle + "             ║\n"
	welcome += "╚══════════════════════════════════════════════╝[/color]\n"
	welcome += "\n"
	welcome += "[color=#AAAAAA]终端系统已启动。\n"
	welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
	
	output_text.append_text(welcome)
```

### 5.3e 添加 story 命令（可选，查看当前剧本信息）

找到 `_execute_command` 中的 match 块，在 `"whoami":` 的**下面**加一个新命令：

```gdscript
		"story", "info":
			_cmd_story_info()
```

然后在 `_cmd_whoami` 函数的**下面**添加：

```gdscript
func _cmd_story_info() -> void:
	if story_manifest.is_empty():
		append_output("[color=#AAAAAA]当前使用内置测试数据，未加载剧本文件。[/color]")
		return
	
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════ 剧本信息 ═══════════[/color]")
	
	if story_manifest.has("story"):
		var info: Dictionary = story_manifest["story"]
		lines.append("  标题:   [color=#66FF66]" + info.get("title", "未知") + "[/color]")
		lines.append("  作者:   [color=#66FF66]" + info.get("author", "未知") + "[/color]")
		lines.append("  版本:   [color=#66FF66]" + info.get("version", "未知") + "[/color]")
		if info.has("description"):
			lines.append("  简介:   [color=#AAAAAA]" + info["description"] + "[/color]")
	
	lines.append("  文件数: [color=#66FF66]" + str(file_system.size()) + "[/color]")
	lines.append("  来源:   [color=#AAAAAA]" + current_story_path + "[/color]")
	lines.append("[color=#66FF66]════════════════════════════════[/color]")
	append_output("\n".join(lines))
```

---

## 测试步骤

**先不创建ZIP文件测试**：直接 `F5` 运行，应该看到控制台输出 `stories 目录不存在，使用测试数据`，然后一切照常工作。

**创建ZIP文件后测试**：
1. 按照5.1的步骤创建文件并打包
2. 放到 `res://stories/` 目录
3. `F5` 运行
4. 输入 `story` 查看剧本信息
5. 输入 `ls` 应该能看到ZIP中的文件结构

---

## 总结

| 新增 | 说明 |
|------|------|
| `story_loader.gd` | 独立的ZIP读取和解析类 |
| `manifest.cfg` 解析 | 读取剧本标题、作者、设置等 |
| 自动加载 | 启动时自动搜索 stories 目录 |
| 回退机制 | 没有剧本文件时用测试数据 |
| `story` 命令 | 查看当前加载的剧本信息 |
| 欢迎信息动态化 | 显示剧本标题 |

告诉我测试结果，确认没问题后阶段一就完成了！🎉

### USER
story命令可以查看剧本信息，这很好。但为什么godot引擎里面res://stories/目录不显示我的.scp文件，而且help菜单中没有story提示。
需要给story命令换一个更酷的名字，类似直接用story太出戏了。
另外，现在没有密码之类的功能，是之后再加吗？

### ASSISTANT
好问题，逐一回答：

## 问题1：Godot不显示.scp文件

Godot默认只识别它认识的文件格式，`.scp` 不在其中，所以文件系统面板里不显示，**但文件确实在那里**。有两个解决方案：

### 方案A：让Godot识别.scp文件（推荐）

在 `res://` 根目录下创建一个文件 `export_presets.cfg`... 其实更简单的方法是：

在 `res://` 根目录下创建文件 `.gdignore`... 不对，我们换个思路：

**最简单的方案**：把 `.scp` 文件改为 `.zip` 后缀，代码已经支持 `.zip`。

或者，在Godot中创建一个 `res://.import` 配置。但这些都太麻烦了。

**实际上文件是可以正常读取的**，只是Godot编辑器面板不显示。你可以用文件管理器确认文件在正确位置，运行时就能加载。

但如果你想在编辑器里看到，把后缀名改为 `.zip` 放进去即可，代码已经兼容。

## 问题2：help中没有story

## 问题3：命令改名

## 问题4：密码功能

密码系统是**阶段二**的核心功能，现在先不加。阶段一只建框架。

---

下面是具体修改：

## 修改1：help菜单添加新命令

找到 `_cmd_help` 函数中的：

```gdscript
	lines.append("  [color=#66FF66]exit[/color]          退出终端")
```

在它**下面**加一行：

```gdscript
	lines.append("  [color=#66FF66]protocol[/color]      查看当前载入的协议档案")
```

## 修改2：替换命令名称

找到 `_execute_command` 中的：

```gdscript
		"story", "info":
			_cmd_story_info()
```

替换为：

```gdscript
		"protocol", "proto":
			_cmd_story_info()
```

## 修改3：替换命令输出内容

找到整个 `_cmd_story_info` 函数，**替换为**：

```gdscript
func _cmd_story_info() -> void:
	if story_manifest.is_empty():
		append_output("[color=#AAAAAA]未检测到外部协议档案，当前运行于内置诊断模式。[/color]")
		return
	
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════ 协议档案信息 ═══════════[/color]")
	
	if story_manifest.has("story"):
		var info: Dictionary = story_manifest["story"]
		lines.append("  档案代号:   [color=#66FF66]" + info.get("title", "未知") + "[/color]")
		lines.append("  编撰者:     [color=#66FF66]" + info.get("author", "未知") + "[/color]")
		lines.append("  版本编号:   [color=#66FF66]" + info.get("version", "未知") + "[/color]")
		if info.has("description"):
			lines.append("  档案摘要:   [color=#AAAAAA]" + info["description"] + "[/color]")
	
	lines.append("  文件总数:   [color=#66FF66]" + str(file_system.size()) + "[/color]")
	lines.append("  安全等级:   [color=#FF6666]CLASSIFIED[/color]")
	lines.append("[color=#66FF66]════════════════════════════════════[/color]")
	append_output("\n".join(lines))
```

## 修改4：让Godot能导出时包含.scp和.zip文件

在 `res://` 根目录创建或编辑 `project.godot` 中不太方便，换个方式：

在 `_try_load_story` 函数中，同时支持从**用户目录**加载。找到函数开头的：

```gdscript
func _try_load_story() -> bool:
	var stories_dir := "res://stories/"
```

替换为：

```gdscript
func _try_load_story() -> bool:
	# 优先从用户目录加载，再尝试资源目录
	var search_dirs: Array[String] = [
		OS.get_executable_path().get_base_dir() + "/stories/",
		"res://stories/",
		"user://stories/"
	]
	
	for stories_dir in search_dirs:
		if _try_load_from_dir(stories_dir):
			return true
	
	print("[StoryLoader] 未找到剧本文件，使用测试数据")
	return false


func _try_load_from_dir(stories_dir: String) -> bool:
```

然后把原来 `_try_load_story` 中剩余的逻辑（从 `var dir := DirAccess.open` 开始到函数结尾）改为 `_try_load_from_dir` 的函数体：

找到原来 `_try_load_story` 中从 `# 检查目录是否存在` 开始到函数末尾的所有代码：

```gdscript
	# 检查目录是否存在
	if not DirAccess.dir_exists_absolute(stories_dir):
		print("[StoryLoader] stories 目录不存在，使用测试数据")
		return false
	
	# 遍历目录找 .scp 文件
	var dir := DirAccess.open(stories_dir)
	if dir == null:
		print("[StoryLoader] 无法打开 stories 目录")
		return false
	
	dir.list_dir_begin()
	var file_name := dir.get_next()
	while file_name != "":
		if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
			var full_path: String = stories_dir + file_name
			return _load_story_file(full_path)
		file_name = dir.get_next()
	
	print("[StoryLoader] 未找到 .scp 剧本文件，使用测试数据")
	return false
```

**删除这些代码**（它们现在在新的 `_try_load_from_dir` 函数里），替换 `_try_load_from_dir` 为：

```gdscript
func _try_load_from_dir(stories_dir: String) -> bool:
	if not DirAccess.dir_exists_absolute(stories_dir):
		return false
	
	var dir := DirAccess.open(stories_dir)
	if dir == null:
		return false
	
	dir.list_dir_begin()
	var file_name := dir.get_next()
	while file_name != "":
		if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
			var full_path: String = stories_dir + file_name
			print("[StoryLoader] 发现剧本: " + full_path)
			return _load_story_file(full_path)
		file_name = dir.get_next()
	
	return false
```

---

## 关于密码功能的规划

密码系统在**阶段二**实现，大致是这样的：

```
阶段二包含：
├── 密码/权限系统
│   ├── 某些文件需要密码才能打开
│   ├── 密码隐藏在其他文件的内容中
│   ├── login 命令用于登录不同权限等级
│   └── manifest.cfg 中定义密码和权限规则
├── CRT-ML 标记语言解析
│   ├── [speed=], [pause=] 已在阶段一完成
│   ├── [shake], [glitch] 等特效标签
│   └── [password_gate] 密码门标签
├── 邮件系统
└── 存档系统
```

---

## 总结

| 修改 | 说明 |
|------|------|
| help菜单 | 添加 protocol 命令提示 |
| 命令改名 | `story` → `protocol`（更有沉浸感） |
| 输出文案 | 改为"协议档案"风格 |
| 多目录搜索 | 支持从exe同级目录、res://、user:// 加载 |

保存 `Ctrl+S`，`F5` 测试。确认没问题后，**阶段一就全部完成了**！🎉

然后我们可以讨论进入阶段二的计划。

### USER
目前打开后是图片那样，最上面的标题需要修改一下，自动居中对齐外框长度需要自适应。
现在用protocol命令名还是不好，我打算之后兼容软盘，即插入软盘（disc）可以识别里面的文件故事，所以目前用类似于虚拟盘的名称（vdisc）替代原来的protocol命令。
下面我会给你现在的所有main.gd代码，你检查一下并进行修改。最后反馈需要修改的部分给我，不要全部发回，不然会导致对话断开，然后不要用四个空格“    ”替代制表符。

### ASSISTANT
我来修改。以下是需要改动的部分：

## 修改1：替换 `_show_welcome_message` 函数

找到整个 `_show_welcome_message` 函数，替换为：

```gdscript
func _show_welcome_message() -> void:
	var title: String = "SCP FOUNDATION TERMINAL v0.1"
	var subtitle: String = "SECURE - CONTAIN - PROTECT"
	
	if story_manifest.has("story"):
		var story_info: Dictionary = story_manifest["story"]
		if story_info.has("title"):
			subtitle = story_info["title"]
	
	# 计算框的宽度：取较长的那行，两侧各留3个空格
	var max_len: int = max(title.length(), subtitle.length())
	# 中英文混排时，中文字符占2个宽度，英文占1个
	var title_display_len: int = _display_width(title)
	var subtitle_display_len: int = _display_width(subtitle)
	var inner_width: int = max(title_display_len, subtitle_display_len) + 6
	
	# 居中填充
	var title_pad_total: int = inner_width - title_display_len
	var title_pad_left: int = title_pad_total / 2
	var title_pad_right: int = title_pad_total - title_pad_left
	
	var subtitle_pad_total: int = inner_width - subtitle_display_len
	var subtitle_pad_left: int = subtitle_pad_total / 2
	var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
	
	var border_h: String = "═".repeat(inner_width)
	
	var welcome: String = ""
	welcome += "[color=#66FF66]╔" + border_h + "╗\n"
	welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
	welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
	welcome += "╚" + border_h + "╝[/color]\n"
	welcome += "\n"
	welcome += "[color=#AAAAAA]终端系统已启动。\n"
	welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
	
	output_text.append_text(welcome)
```

## 修改2：添加 `_display_width` 辅助函数

在 `_show_welcome_message` 函数的**正下方**添加：

```gdscript
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func _display_width(text: String) -> int:
	var width: int = 0
	for ch in text:
		var code: int = ch.unicode_at(0)
		if code >= 0x4E00 and code <= 0x9FFF:
			width += 2  # CJK统一汉字
		elif code >= 0x3000 and code <= 0x303F:
			width += 2  # CJK标点
		elif code >= 0xFF00 and code <= 0xFFEF:
			width += 2  # 全角字符
		else:
			width += 1
	return width
```

## 修改3：命令名 protocol → vdisc

找到 `_cmd_help` 中的：

```gdscript
	lines.append("  [color=#66FF66]protocol[/color]      查看当前载入的协议档案")
```

替换为：

```gdscript
	lines.append("  [color=#66FF66]vdisc[/color]         查看当前载入的虚拟磁盘信息")
```

## 修改4：替换 `_execute_command` 中的命令匹配

找到：

```gdscript
		"protocol", "proto":
			_cmd_story_info()
```

替换为：

```gdscript
		"vdisc", "disc", "disk":
			_cmd_story_info()
```

## 修改5：替换 `_cmd_story_info` 函数

找到整个 `_cmd_story_info` 函数，替换为：

```gdscript
func _cmd_story_info() -> void:
	if story_manifest.is_empty():
		append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。[/color]")
		append_output("[color=#AAAAAA]将 .scp 或 .zip 文件放入 stories/ 目录后重启终端。[/color]")
		return
	
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════ 虚拟磁盘信息 ═══════════[/color]")
	
	if story_manifest.has("story"):
		var info: Dictionary = story_manifest["story"]
		lines.append("  磁盘标签:   [color=#66FF66]" + info.get("title", "未知") + "[/color]")
		lines.append("  制作者:     [color=#66FF66]" + info.get("author", "未知") + "[/color]")
		lines.append("  版本:       [color=#66FF66]" + info.get("version", "未知") + "[/color]")
		if info.has("description"):
			lines.append("  描述:       [color=#AAAAAA]" + info["description"] + "[/color]")
	
	lines.append("  文件总数:   [color=#66FF66]" + str(file_system.size()) + "[/color]")
	lines.append("  磁盘来源:   [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
	lines.append("  磁盘状态:   [color=#33FF33]已挂载[/color]")
	lines.append("[color=#66FF66]═══════════════════════════════════[/color]")
	append_output("\n".join(lines))
```

## 修改6：自动补全也加上新命令

找到 `_auto_complete` 中的命令列表：

```gdscript
		var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
						"clear", "cls", "status", "mail", "whoami", "exit", "quit"]
```

替换为：

```gdscript
		var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
						"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc"]
```

---

## 总结

| 修改 | 说明 |
|------|------|
| `_show_welcome_message` | 自适应框宽、居中对齐 |
| `_display_width` | 正确计算中英文混排宽度 |
| 命令改名 | `protocol` → `vdisc`（支持 disc/disk 别名） |
| `_cmd_story_info` | 文案改为虚拟磁盘风格 |
| 自动补全 | 添加 vdisc |

保存 `Ctrl+S`，`F5` 测试。标题框应该会自动根据内容长度调整宽度，文字居中。

### USER
目前表现很好，但在阅读时排版比较难看，在显示文档时就不要隔一行显示一行了，按原生txt内的格式显示即可，而且打开文档后需要自动清除之前的命令记录（进度条加载完成后停留一小会，然后自动消失），以提供更好的阅读体验和固定的页面大小，方便以后排版。
另外，目前显示故事的页面利用率太低了，之后能否以某种方式（例如使用模板等）整体类似于书页一样排版并显示文档，同时插入图片等多媒体内容？
最后，目前无法使用鼠标进行交互，目前无法通过滚轮上下滚动，为了以后插入超链接等功能请完善一下鼠标交互。

### ASSISTANT
好的，我来逐一修改。关于图片和模板排版的问题最后回答。

## 修改1：修复隔行问题 —— 替换 `append_output`

每次 `append_output` 都额外加了一个 `\n`，导致双倍换行。命令反馈需要空行间隔，但文档内容不需要。

找到 `append_output` 函数，**替换为**：

```gdscript
func append_output(text: String, extra_newline: bool = true) -> void:
	_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
	if not _is_typing:
		_process_typewriter_queue()
```

## 修改2：替换 `_process_typewriter_queue`

找到整个 `_process_typewriter_queue` 函数，**替换为**：

```gdscript
func _process_typewriter_queue() -> void:
	if _typewriter_queue.is_empty():
		_is_typing = false
		return
	
	_is_typing = true
	var entry = _typewriter_queue.pop_front()
	var text: String = entry["text"]
	var extra_newline: bool = entry["extra_newline"]
	
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	
	if _typewriter_instant:
		output_text.append_text(text)
		if extra_newline:
			output_text.append_text("\n")
		_do_scroll()
		_process_typewriter_queue()
	else:
		_typewrite_text(text, extra_newline)
```

## 修改3：修改 `_typewrite_text` 签名和结尾

找到 `_typewrite_text` 函数的**第一行**：

```gdscript
func _typewrite_text(text: String) -> void:
```

替换为：

```gdscript
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
```

然后在同一个函数中，找到接近末尾的：

```gdscript
	# 当前文本打完
	output_text.append_text("\n")
	_do_scroll()
```

替换为：

```gdscript
	# 当前文本打完
	if extra_newline:
		output_text.append_text("\n")
	_do_scroll()
```

## 修改4：替换 `_cmd_open` —— 清屏阅读模式

找到整个 `_cmd_open` 函数，**替换为**：

```gdscript
func _cmd_open(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
		return
	
	var filename: String = args[0]
	var file_path: String
	
	if filename.begins_with("/"):
		file_path = filename
	else:
		file_path = _join_path(current_path, filename)
	
	file_path = _normalize_path(file_path)
	
	var node := _get_node_at_path(file_path)
	if node == null:
		append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
		return
	if node.type != "file":
		append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
		return
	
	# 显示进度条
	var content_size: int = node.content.length()
	await _show_progress_bar(content_size)
	
	# 进度条完成后等待一小会
	await get_tree().create_timer(0.5).timeout
	
	# 清屏进入阅读模式
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false
	
	# 显示文件头
	var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
	append_output(header, false)
	append_output("", false)
	
	# 显示文件内容（不加额外空行，保持原始格式）
	append_output(node.content, false)
	
	# 显示文件尾
	append_output("", false)
	append_output("[color=#66FF66]══════════ 文件结束 ══════════[/color]", false)
	append_output("[color=#AAAAAA]输入任意命令返回终端。[/color]")
```

## 修改5：添加鼠标滚轮支持

找到 `_input` 函数，在函数的**最开头**（`if not event is InputEventKey` 之前），添加鼠标滚轮处理：

找到：

```gdscript
func _input(event: InputEvent) -> void:
	if not event is InputEventKey or not event.pressed:
		return
```

替换为：

```gdscript
func _input(event: InputEvent) -> void:
	# 鼠标滚轮滚动
	if event is InputEventMouseButton and event.pressed:
		match event.button_index:
			MOUSE_BUTTON_WHEEL_UP:
				scroll_container.scroll_vertical -= 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_WHEEL_DOWN:
				scroll_container.scroll_vertical += 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_LEFT:
				# 点击任意位置聚焦输入框
				input_field.grab_focus()
				return
	
	if not event is InputEventKey or not event.pressed:
		return
```

## 修改6：让 RichTextLabel 支持鼠标交互（为超链接做准备）

找到 `_ready` 函数中的：

```gdscript
	output_text.text = ""
	output_text.bbcode_enabled = true
```

在这两行**下面**加上：

```gdscript
	# 启用鼠标选择和交互（为超链接做准备）
	output_text.selection_enabled = true
	output_text.meta_underlined = true
	output_text.meta_clicked.connect(_on_meta_clicked)
```

然后在 `_show_welcome_message` 函数的**前面**添加超链接点击处理函数：

```gdscript
# 处理RichTextLabel中的超链接点击
func _on_meta_clicked(meta: Variant) -> void:
	var meta_str: String = str(meta)
	
	# 如果是命令链接，直接执行
	if meta_str.begins_with("cmd://"):
		var cmd: String = meta_str.substr(6)
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + cmd)
		output_text.append_text("\n")
		_execute_command(cmd)
		return
	
	# 如果是文件链接，打开文件
	if meta_str.begins_with("file://"):
		var file_path: String = meta_str.substr(7)
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> open " + file_path)
		output_text.append_text("\n")
		await _cmd_open([file_path])
		return
	
	print("[Terminal] 未知链接: " + meta_str)
```

---

## 关于图片和模板排版

> 之后能否以某种方式整体类似于书页一样排版并显示文档，同时插入图片等多媒体内容？

**完全可以**，这是阶段二的 CRT-ML 标记语言要做的事。方案是：

```
阶段二 CRT-ML 规划：
├── [img=path] → 在文档中嵌入图片
├── [center]居中文本[/center]
├── [box]带边框的文本块[/box]  
├── [hr] → 水平分割线
├── [indent=2]缩进内容[/indent]
├── [columns=2]分栏布局[/columns]
├── [link=cmd://open file.txt]可点击的链接[/link]
└── 模板系统：manifest.cfg 中定义页面模板
```

文档中写法类似：
```
[center][color=#66FF66]SCP-173 档案[/color][/center]
[hr]
[img=images/scp173.png]
[box]
项目等级: Euclid
收容等级: 标准
[/box]
```

这些在阶段二实现，现在的框架已经为此做好了准备（超链接点击已经能用了）。

---

## 总结

| 修改 | 说明 |
|------|------|
| `append_output` | 添加 `extra_newline` 参数，控制是否加空行 |
| `_process_typewriter_queue` | 适配新的队列数据结构 |
| `_typewrite_text` | 适配 `extra_newline` 参数 |
| `_cmd_open` | 进度条后清屏，文档保持原始格式 |
| `_input` | 添加鼠标滚轮、左键点击支持 |
| `_ready` | 启用选择、超链接交互 |
| `_on_meta_clicked` | 超链接点击处理（cmd://、file://） |

保存 `Ctrl+S`，`F5` 测试：

1. `open welcome.txt` → 进度条 → 短暂停留 → 清屏显示文档（原始格式，无多余空行）
2. 鼠标滚轮 → 可以上下滚动
3. 点击屏幕任意位置 → 输入框获得焦点

### USER
为什么现在输入指令没有反应了，我给你所有的main.gd代码，你仔细检查一下把需要修改的部分反馈给我，不要全部发我，不然会导致对话卡死。
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false
# 打字机效果
var _typewriter_queue: Array[String] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
# 尝试加载剧本，如果失败则用测试数据
if not _try_load_story():
_init_test_file_system()
output_text.text = ""
output_text.bbcode_enabled = true
# 启用鼠标选择和交互（为超链接做准备）
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
input_field.focus_mode = Control.FOCUS_ALL
# 阻止Tab键切换焦点，让我们自己处理
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
# 不再用 text_submitted 信号，改为手动监听回车键
input_field.grab_focus()
_update_status_bar()
_show_welcome_message()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 鼠标滚轮滚动
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 点击任意位置聚焦输入框
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
# 点击任何键都确保输入框有焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果正在打字或加载，按空格或ESC跳过动画
if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
_typewriter_instant = true
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
# 如果正在打字，忽略回车（防止干扰）
if _is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
command_history.append(raw_input)
history_index = -1
# 命令回显用即时显示（不走打字机）
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input)
output_text.append_text("\n")
# 执行命令（命令输出走打字机效果）
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
# 重置打字机为动画模式
_typewriter_instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
_cmd_story_info()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]")
append_output("输入 [color=#66FF66]help[/color] 查看可用命令。")
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("  [color=#66FF66]vdisc[/color]         查看当前载入的虚拟磁盘信息")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines))
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
if node.type == "folder":
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines))
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 显示进度条
var content_size: int = node.content.length()
await _show_progress_bar(content_size)
# 进度条完成后等待一小会
await get_tree().create_timer(0.5).timeout
# 清屏进入阅读模式
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
# 显示文件头
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
append_output(header, false)
append_output("", false)
# 显示文件内容（不加额外空行，保持原始格式）
append_output(node.content, false)
# 显示文件尾
append_output("", false)
append_output("[color=#66FF66]══════════ 文件结束 ══════════[/color]", false)
append_output("[color=#AAAAAA]输入任意命令返回终端。[/color]")
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path)
func _cmd_clear() -> void:
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名:     [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]0[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]0[/color]")
lines.append("  已获取密码: [color=#66FF66]0[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines))
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。[/color]")
append_output("[color=#AAAAAA](邮件系统将在后续版本中实现)[/color]")
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]")
append_output("[color=#AAAAAA](用户系统将在后续版本中实现)[/color]")
func _cmd_story_info() -> void:
if story_manifest.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。[/color]")
append_output("[color=#AAAAAA]将 .scp 或 .zip 文件放入 stories/ 目录后重启终端。[/color]")
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 虚拟磁盘信息 ═══════════[/color]")
if story_manifest.has("story"):
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签:   [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者: [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本:    [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述:    [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数:   [color=#66FF66]" + str(file_system.size()) + "[/color]")
lines.append("  磁盘来源:   [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态:   [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════[/color]")
append_output("\n".join(lines))
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
# 只输入了一个词：补全命令
if parts.size() == 1:
# 检查是否已经是完整命令，后面有空格表示要补全参数
if current_text.ends_with(" "):
# 命令已输入完，补全文件名（无前缀匹配，列出所有）
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只补全文件夹，open/cat只补全文件
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
append_output("[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
else:
# 补全命令名
var partial_cmd: String = parts[0].to_lower()
var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
append_output("[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
# 两个词：命令 + 部分文件名
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只匹配文件夹，open/cat只匹配文件
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
# 找公共前缀，补全到最长公共部分
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
append_output("[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
# 查找多个字符串的最长公共前缀
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
if not _is_typing:
_process_typewriter_queue()
func _process_typewriter_queue() -> void:
if _typewriter_queue.is_empty():
_is_typing = false
return
_is_typing = true
var entry = _typewriter_queue.pop_front()
var text: String = entry["text"]
var extra_newline: bool = entry["extra_newline"]
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
if _typewriter_instant:
output_text.append_text(text)
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
else:
_typewrite_text(text, extra_newline)
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
var i: int = 0
var length: int = text.length()
_current_char_speed = _typewriter_speed
while i < length:
# 如果中途切换为即时模式，把剩余文本一次性输出
if _typewriter_instant:
output_text.append_text(text.substr(i))
break
# 检查是否是BBCode标签
if text[i] == "[":
var close_bracket: int = text.find("]", i)
if close_bracket != -1:
var tag: String = text.substr(i, close_bracket - i + 1)
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 普通BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 普通字符
var ch: String = text[i]
output_text.append_text(ch)
i += 1
# 根据字符类型决定延迟
var delay: float = _current_char_speed
# 标点符号额外停顿（制造顿挫感）
if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
delay += _typewriter_period_pause
elif ch in ["、", "—", "-", "…"]:
delay += _typewriter_comma_pause
elif ch == "\n":
delay += _typewriter_period_pause
else:
# 随机顿挫：有一定概率额外停顿
if randf() < _typewriter_pause_chance:
delay += _typewriter_pause_duration
await get_tree().create_timer(delay).timeout
# 每隔几个字符滚动一次
if i % 8 == 0:
_do_scroll()
# 当前文本打完
if extra_newline:
output_text.append_text("\n")
_do_scroll()
# 继续处理队列
_process_typewriter_queue()
func _do_scroll() -> void:
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
scroll_container.scroll_vertical = int(v_scroll.max_value)
# 显示文件加载进度条
# file_size: 文件内容长度，影响进度条速度
# speed_override: 速度倍率覆盖，-1表示用默认
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
var bar_width: int = 30  # 进度条总长度（字符数）
var speed: float = _progress_bar_speed
if speed_override > 0.0:
speed = speed_override
# 文件越大，每格停顿越长（但有上下限）
var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
base_delay /= speed
# 起始行
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("[color=#66FF66]加载中 [[/color]")
for i in range(bar_width):
if _typewriter_instant:
# 跳过动画，直接填满
var remaining: int = bar_width - i
output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
break
output_text.append_text("[color=#33FF33]█[/color]")
_do_scroll()
# 随机波动让进度条不匀速，更真实
var jitter: float = randf_range(0.7, 1.5)
await get_tree().create_timer(base_delay * jitter).timeout
output_text.append_text("[color=#66FF66]] 完成[/color]\n")
_do_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
path_label.text = "[" + current_path + "]"
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
# 处理RichTextLabel中的超链接点击
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
# 如果是命令链接，直接执行
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
# 如果是文件链接，打开文件
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
# 计算框的宽度：取较长的那行，两侧各留3个空格
var max_len: int = max(title.length(), subtitle.length())
# 中英文混排时，中文字符占2个宽度，英文占1个
var title_display_len: int = _display_width(title)
var subtitle_display_len: int = _display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
# 居中填充
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func _display_width(text: String) -> int:
var width: int = 0
for ch in text:
var code: int = ch.unicode_at(0)
if code >= 0x4E00 and code <= 0x9FFF:
width += 2  # CJK统一汉字
elif code >= 0x3000 and code <= 0x303F:
width += 2  # CJK标点
elif code >= 0xFF00 and code <= 0xFFEF:
width += 2  # 全角字符
else:
width += 1
return width
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
return FSNode.new(entry.get("type", "file"), entry.get("content", ""))
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 测试文件系统初始化
# ============================================================
# 尝试从 stories 目录加载第一个 .scp 文件
func _try_load_story() -> bool:
# 优先从用户目录加载，再尝试资源目录
var search_dirs: Array[String] = [
OS.get_executable_path().get_base_dir() + "/stories/",
"res://stories/",
"user://stories/"
]
for stories_dir in search_dirs:
if _try_load_from_dir(stories_dir):
return true
print("[StoryLoader] 未找到剧本文件，使用测试数据")
return false
func _try_load_from_dir(stories_dir: String) -> bool:
if not DirAccess.dir_exists_absolute(stories_dir):
return false
var dir := DirAccess.open(stories_dir)
if dir == null:
return false
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = stories_dir + file_name
print("[StoryLoader] 发现剧本: " + full_path)
return _load_story_file(full_path)
file_name = dir.get_next()
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据
file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 应用 manifest 中的设置
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
_typewriter_speed = settings["typing_speed"].to_float()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 文件数量: " + str(file_system.size()))
return true
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
我找到了问题。核心原因是 `_typewriter_queue` 的类型声明与实际存入的数据不匹配。

你在变量声明处写的是：

```gdscript
var _typewriter_queue: Array[String] = []
```

但 `append_output` 里往队列中放的是 **Dictionary**：

```gdscript
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
```

类型不匹配导致 `append` 静默失败，队列始终为空，所以命令输出没有任何反应。

## 修改1：修复队列类型声明

找到：

```gdscript
var _typewriter_queue: Array[String] = []  # 待显示的文本队列
```

替换为：

```gdscript
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
```

---

只需要这一个改动。保存 `Ctrl+S`，`F5` 测试。输入 `help`、`ls`、`open welcome.txt` 看看是否正常。

### USER
还是存在问题：
1.输入一次ls后打开文档没有显示进度条，但打开过一次文档再打开文档就会显示进度条。
2.打开文档后还是会有多余的空行，需要进行修改。

### ASSISTANT
我来分析这两个问题。

## 问题1：第一次打开没有进度条

原因是 `_cmd_open` 中有 `await _show_progress_bar()`，但 `_execute_command` 是被 `_on_command_submitted` 通过 `await` 调用的，而此时打字机可能还在处理 `ls` 的输出。进度条和打字队列产生了冲突。

## 问题2：多余空行

原因是 `_process_typewriter_queue` 中每次都会先加一个 `\n`，即使上一条设了 `extra_newline = false`。

---

## 修改1：替换 `_process_typewriter_queue`

找到整个 `_process_typewriter_queue`，替换为：

```gdscript
func _process_typewriter_queue() -> void:
	if _typewriter_queue.is_empty():
		_is_typing = false
		return
	
	_is_typing = true
	var entry = _typewriter_queue.pop_front()
	var text: String = entry["text"]
	var extra_newline: bool = entry["extra_newline"]
	
	if _typewriter_instant:
		output_text.append_text(text)
		if extra_newline:
			output_text.append_text("\n")
		_do_scroll()
		_process_typewriter_queue()
	else:
		_typewrite_text(text, extra_newline)
```

（去掉了开头自动加 `\n` 的逻辑）

## 修改2：替换 `_cmd_open`

找到整个 `_cmd_open` 函数，替换为：

```gdscript
func _cmd_open(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
		return
	
	var filename: String = args[0]
	var file_path: String
	
	if filename.begins_with("/"):
		file_path = filename
	else:
		file_path = _join_path(current_path, filename)
	
	file_path = _normalize_path(file_path)
	
	var node := _get_node_at_path(file_path)
	if node == null:
		append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
		return
	if node.type != "file":
		append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
		return
	
	# 先等待打字队列全部完成
	while _is_typing:
		await get_tree().process_frame
	
	# 显示进度条（直接操作output_text，不走打字队列）
	var content_size: int = node.content.length()
	await _show_progress_bar(content_size)
	
	# 进度条完成后等待一小会
	await get_tree().create_timer(0.5).timeout
	
	# 清屏进入阅读模式
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false
	
	# 显示文件头
	var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
	output_text.append_text(header + "\n\n")
	
	# 显示文件内容（走打字机，不加额外空行）
	append_output(node.content, false)
	
	# 文件尾放入队列，等内容打完后显示
	append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]", false)
	append_output("[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
```

## 修改3：替换 `_on_command_submitted` 中的命令回显

找到 `_on_command_submitted` 中的：

```gdscript
	# 命令回显用即时显示（不走打字机）
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text("> " + raw_input)
	output_text.append_text("\n")
```

替换为：

```gdscript
	# 等待打字队列完成
	while _is_typing:
		await get_tree().process_frame
	
	# 命令回显用即时显示（不走打字机）
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text("> " + raw_input + "\n")
```

## 修改4：修复其他命令的空行问题

各命令用 `append_output` 时需要统一。找到 `_cmd_cd` 中的：

```gdscript
	append_output("已切换到: " + current_path)
```

替换为：

```gdscript
	append_output("已切换到: " + current_path + "\n", false)
```

找到 `_cmd_back` 中的：

```gdscript
	append_output("已返回: " + current_path)
```

替换为：

```gdscript
	append_output("已返回: " + current_path + "\n", false)
```

找到 `_execute_command` 最后的未知命令部分：

```gdscript
		_:
			append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]")
			append_output("输入 [color=#66FF66]help[/color] 查看可用命令。")
```

替换为：

```gdscript
		_:
			append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
```

找到 `_cmd_mail` 中的：

```gdscript
	append_output("[color=#AAAAAA]收件箱为空。[/color]")
	append_output("[color=#AAAAAA](邮件系统将在后续版本中实现)[/color]")
```

替换为：

```gdscript
	append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
```

找到 `_cmd_whoami` 中的：

```gdscript
	append_output("[color=#66FF66]未登录用户[/color]")
	append_output("[color=#AAAAAA](用户系统将在后续版本中实现)[/color]")
```

替换为：

```gdscript
	append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
```

找到 `_cmd_story_info` 中**两处** `append_output`（空磁盘时的两行）：

```gdscript
	append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。[/color]")
	append_output("[color=#AAAAAA]将 .scp 或 .zip 文件放入 stories/ 目录后重启终端。[/color]")
```

替换为：

```gdscript
	append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 stories/ 目录后重启终端。[/color]\n", false)
```

## 修改5：让各命令的多行输出统一加末尾换行

找到 `_cmd_help` 末尾的：

```gdscript
	append_output("\n".join(lines))
```

替换为：

```gdscript
	append_output("\n".join(lines) + "\n", false)
```

找到 `_cmd_ls` 末尾的：

```gdscript
	append_output("\n".join(lines))
```

替换为：

```gdscript
	append_output("\n".join(lines) + "\n", false)
```

找到 `_cmd_status` 末尾的：

```gdscript
	append_output("\n".join(lines))
```

替换为：

```gdscript
	append_output("\n".join(lines) + "\n", false)
```

找到 `_cmd_story_info` 末尾的（有磁盘信息时的那个）：

```gdscript
	append_output("\n".join(lines))
```

替换为：

```gdscript
	append_output("\n".join(lines) + "\n", false)
```

---

## 总结

| 修改 | 原因 |
|------|------|
| `_process_typewriter_queue` | 去掉自动加 `\n`，由调用者控制换行 |
| `_cmd_open` | 等待队列完成后再显示进度条 |
| `_on_command_submitted` | 等待队列完成后再回显命令 |
| 所有命令输出 | 统一用 `extra_newline=false`，在文本内自己控制换行 |

保存 `Ctrl+S`，`F5` 测试：
1. `ls` → 正常显示，无多余空行
2. `open welcome.txt` → 应出现进度条 → 清屏显示文档
3. 连续多次 `open` 不同文件 → 每次都有进度条

### USER
func _process_typewriter_queue() -> void:部分代码中报错
第 546 行：Expected indented block after lambda declaration.
第 547 行：Expected "else" after ternary operator condition.
第 547 行：Expected expression after "else".
第 547 行：Expected end of statement after expression, found ":" instead.
第 548 行：Expected statement, found "Indent" instead.
第 551 行：Unexpected identifier "_is_typing" in class body.
第 556 行：Unexpected "if" in class body.
第 557 行：Unexpected "Indent" in class body.
第 558 行：Unexpected "if" in class body.
第 559 行：Unexpected "Indent" in class body.
第 559 行：Expected end of file.

### ASSISTANT
这是缩进问题。你的代码可能混用了Tab和空格。我把这个函数重新给你，请**完整删除**原来的 `_process_typewriter_queue` 函数，然后粘贴以下内容：

确保你的编辑器用的是 **Tab缩进**。找到整个 `_process_typewriter_queue` 函数（从 `func _process_typewriter_queue` 到下一个 `func` 之前），全部删除，替换为：

```
func _process_typewriter_queue() -> void:
[TAB]if _typewriter_queue.is_empty():
[TAB][TAB]_is_typing = false
[TAB][TAB]return
[TAB]
[TAB]_is_typing = true
[TAB]var entry = _typewriter_queue.pop_front()
[TAB]var text: String = entry["text"]
[TAB]var extra_newline: bool = entry["extra_newline"]
[TAB]
[TAB]if _typewriter_instant:
[TAB][TAB]output_text.append_text(text)
[TAB][TAB]if extra_newline:
[TAB][TAB][TAB]output_text.append_text("\n")
[TAB][TAB]_do_scroll()
[TAB][TAB]_process_typewriter_queue()
[TAB]else:
[TAB][TAB]_typewrite_text(text, extra_newline)
```

其中 `[TAB]` 表示一个制表符。如果你在Godot脚本编辑器中直接粘贴，请用这个可以直接复制的版本：

在Godot脚本编辑器中：
1. 删除整个旧的 `_process_typewriter_queue` 函数
2. 输入 `func _process_typewriter_queue() -> void:` 然后回车
3. 按Tab输入 `if _typewriter_queue.is_empty():` 回车
4. 连按两个Tab输入 `_is_typing = false` 回车
5. 连按两个Tab输入 `return` 回车
6. 回车空一行
7. 按Tab输入 `_is_typing = true` 回车
8. 按Tab输入 `var entry = _typewriter_queue.pop_front()` 回车
9. 按Tab输入 `var text: String = entry["text"]` 回车
10. 按Tab输入 `var extra_newline: bool = entry["extra_newline"]` 回车
11. 回车空一行
12. 按Tab输入 `if _typewriter_instant:` 回车
13. 按两个Tab输入 `output_text.append_text(text)` 回车
14. 按两个Tab输入 `if extra_newline:` 回车
15. 按三个Tab输入 `output_text.append_text("\n")` 回车
16. 按两个Tab输入 `_do_scroll()` 回车
17. 按两个Tab输入 `_process_typewriter_queue()` 回车
18. 按Tab输入 `else:` 回车
19. 按两个Tab输入 `_typewrite_text(text, extra_newline)`

保存后看看报错是否消失。

### USER
目前存在问题：
1.输入命令，后面没有具体文件名时按tab补全不会出现补全提示，需要修正。
2.文档内还是会自动空行，需要修改。
我给你目前所有的main.gd，你仔细检查并修改好，反馈回我时不要给出全部代码，只要需要修改的那部分即可，不然回导致对话卡住。

### ASSISTANT


### USER
目前存在问题：  
1.输入命令，后面没有具体文件名时按tab补全不会出现补全提示，需要修正。  
2.文档内还是会自动空行，需要修改。  
我给你目前所有的main.gd，你仔细检查并修改好，反馈回我时不要给出全部代码，只要需要修改的那部分即可，不然回导致对话卡住。下面是代码：
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false
# 打字机效果
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
# 尝试加载剧本，如果失败则用测试数据
if not _try_load_story():
_init_test_file_system()
output_text.text = ""
output_text.bbcode_enabled = true
# 启用鼠标选择和交互（为超链接做准备）
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
input_field.focus_mode = Control.FOCUS_ALL
# 阻止Tab键切换焦点，让我们自己处理
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
# 不再用 text_submitted 信号，改为手动监听回车键
input_field.grab_focus()
_update_status_bar()
_show_welcome_message()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 鼠标滚轮滚动
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 点击任意位置聚焦输入框
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
# 点击任何键都确保输入框有焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果正在打字或加载，按空格或ESC跳过动画
if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
_typewriter_instant = true
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
# 如果正在打字，忽略回车（防止干扰）
if _is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
command_history.append(raw_input)
history_index = -1
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 命令回显用即时显示（不走打字机）
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
# 执行命令（命令输出走打字机效果）
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
# 重置打字机为动画模式
_typewriter_instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
_cmd_story_info()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("  [color=#66FF66]vdisc[/color]         查看当前载入的虚拟磁盘信息")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
if node.type == "folder":
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 先等待打字队列全部完成
while _is_typing:
await get_tree().process_frame
# 显示进度条（直接操作output_text，不走打字队列）
var content_size: int = node.content.length()
await _show_progress_bar(content_size)
# 进度条完成后等待一小会
await get_tree().create_timer(0.5).timeout
# 清屏进入阅读模式
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
# 显示文件头
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
# 显示文件内容（走打字机，不加额外空行）
append_output(node.content, false)
# 文件尾放入队列，等内容打完后显示
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]", false)
append_output("[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名:     [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]0[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]0[/color]")
lines.append("  已获取密码: [color=#66FF66]0[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 stories/ 目录后重启终端。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 虚拟磁盘信息 ═══════════[/color]")
if story_manifest.has("story"):
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签:   [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者: [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本:    [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述:    [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数:   [color=#66FF66]" + str(file_system.size()) + "[/color]")
lines.append("  磁盘来源:   [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态:   [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
# 只输入了一个词：补全命令
if parts.size() == 1:
# 检查是否已经是完整命令，后面有空格表示要补全参数
if current_text.ends_with(" "):
# 命令已输入完，补全文件名（无前缀匹配，列出所有）
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只补全文件夹，open/cat只补全文件
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
append_output("[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
else:
# 补全命令名
var partial_cmd: String = parts[0].to_lower()
var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
append_output("[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
# 两个词：命令 + 部分文件名
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只匹配文件夹，open/cat只匹配文件
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
# 找公共前缀，补全到最长公共部分
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
append_output("[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
# 查找多个字符串的最长公共前缀
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
if not _is_typing:
_process_typewriter_queue()
func _process_typewriter_queue() -> void:
if _typewriter_queue.is_empty():
_is_typing = false
return
_is_typing = true
var entry = _typewriter_queue.pop_front()
var text: String = entry["text"]
var extra_newline: bool = entry["extra_newline"]
if _typewriter_instant:
output_text.append_text(text)
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
else:
_typewrite_text(text, extra_newline)
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
var i: int = 0
var length: int = text.length()
_current_char_speed = _typewriter_speed
while i < length:
# 如果中途切换为即时模式，把剩余文本一次性输出
if _typewriter_instant:
output_text.append_text(text.substr(i))
break
# 检查是否是BBCode标签
if text[i] == "[":
var close_bracket: int = text.find("]", i)
if close_bracket != -1:
var tag: String = text.substr(i, close_bracket - i + 1)
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 普通BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 普通字符
var ch: String = text[i]
output_text.append_text(ch)
i += 1
# 根据字符类型决定延迟
var delay: float = _current_char_speed
# 标点符号额外停顿（制造顿挫感）
if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
delay += _typewriter_period_pause
elif ch in ["、", "—", "-", "…"]:
delay += _typewriter_comma_pause
elif ch == "\n":
delay += _typewriter_period_pause
else:
# 随机顿挫：有一定概率额外停顿
if randf() < _typewriter_pause_chance:
delay += _typewriter_pause_duration
await get_tree().create_timer(delay).timeout
# 每隔几个字符滚动一次
if i % 8 == 0:
_do_scroll()
# 当前文本打完
if extra_newline:
output_text.append_text("\n")
_do_scroll()
# 继续处理队列
_process_typewriter_queue()
func _do_scroll() -> void:
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
scroll_container.scroll_vertical = int(v_scroll.max_value)
# 显示文件加载进度条
# file_size: 文件内容长度，影响进度条速度
# speed_override: 速度倍率覆盖，-1表示用默认
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
var bar_width: int = 30  # 进度条总长度（字符数）
var speed: float = _progress_bar_speed
if speed_override > 0.0:
speed = speed_override
# 文件越大，每格停顿越长（但有上下限）
var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
base_delay /= speed
# 起始行
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("[color=#66FF66]加载中 [[/color]")
for i in range(bar_width):
if _typewriter_instant:
# 跳过动画，直接填满
var remaining: int = bar_width - i
output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
break
output_text.append_text("[color=#33FF33]█[/color]")
_do_scroll()
# 随机波动让进度条不匀速，更真实
var jitter: float = randf_range(0.7, 1.5)
await get_tree().create_timer(base_delay * jitter).timeout
output_text.append_text("[color=#66FF66]] 完成[/color]\n")
_do_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
path_label.text = "[" + current_path + "]"
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
# 处理RichTextLabel中的超链接点击
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
# 如果是命令链接，直接执行
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
# 如果是文件链接，打开文件
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
# 计算框的宽度：取较长的那行，两侧各留3个空格
var max_len: int = max(title.length(), subtitle.length())
# 中英文混排时，中文字符占2个宽度，英文占1个
var title_display_len: int = _display_width(title)
var subtitle_display_len: int = _display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
# 居中填充
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func _display_width(text: String) -> int:
var width: int = 0
for ch in text:
var code: int = ch.unicode_at(0)
if code >= 0x4E00 and code <= 0x9FFF:
width += 2  # CJK统一汉字
elif code >= 0x3000 and code <= 0x303F:
width += 2  # CJK标点
elif code >= 0xFF00 and code <= 0xFFEF:
width += 2  # 全角字符
else:
width += 1
return width
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
return FSNode.new(entry.get("type", "file"), entry.get("content", ""))
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 测试文件系统初始化
# ============================================================
# 尝试从 stories 目录加载第一个 .scp 文件
func _try_load_story() -> bool:
# 优先从用户目录加载，再尝试资源目录
var search_dirs: Array[String] = [
OS.get_executable_path().get_base_dir() + "/stories/",
"res://stories/",
"user://stories/"
]
for stories_dir in search_dirs:
if _try_load_from_dir(stories_dir):
return true
print("[StoryLoader] 未找到剧本文件，使用测试数据")
return false
func _try_load_from_dir(stories_dir: String) -> bool:
if not DirAccess.dir_exists_absolute(stories_dir):
return false
var dir := DirAccess.open(stories_dir)
if dir == null:
return false
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = stories_dir + file_name
print("[StoryLoader] 发现剧本: " + full_path)
return _load_story_file(full_path)
file_name = dir.get_next()
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据
file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 应用 manifest 中的设置
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
_typewriter_speed = settings["typing_speed"].to_float()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 文件数量: " + str(file_system.size()))
return true
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
我仔细检查了代码，找到了两个问题的根本原因。

## 问题1：Tab补全不显示提示

原因是 `_auto_complete` 中调用 `append_output` 时没传 `false`，走了默认的 `extra_newline = true`，但自动补全的提示需要即时显示，不应该走打字队列。

找到 `_auto_complete` 函数中**所有的** `append_output` 调用（共4处），逐一修改：

### 修改1a

找到（大约在 `if current_text.ends_with(" ")` 分支里）：

```gdscript
					if display.size() > 0:
						append_output("[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
```

替换为：

```gdscript
					if display.size() > 0:
						output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
						_do_scroll()
```

### 修改1b

找到（补全命令名分支里）：

```gdscript
			elif matches.size() > 1:
				append_output("[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
```

替换为：

```gdscript
			elif matches.size() > 1:
				output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
				_do_scroll()
```

### 修改1c

找到（两个词补全分支里，`elif matches.size() > 1:` 下面）：

```gdscript
				append_output("[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
```

替换为：

```gdscript
				output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
				_do_scroll()
```

---

## 问题2：文档内多余空行

根本原因是测试数据中用了 `"""` 三引号字符串，GDScript的三引号会把你代码中的换行原样保留。你的测试数据每行之间有一个空行，就是因为三引号字符串里本身就有空行。

找到 `_init_test_file_system` 函数中 **所有的** `"""` 多行字符串内容，把内容中的空行去掉。

例如，找到：

```gdscript
		"/welcome.txt": {
			"type": "file",
			"content": """欢迎接入SCP基金会安全终端系统。

本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。

请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。

- 基金会信息安全部门"""
		},
```

如果你**想要**有空行就保留，如果**不想要**就删掉空行。但更关键的问题是三引号的**首行**会产生一个多余换行。

更干净的做法是把所有 `content` 改为单行拼接。但文件太多改起来麻烦，所以我们在显示时去掉首尾多余换行。

找到 `_cmd_open` 函数中的：

```gdscript
	# 显示文件内容（走打字机，不加额外空行）
	append_output(node.content, false)
```

替换为：

```gdscript
	# 显示文件内容（走打字机，不加额外空行）
	# strip_edges去除三引号字符串首尾多余的换行
	var clean_content: String = node.content.strip_edges()
	append_output(clean_content, false)
```

---

以上就是所有需要修改的部分。保存 `Ctrl+S`，`F5` 测试：

1. 输入 `open ` 按 Tab → 应该立即显示可选文件列表
2. 输入 `cd ` 按 Tab → 应该立即显示可选文件夹
3. `open welcome.txt` → 文档内容不应有首尾多余空行

### USER
目前存在问题：  
1.输入命令后面没有具体文件名时按tab补全现在有提示了，但不会自动滚到最下面，需要修正。  
2.打开文档后，文档原txt内没有空行，但显示时有自动空行，需要修改。  
我给你目前所有的main.gd，你仔细检查并修改好，反馈回我时不要给出全部代码，只要需要修改的那部分即可，不然回导致对话卡住。下面是代码：
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false
# 打字机效果
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
# 尝试加载剧本，如果失败则用测试数据
if not _try_load_story():
_init_test_file_system()
output_text.text = ""
output_text.bbcode_enabled = true
# 启用鼠标选择和交互（为超链接做准备）
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
input_field.focus_mode = Control.FOCUS_ALL
# 阻止Tab键切换焦点，让我们自己处理
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
# 不再用 text_submitted 信号，改为手动监听回车键
input_field.grab_focus()
_update_status_bar()
_show_welcome_message()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 鼠标滚轮滚动
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 点击任意位置聚焦输入框
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
# 点击任何键都确保输入框有焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果正在打字或加载，按空格或ESC跳过动画
if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
_typewriter_instant = true
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
# 如果正在打字，忽略回车（防止干扰）
if _is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
command_history.append(raw_input)
history_index = -1
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 命令回显用即时显示（不走打字机）
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
# 执行命令（命令输出走打字机效果）
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
# 重置打字机为动画模式
_typewriter_instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
_cmd_story_info()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("  [color=#66FF66]vdisc[/color]         查看当前载入的虚拟磁盘信息")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
if node.type == "folder":
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 先等待打字队列全部完成
while _is_typing:
await get_tree().process_frame
# 显示进度条（直接操作output_text，不走打字队列）
var content_size: int = node.content.length()
await _show_progress_bar(content_size)
# 进度条完成后等待一小会
await get_tree().create_timer(0.5).timeout
# 清屏进入阅读模式
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
# 显示文件头
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
# 显示文件内容（走打字机，不加额外空行）
# strip_edges去除三引号字符串首尾多余的换行
var clean_content: String = node.content.strip_edges()
append_output(clean_content, false)
# 文件尾放入队列，等内容打完后显示
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]", false)
append_output("[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名:     [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]0[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]0[/color]")
lines.append("  已获取密码: [color=#66FF66]0[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 stories/ 目录后重启终端。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 虚拟磁盘信息 ═══════════[/color]")
if story_manifest.has("story"):
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签:   [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者: [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本:    [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述:    [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数:   [color=#66FF66]" + str(file_system.size()) + "[/color]")
lines.append("  磁盘来源:   [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态:   [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
# 只输入了一个词：补全命令
if parts.size() == 1:
# 检查是否已经是完整命令，后面有空格表示要补全参数
if current_text.ends_with(" "):
# 命令已输入完，补全文件名（无前缀匹配，列出所有）
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只补全文件夹，open/cat只补全文件
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
_do_scroll()
else:
# 补全命令名
var partial_cmd: String = parts[0].to_lower()
var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 两个词：命令 + 部分文件名
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只匹配文件夹，open/cat只匹配文件
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
# 找公共前缀，补全到最长公共部分
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 查找多个字符串的最长公共前缀
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
if not _is_typing:
_process_typewriter_queue()
func _process_typewriter_queue() -> void:
if _typewriter_queue.is_empty():
_is_typing = false
return
_is_typing = true
var entry = _typewriter_queue.pop_front()
var text: String = entry["text"]
var extra_newline: bool = entry["extra_newline"]
if _typewriter_instant:
output_text.append_text(text)
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
else:
_typewrite_text(text, extra_newline)
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
var i: int = 0
var length: int = text.length()
_current_char_speed = _typewriter_speed
while i < length:
# 如果中途切换为即时模式，把剩余文本一次性输出
if _typewriter_instant:
output_text.append_text(text.substr(i))
break
# 检查是否是BBCode标签
if text[i] == "[":
var close_bracket: int = text.find("]", i)
if close_bracket != -1:
var tag: String = text.substr(i, close_bracket - i + 1)
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 普通BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 普通字符
var ch: String = text[i]
output_text.append_text(ch)
i += 1
# 根据字符类型决定延迟
var delay: float = _current_char_speed
# 标点符号额外停顿（制造顿挫感）
if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
delay += _typewriter_period_pause
elif ch in ["、", "—", "-", "…"]:
delay += _typewriter_comma_pause
elif ch == "\n":
delay += _typewriter_period_pause
else:
# 随机顿挫：有一定概率额外停顿
if randf() < _typewriter_pause_chance:
delay += _typewriter_pause_duration
await get_tree().create_timer(delay).timeout
# 每隔几个字符滚动一次
if i % 8 == 0:
_do_scroll()
# 当前文本打完
if extra_newline:
output_text.append_text("\n")
_do_scroll()
# 继续处理队列
_process_typewriter_queue()
func _do_scroll() -> void:
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
scroll_container.scroll_vertical = int(v_scroll.max_value)
# 显示文件加载进度条
# file_size: 文件内容长度，影响进度条速度
# speed_override: 速度倍率覆盖，-1表示用默认
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
var bar_width: int = 30  # 进度条总长度（字符数）
var speed: float = _progress_bar_speed
if speed_override > 0.0:
speed = speed_override
# 文件越大，每格停顿越长（但有上下限）
var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
base_delay /= speed
# 起始行
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("[color=#66FF66]加载中 [[/color]")
for i in range(bar_width):
if _typewriter_instant:
# 跳过动画，直接填满
var remaining: int = bar_width - i
output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
break
output_text.append_text("[color=#33FF33]█[/color]")
_do_scroll()
# 随机波动让进度条不匀速，更真实
var jitter: float = randf_range(0.7, 1.5)
await get_tree().create_timer(base_delay * jitter).timeout
output_text.append_text("[color=#66FF66]] 完成[/color]\n")
_do_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
path_label.text = "[" + current_path + "]"
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
# 处理RichTextLabel中的超链接点击
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
# 如果是命令链接，直接执行
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
# 如果是文件链接，打开文件
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
# 计算框的宽度：取较长的那行，两侧各留3个空格
var max_len: int = max(title.length(), subtitle.length())
# 中英文混排时，中文字符占2个宽度，英文占1个
var title_display_len: int = _display_width(title)
var subtitle_display_len: int = _display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
# 居中填充
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func _display_width(text: String) -> int:
var width: int = 0
for ch in text:
var code: int = ch.unicode_at(0)
if code >= 0x4E00 and code <= 0x9FFF:
width += 2  # CJK统一汉字
elif code >= 0x3000 and code <= 0x303F:
width += 2  # CJK标点
elif code >= 0xFF00 and code <= 0xFFEF:
width += 2  # 全角字符
else:
width += 1
return width
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
return FSNode.new(entry.get("type", "file"), entry.get("content", ""))
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 测试文件系统初始化
# ============================================================
# 尝试从 stories 目录加载第一个 .scp 文件
func _try_load_story() -> bool:
# 优先从用户目录加载，再尝试资源目录
var search_dirs: Array[String] = [
OS.get_executable_path().get_base_dir() + "/stories/",
"res://stories/",
"user://stories/"
]
for stories_dir in search_dirs:
if _try_load_from_dir(stories_dir):
return true
print("[StoryLoader] 未找到剧本文件，使用测试数据")
return false
func _try_load_from_dir(stories_dir: String) -> bool:
if not DirAccess.dir_exists_absolute(stories_dir):
return false
var dir := DirAccess.open(stories_dir)
if dir == null:
return false
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = stories_dir + file_name
print("[StoryLoader] 发现剧本: " + full_path)
return _load_story_file(full_path)
file_name = dir.get_next()
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据
file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 应用 manifest 中的设置
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
_typewriter_speed = settings["typing_speed"].to_float()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 文件数量: " + str(file_system.size()))
return true
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
我仔细检查了代码，找到两个问题的根源。

## 问题1：Tab补全提示后不滚动到底

`_do_scroll` 在同一帧内调用时，`max_value` 还没更新。需要延迟一帧再滚动。

找到 `_do_scroll` 函数，**替换为**：

```gdscript
func _do_scroll() -> void:
	await get_tree().process_frame
	var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
	scroll_container.scroll_vertical = int(v_scroll.max_value)
```

但这会导致 `_do_scroll` 变成异步函数，打字机循环中频繁 `await` 可能太慢。所以改为两个函数：

找到 `_do_scroll` 函数，**替换为**：

```gdscript
func _do_scroll() -> void:
	_needs_scroll = true

func _process(_delta: float) -> void:
	if _needs_scroll:
		var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
		scroll_container.scroll_vertical = int(v_scroll.max_value)
		_needs_scroll = false
```

---

## 问题2：文档内多余空行

根本原因在 `_typewrite_text` 中。当打字机逐字输出遇到 `\n` 字符时，它正常输出这个换行。但问题出在你的测试数据的三引号字符串里——GDScript中 `"""` 紧跟换行后，第一个字符就是换行符本身。

虽然 `strip_edges()` 已经去掉了首尾空白，但真正的问题是 `_typewrite_text` 里**BBCode标签检测误判**。

看你的测试数据中有这样的内容：

```
[本文件需要O5级权限才能查阅完整内容]
[03:38] 控制室: Alpha小组，报告状态。
[警告: Dr. Bright的个人请求不应被认真对待]
```

这些 `[...]` 被打字机当成BBCode标签，导致整个 `[本文件需要O5级权限才能查阅完整内容]` 被当成标签一次性输出，而且可能引起RichTextLabel的解析错误产生额外换行。

找到 `_typewrite_text` 函数中检测BBCode标签的部分：

```gdscript
		# 检查是否是BBCode标签
		if text[i] == "[":
			var close_bracket: int = text.find("]", i)
			if close_bracket != -1:
				var tag: String = text.substr(i, close_bracket - i + 1)
```

**替换为**（从 `# 检查是否是BBCode标签` 开始，到 `# 普通字符` 之前）：

```gdscript
		# 检查是否是BBCode标签
		if text[i] == "[":
			var close_bracket: int = text.find("]", i)
			if close_bracket != -1:
				var tag: String = text.substr(i, close_bracket - i + 1)
				# 检查是否是自定义速度标签 [speed=0.05]
				if tag.begins_with("[speed="):
					var speed_str: String = tag.substr(7, tag.length() - 8)
					_current_char_speed = speed_str.to_float()
					i = close_bracket + 1
					continue
				elif tag == "[/speed]":
					_current_char_speed = _typewriter_speed
					i = close_bracket + 1
					continue
				elif tag.begins_with("[pause="):
					# 自定义暂停标签 [pause=0.5]
					var pause_str: String = tag.substr(7, tag.length() - 8)
					var pause_time: float = pause_str.to_float()
					await get_tree().create_timer(pause_time).timeout
					i = close_bracket + 1
					continue
				# 判断是否是合法的BBCode标签（以字母或/开头）
				var tag_inner: String = tag.substr(1, tag.length() - 2)
				if tag_inner.length() > 0 and (tag_inner[0] == "/" or tag_inner[0].unicode_at(0) >= 65 and tag_inner[0].unicode_at(0) <= 122):
					# 看起来像BBCode标签，整体添加
					output_text.append_text(tag)
					i = close_bracket + 1
					continue
				# 不是BBCode标签，转义方括号后逐字输出
				output_text.append_text("[lb]")
				i += 1
				continue
```

这样 `[03:38]`、`[本文件需要O5级权限]`、`[警告: ...]` 这类非BBCode的方括号内容就不会被误判了，而是用 `[lb]` 转义正确显示左方括号。

---

## 总结

| 修改 | 说明 |
|------|------|
| `_do_scroll` + `_process` | 用每帧检测替代即时滚动，确保滚动位置正确 |
| `_typewrite_text` 中BBCode检测 | 区分真正的BBCode标签和普通方括号文本，避免误判导致格式错乱 |

保存 `Ctrl+S`，`F5` 测试：

1. `open ` 按Tab → 提示应自动滚到底部
2. `open scp_173.txt` → 文档无多余空行
3. `open radio_log.txt` → `[03:38]` 等应正常显示，不会被吞掉

### USER
你还是没有解决文档打开后显示回自动空行的问题，如图：
欢迎接入SCP基金会安全终端系统。
  
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
  
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
  
- 基金会信息安全部门
  
在软件中会变成
  
欢迎接入SCP基金会安全终端系统。
  
  
本系统用于查阅基金会内部文件档案。
  
您的一切操作都将被记录和监控。
  
  
请遵守信息安全协议，不要尝试访问
  
超出您权限等级的文件。
  
  
- 基金会信息安全部门
然后，“输入任意命令返回终端”直接接在了“文件结束”那一行，需要修改。

### ASSISTANT
问题找到了。有两个原因：

**原因1：** 打字机逐字输出时，每个 `\n` 字符被 `output_text.append_text("\n")` 输出后，RichTextLabel 的 `append_text` 会额外产生一个段落间距。每次单独 `append_text` 一个换行就等于多一行。

**原因2：** 文件尾的 `\n` 和提示文字之间缺少换行。

## 修改1：修复文档空行问题

根本解决方案是不要逐字符输出换行，而是把换行和下一行的文字合并输出。

找到 `_typewrite_text` 函数中 `# 普通字符` 这一段（在BBCode检测之后）：

```gdscript
		# 普通字符
		var ch: String = text[i]
		output_text.append_text(ch)
		i += 1
```

**替换为：**

```gdscript
		# 普通字符
		var ch: String = text[i]
		# 换行符不单独append，而是收集连续的换行一次性输出
		if ch == "\n":
			var newlines: String = "\n"
			i += 1
			while i < length and text[i] == "\n":
				newlines += "\n"
				i += 1
			output_text.append_text(newlines)
			# 换行后的停顿
			if not _typewriter_instant:
				await get_tree().create_timer(_typewriter_period_pause).timeout
			_do_scroll()
			continue
		output_text.append_text(ch)
		i += 1
```

然后在同一个函数中，找到换行延迟的部分（在 `i += 1` 之后的延迟逻辑中）：

```gdscript
		# 根据字符类型决定延迟
		var delay: float = _current_char_speed
		# 标点符号额外停顿（制造顿挫感）
		if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
			delay += _typewriter_period_pause
		elif ch in ["、", "—", "-", "…"]:
			delay += _typewriter_comma_pause
		elif ch == "\n":
			delay += _typewriter_period_pause
		else:
```

**替换为：**

```gdscript
		# 根据字符类型决定延迟
		var delay: float = _current_char_speed
		# 标点符号额外停顿（制造顿挫感）
		if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
			delay += _typewriter_period_pause
		elif ch in ["、", "—", "-", "…"]:
			delay += _typewriter_comma_pause
		else:
```

（去掉了 `elif ch == "\n":` 分支，因为换行已经在前面单独处理了）

## 修改2：修复"文件结束"和"输入任意命令"连在一起

找到 `_cmd_open` 函数中的：

```gdscript
	# 文件尾放入队列，等内容打完后显示
	append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]", false)
	append_output("[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
```

**替换为：**

```gdscript
	# 文件尾放入队列，等内容打完后显示
	append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
```

---

## 总结

| 修改 | 说明 |
|------|------|
| `_typewrite_text` 换行处理 | 收集连续换行一次性输出，避免每个 `\n` 单独 `append_text` 导致双倍行距 |
| 去掉延迟中的 `\n` 分支 | 换行延迟已在前面处理 |
| `_cmd_open` 文件尾 | 合并为一次输出，确保换行正确 |

保存 `Ctrl+S`，`F5` 测试 `open welcome.txt`，应该不再有多余空行了。

### USER
如图，还是没有解决打开文档后多行的问题，我觉得是在每行开头多了一个换行符之类的问题。我给你全部代码，你仔细检查，然后返回给我需要修改的代码，不要全部发来不然会导致对话卡住。
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false
# 打字机效果
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
# 尝试加载剧本，如果失败则用测试数据
if not _try_load_story():
_init_test_file_system()
output_text.text = ""
output_text.bbcode_enabled = true
# 启用鼠标选择和交互（为超链接做准备）
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
input_field.focus_mode = Control.FOCUS_ALL
# 阻止Tab键切换焦点，让我们自己处理
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
# 不再用 text_submitted 信号，改为手动监听回车键
input_field.grab_focus()
_update_status_bar()
_show_welcome_message()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 鼠标滚轮滚动
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 点击任意位置聚焦输入框
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
# 点击任何键都确保输入框有焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果正在打字或加载，按空格或ESC跳过动画
if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
_typewriter_instant = true
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
# 如果正在打字，忽略回车（防止干扰）
if _is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
command_history.append(raw_input)
history_index = -1
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 命令回显用即时显示（不走打字机）
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
# 执行命令（命令输出走打字机效果）
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
# 重置打字机为动画模式
_typewriter_instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
_cmd_story_info()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("  [color=#66FF66]vdisc[/color]         查看当前载入的虚拟磁盘信息")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
if node.type == "folder":
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 先等待打字队列全部完成
while _is_typing:
await get_tree().process_frame
# 显示进度条（直接操作output_text，不走打字队列）
var content_size: int = node.content.length()
await _show_progress_bar(content_size)
# 进度条完成后等待一小会
await get_tree().create_timer(0.5).timeout
# 清屏进入阅读模式
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
# 显示文件头
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
# 显示文件内容（走打字机，不加额外空行）
# strip_edges去除三引号字符串首尾多余的换行
var clean_content: String = node.content.strip_edges()
append_output(clean_content, false)
# 文件尾放入队列，等内容打完后显示
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名:     [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]0[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]0[/color]")
lines.append("  已获取密码: [color=#66FF66]0[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 stories/ 目录后重启终端。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 虚拟磁盘信息 ═══════════[/color]")
if story_manifest.has("story"):
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签:   [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者: [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本:    [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述:    [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数:   [color=#66FF66]" + str(file_system.size()) + "[/color]")
lines.append("  磁盘来源:   [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态:   [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
# 只输入了一个词：补全命令
if parts.size() == 1:
# 检查是否已经是完整命令，后面有空格表示要补全参数
if current_text.ends_with(" "):
# 命令已输入完，补全文件名（无前缀匹配，列出所有）
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只补全文件夹，open/cat只补全文件
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
_do_scroll()
else:
# 补全命令名
var partial_cmd: String = parts[0].to_lower()
var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 两个词：命令 + 部分文件名
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只匹配文件夹，open/cat只匹配文件
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
# 找公共前缀，补全到最长公共部分
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 查找多个字符串的最长公共前缀
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
if not _is_typing:
_process_typewriter_queue()
func _process_typewriter_queue() -> void:
if _typewriter_queue.is_empty():
_is_typing = false
return
_is_typing = true
var entry = _typewriter_queue.pop_front()
var text: String = entry["text"]
var extra_newline: bool = entry["extra_newline"]
if _typewriter_instant:
output_text.append_text(text)
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
else:
_typewrite_text(text, extra_newline)
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
var i: int = 0
var length: int = text.length()
_current_char_speed = _typewriter_speed
while i < length:
# 如果中途切换为即时模式，把剩余文本一次性输出
if _typewriter_instant:
output_text.append_text(text.substr(i))
break
# 检查是否是BBCode标签
if text[i] == "[":
var close_bracket: int = text.find("]", i)
if close_bracket != -1:
var tag: String = text.substr(i, close_bracket - i + 1)
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 判断是否是合法的BBCode标签（以字母或/开头）
var tag_inner: String = tag.substr(1, tag.length() - 2)
if tag_inner.length() > 0 and (tag_inner[0] == "/" or tag_inner[0].unicode_at(0) >= 65 and tag_inner[0].unicode_at(0) <= 122):
# 看起来像BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 不是BBCode标签，转义方括号后逐字输出
output_text.append_text("[lb]")
i += 1
continue
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 普通BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 普通字符
var ch: String = text[i]
# 换行符不单独append，而是收集连续的换行一次性输出
if ch == "\n":
var newlines: String = "\n"
i += 1
while i < length and text[i] == "\n":
newlines += "\n"
i += 1
output_text.append_text(newlines)
# 换行后的停顿
if not _typewriter_instant:
await get_tree().create_timer(_typewriter_period_pause).timeout
_do_scroll()
continue
output_text.append_text(ch)
i += 1
# 根据字符类型决定延迟
var delay: float = _current_char_speed
# 标点符号额外停顿（制造顿挫感）
if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
delay += _typewriter_period_pause
elif ch in ["、", "—", "-", "…"]:
delay += _typewriter_comma_pause
else:
# 随机顿挫：有一定概率额外停顿
if randf() < _typewriter_pause_chance:
delay += _typewriter_pause_duration
await get_tree().create_timer(delay).timeout
# 每隔几个字符滚动一次
if i % 8 == 0:
_do_scroll()
# 当前文本打完
if extra_newline:
output_text.append_text("\n")
_do_scroll()
# 继续处理队列
_process_typewriter_queue()
func _do_scroll() -> void:
_needs_scroll = true
func _process(_delta: float) -> void:
if _needs_scroll:
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
scroll_container.scroll_vertical = int(v_scroll.max_value)
_needs_scroll = false
# 显示文件加载进度条
# file_size: 文件内容长度，影响进度条速度
# speed_override: 速度倍率覆盖，-1表示用默认
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
var bar_width: int = 30  # 进度条总长度（字符数）
var speed: float = _progress_bar_speed
if speed_override > 0.0:
speed = speed_override
# 文件越大，每格停顿越长（但有上下限）
var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
base_delay /= speed
# 起始行
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("[color=#66FF66]加载中 [[/color]")
for i in range(bar_width):
if _typewriter_instant:
# 跳过动画，直接填满
var remaining: int = bar_width - i
output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
break
output_text.append_text("[color=#33FF33]█[/color]")
_do_scroll()
# 随机波动让进度条不匀速，更真实
var jitter: float = randf_range(0.7, 1.5)
await get_tree().create_timer(base_delay * jitter).timeout
output_text.append_text("[color=#66FF66]] 完成[/color]\n")
_do_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
path_label.text = "[" + current_path + "]"
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
# 处理RichTextLabel中的超链接点击
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
# 如果是命令链接，直接执行
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
# 如果是文件链接，打开文件
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
# 计算框的宽度：取较长的那行，两侧各留3个空格
var max_len: int = max(title.length(), subtitle.length())
# 中英文混排时，中文字符占2个宽度，英文占1个
var title_display_len: int = _display_width(title)
var subtitle_display_len: int = _display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
# 居中填充
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func _display_width(text: String) -> int:
var width: int = 0
for ch in text:
var code: int = ch.unicode_at(0)
if code >= 0x4E00 and code <= 0x9FFF:
width += 2  # CJK统一汉字
elif code >= 0x3000 and code <= 0x303F:
width += 2  # CJK标点
elif code >= 0xFF00 and code <= 0xFFEF:
width += 2  # 全角字符
else:
width += 1
return width
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
return FSNode.new(entry.get("type", "file"), entry.get("content", ""))
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 测试文件系统初始化
# ============================================================
# 尝试从 stories 目录加载第一个 .scp 文件
func _try_load_story() -> bool:
# 优先从用户目录加载，再尝试资源目录
var search_dirs: Array[String] = [
OS.get_executable_path().get_base_dir() + "/stories/",
"res://stories/",
"user://stories/"
]
for stories_dir in search_dirs:
if _try_load_from_dir(stories_dir):
return true
print("[StoryLoader] 未找到剧本文件，使用测试数据")
return false
func _try_load_from_dir(stories_dir: String) -> bool:
if not DirAccess.dir_exists_absolute(stories_dir):
return false
var dir := DirAccess.open(stories_dir)
if dir == null:
return false
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = stories_dir + file_name
print("[StoryLoader] 发现剧本: " + full_path)
return _load_story_file(full_path)
file_name = dir.get_next()
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据
file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 应用 manifest 中的设置
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
_typewriter_speed = settings["typing_speed"].to_float()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 文件数量: " + str(file_system.size()))
return true
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
我终于看清楚问题了。你的scp文件实际加载后的内容里，每一行末尾都有 `\r\n`（Windows换行符）。`\r` 字符被RichTextLabel当作一个额外的换行处理，所以每行显示后都多了一个空行。

## 修改1：在 _cmd_open 中清理换行符

找到 `_cmd_open` 中的：

```gdscript
	# 显示文件内容（走打字机，不加额外空行）
	# strip_edges去除三引号字符串首尾多余的换行
	var clean_content: String = node.content.strip_edges()
	append_output(clean_content, false)
```

**替换为：**

```gdscript
	# 显示文件内容（走打字机，不加额外空行）
	# 清理内容：去除首尾空白，统一换行符为\n
	var clean_content: String = node.content.strip_edges()
	clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
	append_output(clean_content, false)
```

## 修改2：同时在文件加载入口也做清理（防止其他命令也受影响）

找到 `_get_node_at_path` 函数：

```gdscript
func _get_node_at_path(path: String) -> FSNode:
	path = _normalize_path(path)
	if path == "/":
		return FSNode.new("folder")
	if file_system.has(path):
		var entry: Dictionary = file_system[path]
		return FSNode.new(entry.get("type", "file"), entry.get("content", ""))
	return null
```

**替换为：**

```gdscript
func _get_node_at_path(path: String) -> FSNode:
	path = _normalize_path(path)
	if path == "/":
		return FSNode.new("folder")
	if file_system.has(path):
		var entry: Dictionary = file_system[path]
		var content: String = entry.get("content", "")
		# 统一换行符，防止\r\n导致双倍行距
		content = content.replace("\r\n", "\n").replace("\r", "\n")
		return FSNode.new(entry.get("type", "file"), content)
	return null
```

---

以上两处修改。保存 `Ctrl+S`，`F5` 测试 `open welcome.txt`，应该不再有多余空行了。

### USER
非常感谢，终于改好了。
我发现我导出exe时，只有SCRT-Reader.console.exe和SCRT-Reader.exe两个文件，没有文件夹结构。
我该如何正确导出并实现实时添加.scp压缩包呢？

### ASSISTANT
很好，现在来解决导出和运行时加载 `.scp` 文件的问题。

## 问题分析

Godot导出后，`res://` 路径下的文件都被打包进了exe内部，无法从外部修改。你需要让程序在exe**同级目录**下寻找 `stories/` 文件夹。

## 第一步：创建导出后的目录结构

导出exe后，手动在exe旁边创建文件夹：

```
SCRT-Reader.exe
SCRT-Reader.console.exe
stories/
    ├── my_story.scp
    └── another_story.scp
```

## 第二步：检查代码中的路径逻辑

你现在的 `_try_load_story` 已经有这段代码：

```gdscript
var search_dirs: Array[String] = [
    OS.get_executable_path().get_base_dir() + "/stories/",
    "res://stories/",
    "user://stories/"
]
```

第一个路径 `OS.get_executable_path().get_base_dir() + "/stories/"` 就是exe旁边的stories目录，这是正确的。

但问题是**在编辑器中运行时**，`OS.get_executable_path()` 返回的是Godot编辑器的路径，不是项目路径。需要加一个判断。

找到 `_try_load_story` 函数，**替换为：**

```gdscript
func _try_load_story() -> bool:
	var search_dirs: Array[String] = []
	
	# 导出后：exe同级目录下的stories/
	var exe_dir: String = OS.get_executable_path().get_base_dir()
	search_dirs.append(exe_dir + "/stories/")
	
	# 编辑器中运行时：项目根目录下的stories/
	if OS.has_feature("editor"):
		search_dirs.append(ProjectSettings.globalize_path("res://") + "stories/")
	
	# 用户数据目录（备用）
	search_dirs.append(OS.get_user_data_dir() + "/stories/")
	
	for stories_dir in search_dirs:
		print("[StoryLoader] 搜索目录: " + stories_dir)
		if _try_load_from_dir(stories_dir):
			return true
	
	print("[StoryLoader] 未找到剧本文件，使用测试数据")
	return false
```

## 第三步：导出设置

1. 打开 **项目 → 导出**
2. 选择你的 Windows Desktop 导出预设
3. 在 **资源** 选项卡中，确认导出模式是 "导出所有资源" 或包含了你需要的资源
4. **不需要**把 `stories/` 目录导出进exe包内（因为我们从外部读取）
5. 点击 **导出项目**，选择输出路径

## 第四步：创建一个自动创建stories目录的逻辑

为了用户体验更好，在程序启动时自动创建 `stories/` 目录。

找到 `_ready` 函数开头的：

```gdscript
func _ready() -> void:
	# 尝试加载剧本，如果失败则用测试数据
	if not _try_load_story():
		_init_test_file_system()
```

**替换为：**

```gdscript
func _ready() -> void:
	# 确保stories目录存在
	_ensure_stories_dir()
	# 尝试加载剧本，如果失败则用测试数据
	if not _try_load_story():
		_init_test_file_system()
```

然后在 `_try_load_story` 函数**前面**添加一个新函数：

```gdscript
func _ensure_stories_dir() -> void:
	var stories_path: String
	if OS.has_feature("editor"):
		stories_path = ProjectSettings.globalize_path("res://") + "stories/"
	else:
		stories_path = OS.get_executable_path().get_base_dir() + "/stories/"
	
	if not DirAccess.dir_exists_absolute(stories_path):
		var err := DirAccess.make_dir_absolute(stories_path)
		if err == OK:
			print("[StoryLoader] 已创建stories目录: " + stories_path)
		else:
			print("[StoryLoader] 创建stories目录失败: " + str(err))
	else:
		print("[StoryLoader] stories目录已存在: " + stories_path)
```

## 总结：使用方法

1. 在Godot中导出exe
2. 运行exe后，它会自动在同目录下创建 `stories/` 文件夹
3. 把 `.scp` 文件放入 `stories/` 文件夹
4. 重新运行exe，自动加载剧本

| 文件 | 说明 |
|------|------|
| `SCRT-Reader.exe` | 主程序（双击运行） |
| `SCRT-Reader.console.exe` | 带控制台的版本（调试用） |
| `stories/` | 放 `.scp` 剧本文件的目录 |

### USER
导出选项有什么其它需要注意的吗？

### ASSISTANT
## 导出设置详细说明

### 1. 创建导出预设

**项目 → 导出 → 添加**，选择 **Windows Desktop**

### 2. 基本设置

| 选项 | 建议值 | 说明 |
|------|--------|------|
| 导出路径 | 选一个干净的空文件夹 | 比如 `D:/Build/SCRT-Reader/` |
| 导出为Debug | **取消勾选** | 发布时用Release版 |

### 3. 应用程序选项卡

| 选项 | 建议值 | 说明 |
|------|--------|------|
| 图标 | 可选，放一个 `.ico` 文件 | 给exe加个图标 |
| 控制台包装器 | **关闭** | 不需要console.exe，除非调试 |
| 产品名称 | `SCRT-Reader` | 显示在任务管理器中 |

关闭控制台包装器的位置：找到 **Windows → Debug → 控制台包装器**，设为 **关闭**，这样就不会生成 `.console.exe` 了。

### 4. 资源选项卡

| 选项 | 建议值 | 说明 |
|------|--------|------|
| 导出模式 | **导出所有资源** | 确保字体、场景等都包含 |
| 排除过滤器 | `stories/*` | stories目录不打包进exe |

在 **"不导出的过滤器"** 中添加：

```
stories/*
```

这样 `res://stories/` 下的测试文件不会被打包进去（反正我们从外部读取）。

### 5. 加密选项卡

暂时不需要动，保持默认即可。

### 6. 导出步骤

1. 点击 **导出项目**
2. 选择路径，文件名设为 `SCRT-Reader.exe`
3. **取消勾选** "导出为Debug"
4. 点击保存

### 7. 导出后的最终目录结构

```
D:/Build/SCRT-Reader/
├── SCRT-Reader.exe          ← 主程序
├── SCRT-Reader.pck          ← 资源包（自动生成）
└── stories/                  ← 首次运行自动创建，或手动创建
    └── test_story.scp        ← 用户放入的剧本
```

### 8. 常见问题

**Q: 导出时提示缺少导出模板？**

去 **编辑器 → 管理导出模板 → 下载安装** 对应版本的模板。

**Q: exe运行后闪退？**

用 `.console.exe` 版本运行看报错信息，或者临时把控制台包装器打开重新导出。

**Q: 字体不显示/乱码？**

确保你的自定义字体文件（`.ttf`）在 `res://` 下且没有被排除过滤器排掉。

**Q: 想把pck合并进exe？**

在导出选项中勾选 **"嵌入PCK"**，这样只生成一个exe文件，更简洁：

```
D:/Build/SCRT-Reader/
├── SCRT-Reader.exe          ← 主程序+资源一体
└── stories/
    └── test_story.scp
```

### 9. 推荐的最终发布包

如果要分发给别人，打成zip：

```
SCRT-Reader_v0.1.zip
├── SCRT-Reader.exe
├── stories/
│   └── (这里放入.scp文件)
└── README.txt               ← 写个简单说明
```

### USER
目前不支持.scp包热加载，能否设置一个扫描命令或者重启命令？

### ASSISTANT
好的，添加两个命令：`scan` 重新扫描stories目录，`reboot` 重启终端。

## 修改1：在 `_execute_command` 的 match 中添加新命令

找到：

```gdscript
		"vdisc", "disc", "disk":
			_cmd_story_info()
		_:
```

**替换为：**

```gdscript
		"vdisc", "disc", "disk":
			_cmd_story_info()
		"scan":
			await _cmd_scan()
		"reboot", "restart":
			await _cmd_reboot()
		_:
```

## 修改2：在 `_cmd_help` 中添加帮助信息

找到：

```gdscript
	lines.append("  [color=#66FF66]vdisc[/color]         查看当前载入的虚拟磁盘信息")
```

在它**后面**添加：

```gdscript
	lines.append("  [color=#66FF66]scan[/color]          重新扫描stories目录并加载剧本")
	lines.append("  [color=#66FF66]reboot[/color]        重启终端")
```

## 修改3：在 `_cmd_story_info` 函数后面添加两个新函数

```gdscript
func _cmd_scan() -> void:
	append_output("[color=#AAAAAA]正在扫描stories目录...[/color]", false)
	
	# 等待打字完成
	while _is_typing:
		await get_tree().process_frame
	
	# 显示扫描进度条
	await _show_progress_bar(500)
	await get_tree().create_timer(0.3).timeout
	
	# 保存旧状态用于对比
	var old_story_path: String = current_story_path
	var old_manifest: Dictionary = story_manifest.duplicate()
	
	# 重置文件系统
	file_system.clear()
	story_manifest.clear()
	current_story_path = ""
	
	# 重新扫描
	if _try_load_story():
		var title: String = "未知"
		if story_manifest.has("story") and story_manifest["story"].has("title"):
			title = story_manifest["story"]["title"]
		
		if current_story_path == old_story_path:
			append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]", false)
		else:
			append_output("[color=#33FF33][OK] 发现并加载新剧本: " + title + "[/color]", false)
		
		append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "[/color]", false)
		
		# 重置到起始路径
		if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
			current_path = story_manifest["settings"]["start_path"]
		else:
			current_path = "/"
		_update_status_bar()
		append_output("[color=#AAAAAA]当前路径已重置为: " + current_path + "[/color]\n", false)
	else:
		_init_test_file_system()
		current_path = "/"
		_update_status_bar()
		append_output("[color=#FFB000][WARN] 未找到剧本文件，已加载内置测试数据。[/color]", false)
		append_output("[color=#AAAAAA]请将 .scp 文件放入 stories/ 目录后重新扫描。[/color]\n", false)

func _cmd_reboot() -> void:
	append_output("[color=#AAAAAA]正在重启终端...[/color]", false)
	
	# 等待打字完成
	while _is_typing:
		await get_tree().process_frame
	
	await get_tree().create_timer(0.5).timeout
	
	# 清空所有状态
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false
	command_history.clear()
	history_index = -1
	file_system.clear()
	story_manifest.clear()
	current_story_path = ""
	current_path = "/"
	has_new_mail = false
	
	# 重新加载
	_ensure_stories_dir()
	if not _try_load_story():
		_init_test_file_system()
	
	_update_status_bar()
	
	# 模拟重启效果
	output_text.append_text("[color=#AAAAAA]...[/color]\n")
	await get_tree().create_timer(0.3).timeout
	output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
	await get_tree().create_timer(0.5).timeout
	output_text.text = ""
	
	# 重新显示欢迎信息
	_show_welcome_message()
	input_field.grab_focus()
```

## 修改4：在自动补全的命令列表中添加新命令

找到 `_auto_complete` 中的：

```gdscript
			var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
				"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc"]
```

**替换为：**

```gdscript
			var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
				"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
				"scan", "reboot", "restart"]
```

---

## 使用方法

| 命令 | 效果 |
|------|------|
| `scan` | 不清屏，重新扫描stories目录，热加载新剧本 |
| `reboot` | 完全重启终端，清空历史，重新初始化 |

流程：
1. 运行程序 → 显示内置测试数据
2. 把 `.scp` 文件放入 `stories/` 目录
3. 输入 `scan` → 自动加载新剧本
4. 或输入 `reboot` → 完全重启

### USER
然后stories文件夹需要重命名为vdisc文件夹，请修改相关代码以确保正确运行

### ASSISTANT
需要把所有 `stories` 相关的路径和提示文字改为 `vdisc`。以下是所有需要修改的地方：

## 修改1：`_ensure_stories_dir` 函数

找到：

```gdscript
func _ensure_stories_dir() -> void:
	var stories_path: String
	if OS.has_feature("editor"):
		stories_path = ProjectSettings.globalize_path("res://") + "stories/"
	else:
		stories_path = OS.get_executable_path().get_base_dir() + "/stories/"
	
	if not DirAccess.dir_exists_absolute(stories_path):
		var err := DirAccess.make_dir_absolute(stories_path)
		if err == OK:
			print("[StoryLoader] 已创建stories目录: " + stories_path)
		else:
			print("[StoryLoader] 创建stories目录失败: " + str(err))
	else:
		print("[StoryLoader] stories目录已存在: " + stories_path)
```

**替换为：**

```gdscript
func _ensure_stories_dir() -> void:
	var vdisc_path: String
	if OS.has_feature("editor"):
		vdisc_path = ProjectSettings.globalize_path("res://") + "vdisc/"
	else:
		vdisc_path = OS.get_executable_path().get_base_dir() + "/vdisc/"
	
	if not DirAccess.dir_exists_absolute(vdisc_path):
		var err := DirAccess.make_dir_absolute(vdisc_path)
		if err == OK:
			print("[StoryLoader] 已创建vdisc目录: " + vdisc_path)
		else:
			print("[StoryLoader] 创建vdisc目录失败: " + str(err))
	else:
		print("[StoryLoader] vdisc目录已存在: " + vdisc_path)
```

## 修改2：`_try_load_story` 函数

找到：

```gdscript
func _try_load_story() -> bool:
	var search_dirs: Array[String] = []
	
	# 导出后：exe同级目录下的stories/
	var exe_dir: String = OS.get_executable_path().get_base_dir()
	search_dirs.append(exe_dir + "/stories/")
	
	# 编辑器中运行时：项目根目录下的stories/
	if OS.has_feature("editor"):
		search_dirs.append(ProjectSettings.globalize_path("res://") + "stories/")
	
	# 用户数据目录（备用）
	search_dirs.append(OS.get_user_data_dir() + "/stories/")
	
	for stories_dir in search_dirs:
		print("[StoryLoader] 搜索目录: " + stories_dir)
		if _try_load_from_dir(stories_dir):
			return true
	
	print("[StoryLoader] 未找到剧本文件，使用测试数据")
	return false
```

**替换为：**

```gdscript
func _try_load_story() -> bool:
	var search_dirs: Array[String] = []
	
	# 导出后：exe同级目录下的vdisc/
	var exe_dir: String = OS.get_executable_path().get_base_dir()
	search_dirs.append(exe_dir + "/vdisc/")
	
	# 编辑器中运行时：项目根目录下的vdisc/
	if OS.has_feature("editor"):
		search_dirs.append(ProjectSettings.globalize_path("res://") + "vdisc/")
	
	# 用户数据目录（备用）
	search_dirs.append(OS.get_user_data_dir() + "/vdisc/")
	
	for vdisc_dir in search_dirs:
		print("[StoryLoader] 搜索目录: " + vdisc_dir)
		if _try_load_from_dir(vdisc_dir):
			return true
	
	print("[StoryLoader] 未找到剧本文件，使用测试数据")
	return false
```

## 修改3：`_cmd_story_info` 中的提示文字

找到：

```gdscript
		append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 stories/ 目录后重启终端。[/color]\n", false)
```

**替换为：**

```gdscript
		append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后重启终端。[/color]\n", false)
```

## 修改4：`_cmd_scan` 中的提示文字

找到：

```gdscript
	append_output("[color=#AAAAAA]正在扫描stories目录...[/color]", false)
```

**替换为：**

```gdscript
	append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)
```

找到：

```gdscript
		append_output("[color=#AAAAAA]请将 .scp 文件放入 stories/ 目录后重新扫描。[/color]\n", false)
```

**替换为：**

```gdscript
		append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
```

---

同时别忘了把项目中实际的文件夹也重命名：把 `res://stories/` 文件夹改名为 `res://vdisc/`。导出后目录结构变为：

```
SCRT-Reader.exe
SCRT-Reader.pck
vdisc/
    └── my_story.scp
```

### USER
在使用scan命令后，会出现这种文字排版错误，请修正

### ASSISTANT
问题很明显：scan命令的输出文字之间缺少换行符，全部挤在一行了。

找到 `_cmd_scan` 函数中成功加载后的输出部分：

```gdscript
		if current_story_path == old_story_path:
			append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]", false)
		else:
			append_output("[color=#33FF33][OK] 发现并加载新剧本: " + title + "[/color]", false)
		
		append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "[/color]", false)
		
		# 重置到起始路径
		if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
			current_path = story_manifest["settings"]["start_path"]
		else:
			current_path = "/"
		_update_status_bar()
		append_output("[color=#AAAAAA]当前路径已重置为: " + current_path + "[/color]\n", false)
```

**替换为：**

```gdscript
		if current_story_path == old_story_path:
			append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]\n", false)
		else:
			append_output("[color=#33FF33][OK] 发现并加载新剧本: " + title + "[/color]\n", false)
		
		append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "[/color]\n", false)
		
		# 重置到起始路径
		if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
			current_path = story_manifest["settings"]["start_path"]
		else:
			current_path = "/"
		_update_status_bar()
		append_output("[color=#AAAAAA]当前路径已重置为: " + current_path + "[/color]\n", false)
```

每行末尾的 `[/color]"` 后面都加了 `\n`，这样每条信息各占一行。

### USER
目前没有问题了，准备进行下一步编程，请列出一个简要的工作流程，然后开始工作。

### ASSISTANT
好的，让我先梳理一下当前已完成的功能和接下来要做的事。

## 当前已完成

- ✅ 终端界面（输入/输出/状态栏）
- ✅ 基本命令（help, ls, cd, open, back, clear, status, mail, whoami, exit）
- ✅ 虚拟文件系统
- ✅ 打字机效果（含速度控制、暂停标签）
- ✅ 文件加载进度条
- ✅ .scp 剧本包加载（StoryLoader）
- ✅ Tab自动补全 + 命令历史
- ✅ scan/reboot 命令
- ✅ 导出支持（vdisc目录外部加载）

## 下一步工作流程

| 阶段 | 内容 | 说明 |
|------|------|------|
| **1** | **权限系统** | 文件/目录设置权限等级，用户需要密码解锁才能访问 |
| **2** | **密码/解锁机制** | 文档中隐藏密码线索，`unlock` 命令输入密码提升权限 |
| **3** | **邮件系统** | 根据进度触发邮件，`mail` 命令查看/阅读邮件 |
| **4** | **事件触发系统** | 打开特定文件后触发事件（新邮件、新文件出现、文字异常等） |
| **5** | **阅读进度追踪** | 记录已读文件，`status` 显示真实进度 |
| **6** | **存档系统** | 自动保存/加载玩家进度 |
| **7** | **视觉效果增强** | 屏幕闪烁、故障效果、文字扭曲等恐怖氛围 |

---

先从 **阶段1：权限系统** 开始，这是剧情推进的核心机制。

## 阶段1：权限系统设计

**思路：**
- 用户有一个权限等级（0-5）
- 文件/目录可以设置所需权限等级
- 权限不够时提示"权限不足"
- manifest.json 中定义权限

**manifest.json 扩展示例：**

```json
{
  "story": { "title": "...", "author": "..." },
  "settings": {
    "start_path": "/",
    "start_clearance": 0
  },
  "permissions": {
    "/reports/scp_001.txt": 5,
    "/reports/classified/": 3,
    "/personnel/": 1
  }
}
```

需要确认：你对这个权限系统的方向满意吗？或者你有其他优先想做的功能？确认后我立刻开始编写代码。

### USER
需要补充一点设定：特定.scp包内的权限仅在这个包内通用，不同包内的权限不一样，不然的话触发器赋予的权限在其它包内也能用就会导致文字冒险“开挂”了，你想想应该怎么优化，然后咱们进入工作。

### ASSISTANT
很好的考虑！设计思路如下：

## 权限隔离方案

每个 `.scp` 包有独立的权限存档，用**剧本ID**作为隔离标识：

```
存档结构:
user://saves/
├── story_abc123.json    ← 剧本A的进度（权限等级2，已读文件等）
├── story_def456.json    ← 剧本B的进度（权限等级0，全新）
└── story_ghi789.json    ← 剧本C的进度
```

**关键设计：**
- manifest.json 中每个剧本有唯一 `id` 字段
- 加载剧本时，根据 `id` 读取对应存档
- 切换剧本时，当前权限自动归零，加载新剧本的存档
- `scan` 换包后权限不会串包

**manifest.json 扩展：**

```json
{
  "story": {
    "id": "scp_site19_incident",
    "title": "SCP-Site19 事故调查",
    "author": "作者"
  },
  "settings": {
    "start_path": "/",
    "start_clearance": 0
  },
  "permissions": {
    "/classified/": 3,
    "/reports/scp_001.txt": 5
  }
}
```

确认这个方向没问题，开始编码。

---

## 修改1：添加权限相关变量

找到状态变量区域的：

```gdscript
var current_story_path: String = ""
```

在它**后面**添加：

```gdscript
# 权限系统
var player_clearance: int = 0              # 当前权限等级
var story_permissions: Dictionary = {}      # 路径 -> 所需权限等级
var story_id: String = ""                   # 当前剧本唯一ID
var read_files: Array[String] = []          # 已读文件列表
var unlocked_passwords: Array[String] = []  # 已解锁的密码
```

## 修改2：加载剧本时初始化权限

找到 `_load_story_file` 函数，**整个替换为：**

```gdscript
func _load_story_file(path: String) -> bool:
	story_loader = StoryLoader.new()
	if not story_loader.load_story(path):
		print("[StoryLoader] 加载失败: " + story_loader.error_message)
		return false
	
	# 应用加载的数据
	file_system = story_loader.file_system
	story_manifest = story_loader.manifest
	current_story_path = path
	
	# 读取剧本ID
	if story_manifest.has("story") and story_manifest["story"].has("id"):
		story_id = story_manifest["story"]["id"]
	else:
		# 没有id就用文件名的哈希作为id
		story_id = str(path.get_file().hash())
	
	# 读取权限表
	story_permissions.clear()
	if story_manifest.has("permissions"):
		var perms: Dictionary = story_manifest["permissions"]
		for perm_path in perms.keys():
			story_permissions[perm_path] = int(perms[perm_path])
	
	# 应用 manifest 中的设置
	var start_clearance: int = 0
	if story_manifest.has("settings"):
		var settings: Dictionary = story_manifest["settings"]
		if settings.has("start_path"):
			current_path = settings["start_path"]
		if settings.has("typing_speed"):
			_typewriter_speed = settings["typing_speed"].to_float()
		if settings.has("start_clearance"):
			start_clearance = int(settings["start_clearance"])
	
	# 尝试加载该剧本的存档
	if not _load_save():
		# 没有存档，用初始权限
		player_clearance = start_clearance
		read_files.clear()
		unlocked_passwords.clear()
	
	var title: String = "未知剧本"
	if story_manifest.has("story") and story_manifest["story"].has("title"):
		title = story_manifest["story"]["title"]
	
	print("[StoryLoader] 成功加载: " + title)
	print("[StoryLoader] 剧本ID: " + story_id)
	print("[StoryLoader] 文件数量: " + str(file_system.size()))
	print("[StoryLoader] 权限等级: " + str(player_clearance))
	return true
```

## 修改3：添加权限检查函数

在 `_get_node_at_path` 函数**前面**添加：

```gdscript
# 检查路径是否需要权限，返回所需等级（0表示无需权限）
func _get_required_clearance(path: String) -> int:
	path = _normalize_path(path)
	var highest: int = 0
	
	for perm_path in story_permissions.keys():
		var normalized_perm: String = _normalize_path(perm_path)
		# 精确匹配文件
		if path == normalized_perm:
			highest = max(highest, int(story_permissions[perm_path]))
		# 目录匹配（目录权限影响其下所有内容）
		elif normalized_perm.ends_with("/") or story_permissions.has(perm_path):
			var dir_prefix: String = normalized_perm.rstrip("/") + "/"
			if path.begins_with(dir_prefix) or path == normalized_perm.rstrip("/"):
				highest = max(highest, int(story_permissions[perm_path]))
	
	return highest

# 检查玩家是否有权限访问该路径
func _has_clearance(path: String) -> bool:
	return player_clearance >= _get_required_clearance(path)
```

## 修改4：在 `_cmd_open` 中添加权限检查

找到 `_cmd_open` 中的：

```gdscript
	if node.type != "file":
		append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
		return
```

在它**后面**、`# 先等待打字队列全部完成` **之前**添加：

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(file_path)
	if not _has_clearance(file_path):
		append_output("[color=#FF6666]╔══════════════════════════════════════╗[/color]", false)
		append_output("[color=#FF6666]║  [ACCESS DENIED] 权限不足           ║[/color]", false)
		append_output("[color=#FF6666]║  需要等级: " + str(required) + "  当前等级: " + str(player_clearance) + "             ║[/color]", false)
		append_output("[color=#FF6666]╚══════════════════════════════════════╝[/color]\n", false)
		return
```

## 修改5：在 `_cmd_cd` 中添加权限检查

找到 `_cmd_cd` 中的：

```gdscript
	if node.type != "folder":
		append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
		return
```

在它**后面**、`current_path = new_path` **之前**添加：

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(new_path)
	if not _has_clearance(new_path):
		append_output("[color=#FF6666][ACCESS DENIED] 权限不足 - 需要等级: " + str(required) + "  当前: " + str(player_clearance) + "[/color]\n", false)
		return
```

## 修改6：在 `_cmd_ls` 中标记权限锁定的文件

找到 `_cmd_ls` 中的：

```gdscript
		if node.type == "folder":
			lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
		else:
			lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
```

**替换为：**

```gdscript
		var item_required: int = _get_required_clearance(item_path)
		var is_locked: bool = not _has_clearance(item_path)
		
		if node.type == "folder":
			if is_locked:
				lines.append("  [color=#FF6666][DIR]  " + item + "/  🔒 等级" + str(item_required) + "[/color]")
			else:
				lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
		else:
			if is_locked:
				lines.append("  [color=#FF6666][FILE] " + item + "  🔒 等级" + str(item_required) + "[/color]")
			else:
				lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
```

## 修改7：添加 `unlock` 命令

找到 `_execute_command` 中的：

```gdscript
		"scan":
			await _cmd_scan()
```

在它**前面**添加：

```gdscript
		"unlock":
			_cmd_unlock(args)
```

在 `_cmd_scan` 函数**前面**添加：

```gdscript
func _cmd_unlock(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FFB000]用法: unlock <密码>[/color]\n", false)
		append_output("[color=#AAAAAA]在文件中寻找密码线索来提升权限等级。[/color]\n", false)
		return
	
	var password: String = args[0]
	
	# 从manifest中查找密码
	if not story_manifest.has("passwords"):
		append_output("[color=#FF6666][ERROR] 密码验证失败。[/color]\n", false)
		return
	
	var passwords: Dictionary = story_manifest["passwords"]
	
	if passwords.has(password):
		var pwd_info: Dictionary = passwords[password]
		var grant_level: int = int(pwd_info.get("grants_clearance", 0))
		
		if unlocked_passwords.has(password):
			append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(player_clearance) + "[/color]\n", false)
			return
		
		if grant_level <= player_clearance:
			append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。[/color]\n", false)
			return
		
		# 解锁成功
		unlocked_passwords.append(password)
		player_clearance = grant_level
		_auto_save()
		
		append_output("[color=#33FF33]╔══════════════════════════════════════╗[/color]", false)
		append_output("[color=#33FF33]║  [ACCESS GRANTED] 权限已提升        ║[/color]", false)
		append_output("[color=#33FF33]║  新权限等级: " + str(player_clearance) + "                        ║[/color]", false)
		append_output("[color=#33FF33]╚══════════════════════════════════════╝[/color]\n", false)
		
		# 显示提示信息（如果有）
		if pwd_info.has("message"):
			append_output("[color=#AAAAAA]" + pwd_info["message"] + "[/color]\n", false)
	else:
		append_output("[color=#FF6666][ERROR] 密码验证失败。[/color]\n", false)
```

## 修改8：添加存档/读档函数

在 `_ensure_stories_dir` 函数**前面**添加：

```gdscript
func _get_save_path() -> String:
	return "user://saves/save_" + story_id + ".json"

func _auto_save() -> void:
	if story_id.is_empty():
		return
	
	# 确保存档目录存在
	var save_dir: String = "user://saves/"
	if not DirAccess.dir_exists_absolute(save_dir):
		DirAccess.make_dir_absolute(save_dir)
	
	var save_data: Dictionary = {
		"story_id": story_id,
		"player_clearance": player_clearance,
		"read_files": read_files,
		"unlocked_passwords": unlocked_passwords,
		"current_path": current_path
	}
	
	var file := FileAccess.open(_get_save_path(), FileAccess.WRITE)
	if file:
		file.store_string(JSON.stringify(save_data, "\t"))
		file.close()
		print("[Save] 已保存: " + _get_save_path())

func _load_save() -> bool:
	var path: String = _get_save_path()
	if not FileAccess.file_exists(path):
		return false
	
	var file := FileAccess.open(path, FileAccess.READ)
	if file == null:
		return false
	
	var json_text: String = file.get_as_text()
	file.close()
	
	var json := JSON.new()
	if json.parse(json_text) != OK:
		return false
	
	var data: Dictionary = json.data
	if data.get("story_id", "") != story_id:
		return false
	
	player_clearance = int(data.get("player_clearance", 0))
	
	read_files.clear()
	if data.has("read_files"):
		for f in data["read_files"]:
			read_files.append(str(f))
	
	unlocked_passwords.clear()
	if data.has("unlocked_passwords"):
		for p in data["unlocked_passwords"]:
			unlocked_passwords.append(str(p))
	
	if data.has("current_path"):
		current_path = data["current_path"]
	
	print("[Save] 已加载存档: " + path)
	print("[Save] 权限等级: " + str(player_clearance))
	return true
```

## 修改9：打开文件后记录已读并自动存档

找到 `_cmd_open` 中的：

```gdscript
	# 显示文件内容（走打字机，不加额外空行）
```

在它**前面**添加：

```gdscript
	# 记录已读
	if not read_files.has(file_path):
		read_files.append(file_path)
		_auto_save()
```

## 修改10：更新 `_cmd_status` 显示真实数据

找到 `_cmd_status` 函数，**整个替换为：**

```gdscript
func _cmd_status() -> void:
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
	lines.append("  用户名:     [color=#66FF66]未登录[/color]")
	lines.append("  权限等级:   [color=#FFB000]" + str(player_clearance) + "[/color]")
	lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
	lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
	lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
	if not story_id.is_empty():
		lines.append("  剧本ID:    [color=#AAAAAA]" + story_id + "[/color]")
	lines.append("[color=#66FF66]════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)
```

## 修改11：在 help 和自动补全中添加 unlock

在 `_cmd_help` 中找到：

```gdscript
	lines.append("  [color=#66FF66]scan[/color]          重新扫描vdisc目录并加载剧本")
```

在它**前面**添加：

```gdscript
	lines.append("  [color=#66FF66]unlock <密码>[/color] 输入密码提升权限等级")
```

在 `_auto_complete` 的命令列表中找到：

```gdscript
				"scan", "reboot", "restart"]
```

**替换为：**

```gdscript
				"scan", "reboot", "restart", "unlock"]
```

## 修改12：scan 命令重置权限为新剧本的存档

找到 `_cmd_scan` 中的：

```gdscript
	# 重置文件系统
	file_system.clear()
	story_manifest.clear()
	current_story_path = ""
```

**替换为：**

```gdscript
	# 重置文件系统和权限
	file_system.clear()
	story_manifest.clear()
	story_permissions.clear()
	current_story_path = ""
	story_id = ""
	player_clearance = 0
	read_files.clear()
	unlocked_passwords.clear()
```

---

## manifest.json 密码配置示例

剧本制作者在 `manifest.json` 中这样定义密码：

```json
{
  "story": {
    "id": "scp_site19_incident",
    "title": "SCP-Site19 事故调查"
  },
  "settings": {
    "start_path": "/",
    "start_clearance": 0
  },
  "permissions": {
    "/classified/": 3,
    "/reports/scp_001.txt": 5,
    "/personnel/": 1
  },
  "passwords": {
    "alpha7": {
      "grants_clearance": 1,
      "message": "一级权限已解锁，可以访问人员档案了。"
    },
    "omega9": {
      "grants_clearance": 3,
      "message": "三级权限已解锁，机密目录已开放。"
    }
  }
}
```

保存所有修改，`Ctrl+S`，`F5` 测试。

### USER
根据我的test_story包结构制作一个有密码配置的示例manifest.json，方便我测试

### ASSISTANT
根据你之前的测试文件系统结构，这是完整的 `manifest.json`：

```json
{
	"story": {
		"id": "scp_site19_incident",
		"title": "SCP-Site19 事故调查",
		"author": "测试作者",
		"version": "1.0",
		"description": "Site-19发生了一起神秘事故，你需要逐步获取权限来揭开真相。"
	},
	"settings": {
		"start_path": "/",
		"start_clearance": 0
	},
	"permissions": {
		"/personnel/": 1,
		"/comms/": 2,
		"/reports/scp_001.txt": 5,
		"/reports/incident_log.txt": 2
	},
	"passwords": {
		"bright963": {
			"grants_clearance": 1,
			"message": "一级权限已解锁。人员档案目录已开放访问。"
		},
		"alpha0117": {
			"grants_clearance": 2,
			"message": "二级权限已解锁。通讯记录与事故日志已开放访问。"
		},
		"euclid173": {
			"grants_clearance": 3,
			"message": "三级权限已解锁。更多机密文件已开放。"
		},
		"overseer": {
			"grants_clearance": 5,
			"message": "O5级权限已解锁。所有文件已开放访问。\n愿你做好准备面对真相。"
		}
	}
}
```

## 测试流程

| 步骤 | 操作 | 预期结果 |
|------|------|----------|
| 1 | `ls` | 看到 personnel/ 和 comms/ 带🔒标记 |
| 2 | `cd personnel` | 提示权限不足，需要等级1 |
| 3 | `open reports/scp_173.txt` | 正常打开（无权限限制） |
| 4 | `unlock bright963` | 权限提升到1 |
| 5 | `cd personnel` | 成功进入 |
| 6 | `open comms/radio_log.txt` | 权限不足，需要等级2 |
| 7 | `unlock alpha0117` | 权限提升到2 |
| 8 | `open reports/incident_log.txt` | 成功打开 |
| 9 | `open reports/scp_001.txt` | 权限不足，需要等级5 |
| 10 | `unlock overseer` | 权限提升到5，全部解锁 |

## 密码线索提示

你可以在对应文件内容中隐藏密码线索，比如：

- `welcome.txt` 中暗示：*"初始访问码参见Bright博士编号"* → `bright963`
- `scp_173.txt` 中暗示：*"Alpha小组事故编号0117"* → `alpha0117`
- `radio_log.txt` 中暗示：*"Euclid级，编号173"* → `euclid173`

把这个 `manifest.json` 放到你的 `.scp` 包根目录替换原来的，然后 `scan` 或 `reboot` 测试。

### USER
帮我重新制作一个测试用的.scp包，不用管之前的了，现在要较全面地体现各种功能。

### ASSISTANT
好的，我来制作一个完整的测试用 `.scp` 包。你需要创建以下文件结构，然后打包成zip并改后缀为 `.scp`。

## 文件结构

```
test_story/
├── manifest.json
├── welcome.txt
├── notice.txt
├── reports/
│   ├── scp_173.txt
│   ├── scp_682.txt
│   ├── incident_0117.txt
│   └── final_report.txt
├── personnel/
│   ├── dr_bright.txt
│   ├── dr_zhang.txt
│   └── agent_k.txt
├── comms/
│   ├── radio_log.txt
│   └── email_archive.txt
└── classified/
    ├── project_origin.txt
    └── overseer_memo.txt
```

## manifest.json

```json
{
	"story": {
		"id": "site19_incident_0117",
		"title": "Site-19 事故调查",
		"author": "SCRT测试",
		"version": "1.0",
		"description": "2024年1月17日，Site-19发生了一起不明事故。你被授权接入终端系统展开调查。"
	},
	"settings": {
		"start_path": "/",
		"start_clearance": 0
	},
	"permissions": {
		"/personnel/": 1,
		"/comms/": 2,
		"/reports/incident_0117.txt": 2,
		"/reports/scp_682.txt": 3,
		"/classified/": 4,
		"/classified/overseer_memo.txt": 5
	},
	"passwords": {
		"bright963": {
			"grants_clearance": 1,
			"message": "一级权限已解锁。人员档案目录已开放访问。"
		},
		"0117alpha": {
			"grants_clearance": 2,
			"message": "二级权限已解锁。通讯记录与事故日志已开放访问。"
		},
		"hard2kill": {
			"grants_clearance": 3,
			"message": "三级权限已解锁。高危项目档案已开放。"
		},
		"origin": {
			"grants_clearance": 4,
			"message": "四级权限已解锁。机密目录已开放访问。\n请注意：你即将接触到高度敏感信息。"
		},
		"wearethelight": {
			"grants_clearance": 5,
			"message": "O5级权限已解锁。\n欢迎，监督者。\n愿你做好了面对真相的准备。"
		}
	}
}
```

## welcome.txt

```
欢迎接入SCP基金会安全终端系统。

本终端已授权用于调查事故 #2024-0117。
请按照标准程序逐步获取访问权限。

可用命令请输入 help 查看。
当前开放的文件请使用 ls 命令查看。

提示: 在文件中寻找线索以获取更高权限。
密码一旦找到，使用 unlock <密码> 命令输入。

请注意：
Dr. Bright 的个人编号或许是个好的开始。
他的编号与某个SCP项目有关。

- 信息安全部自动系统
```

## notice.txt

```
[系统通知] 2024-01-18 06:00

致所有调查人员：

事故 #2024-0117 已被列为Euclid级安全事件。
以下是当前已知信息摘要：

1. 事故发生于 2024年1月17日 03:41
2. 地点: Site-19 B区走廊
3. 涉及人员: Alpha巡逻小组 (Agent K 负责)
4. 当前状态: B区已封锁，Alpha小组失联

所有调查人员需从公开档案开始工作。
一级权限密码已通过安全渠道分发。

如果你尚未获得密码，请仔细阅读欢迎信息。

注意: 事故编号 0117 与 Alpha 小组代号
组合后可能对你的调查有帮助。

- Site-19 临时指挥部
```

## reports/scp_173.txt

```
项目编号: SCP-173
项目等级: Euclid

特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
指派给SCP-173收容室的两名人员
在任何时候都必须与SCP-173保持直接眼神接触，
直到所有人员撤离并重新锁闭收容室的门。

描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。
当未被直接观察时，SCP-173能够以极快的速度移动，
并会折断目标的颈部或勒死目标。

补充记录 2024-01-17:
事故当晚，SCP-173收容室的监控显示一切正常。
然而B区走廊的目击报告提到了
"类似混凝土摩擦地面的声音"。
这份报告目前尚未得到证实。
建议提升调查权限后查阅事故日志。
```

## reports/scp_682.txt

```
项目编号: SCP-682
项目等级: Keter

[本文件需要三级权限]

特殊收容措施:
SCP-682必须被尽快消灭。
目前SCP-682被收容在一个5m x 5m x 5m的房间中，
房间内充满了盐酸，房间的酸度和任何其他变化
都必须在25秒内做出反应。

描述:
SCP-682是一个大型的、类似爬行动物的生物。
其来源不明。该生物对所有生命表现出极端的敌意。
SCP-682拥有极强的适应能力和再生能力。
至今没有任何手段能够永久消灭SCP-682。

机密备注:
事故 #2024-0117 发生时，SCP-682的
收容酸池产生了异常波动，持续约4.7秒。
这与B区停电的持续时间完全一致。

数据分析表明，某种未知频率的信号
同时影响了B区电力系统和SCP-682的收容设施。
信号来源指向 ████████

如果你正在调查此事件，
project_origin 也许能给你答案。
这个词本身就是进入机密区的钥匙。
```

## reports/incident_0117.txt

```
事故日志 #2024-0117
安全等级: 二级

日期: 2024年1月17日
时间: 03:38 - 03:47
地点: Site-19 B区走廊
涉及人员: Agent K (Alpha小组组长)

事故时间线:

03:38 - Alpha小组开始B区例行巡查
03:41 - B区照明系统突然失效
03:41 - Agent K报告异常声响
03:42 - Agent K发出最后通讯后失联
03:42 - B区所有监控画面中断
03:43 - 应急照明启动
03:44 - 快速反应小组集结
03:45 - 控制室宣布Alpha小组失联
03:47 - B区被完全封锁

现场勘察报告:
快速反应小组进入B区后发现:
1. 走廊地面有明显的拖拽痕迹
2. Agent K的通讯设备碎片散落在走廊中段
3. 墙壁上发现不明物质 (样本已送检)
4. 走廊尽头的安全门被从内部以极大力量变形

未找到Agent K或Alpha小组其他成员。

调查员备注:
地面的拖拽痕迹分析显示，
拖拽力量远超正常人类能力。
墙壁上的不明物质初步检验为
"高浓度角蛋白混合未知有机物"。

这种物质曾在某个项目的收容室中检测到。
该项目被称为 "hard to kill"。
请调查人员据此申请更高权限。
```

## reports/final_report.txt

```
最终调查报告 (公开部分)
编号: IR-2024-0117-FINAL
日期: 2024-01-25

调查结论摘要:

事故 #2024-0117 的调查已基本完成。
以下为可在当前权限下公开的结论:

1. B区停电并非设备故障，而是外部信号干扰导致
2. Alpha小组在停电期间遭遇了不明实体
3. Agent K目前仍处于失联状态
4. 不明实体的来源已基本确定

完整的调查结论和应对方案
已归档至机密目录 /classified/
查阅完整报告需要四级及以上权限。

如果你已经走到这一步，
你应该已经知道了那个词。
那个关于一切开始的词。

- 首席调查员 Dr. Zhang
```

## personnel/dr_bright.txt

```
人员档案: Dr. Jack Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
状态: 在职

个人编号: B-963
(注: 编号关联SCP-963，即Bright博士佩戴的项链)

专长:
- SCP项目交叉研究
- 异常心理学
- 收容方案设计

近期活动:
Dr. Bright在事故 #2024-0117 发生时
正在Site-17参加跨站点会议。
他已被紧急召回参与调查。

Dr. Bright的初步分析:
"B区的电磁波记录很有意思。
我在SCP-682的收容日志里见过类似的模式。
建议调查人员取得更高权限后
优先查阅682的相关记录。"

备注:
Dr. Bright的个人编号 (bright963)
已被分发给调查人员作为一级权限密码。
```

## personnel/dr_zhang.txt

```
人员档案: Dr. Zhang Wei
安全等级: 4级
职位: 首席调查员
当前站点: Site-19
状态: 在职

专长:
- 异常事件分析
- 模式识别
- 信息安全

当前任务:
事故 #2024-0117 首席调查员

调查日记 (摘录):

1月18日:
初步证据指向某种未知实体介入。
地面痕迹和墙壁物质的分析结果令人不安。

1月20日:
Dr. Bright提供了关键线索。
682收容池的波动与B区停电高度相关。
这不是巧合。

1月22日:
我找到了信号源。
它来自Site-19地下三层。
那里有一个项目......基金会建立之初就存在的项目。
他们称之为 "起源计划" (Project Origin)。

1月24日:
报告已经写完了。
如果你正在读这段文字，
说明你的权限已经足够深入。
去机密目录看看吧。
真相就在那里。
```

## personnel/agent_k.txt

```
人员档案: Agent K (全名保密)
安全等级: 2级
职位: 外勤特工 / Alpha小组组长
当前站点: Site-19
状态: 失联

最后已知位置: Site-19 B区走廊中段
最后联络时间: 2024-01-17 03:42

服役记录:
Agent K是一名经验丰富的外勤特工，
在Site-19服役超过5年。
作为Alpha小组组长，负责B区夜间巡逻。
服役期间零事故记录，直到 #2024-0117。

最后通讯记录摘要:
"控制室......这里的灯......不对......
这里有什么东西在......在移动......"

搜救行动:
截至目前，已组织3次搜救行动。
B区走廊中段至尽头区域已被反复搜索。
未发现Agent K或其遗骸。

异常发现:
第二次搜救行动中，
在B区尽头变形的安全门后方，
发现了Agent K的值勤徽章。
徽章上有烧灼痕迹，
且金属部分出现了异常的结晶化现象。

此结晶化现象与 /classified/ 中
Project Origin 的记录高度吻合。
```

## comms/radio_log.txt

```
无线电通讯记录 (完整版)
频道: SITE-19-SECURE-7
日期: 2024-01-17
记录员: 通讯官 Miller

[03:35] 控制室: 各巡逻小组，例行通讯检查。
[03:35] Bravo小组: Bravo正常，C区平静。
[03:36] Alpha小组: Alpha正常，即将进入B区。
[03:36] 控制室: Alpha收到。注意B-7区段的监控有轻微延迟，保持警惕。
[03:38] Agent K: 控制室，Alpha已到达B区入口。一切正常。
[03:38] 控制室: 收到Alpha。按计划巡查。
[03:39] Agent K: 开始例行巡查。B-1区段正常。
[03:40] Agent K: B-4区段正常。走廊比平时安静。
[03:40] 控制室: 收到。
[03:41] Agent K: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:41] Agent K: 灯在闪。B-6区段的灯在闪。等等......
[03:41] Agent K: 听到什么声音了。像是......像是什么东西在地上拖......
[03:42] Agent K: ......不对......这里有什么东西在......在移动......
[03:42] Agent K: 它不......天哪它的速度......
[03:42] [严重静电干扰，持续约3秒]
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:43] 控制室: Alpha小组，这是控制室，请立即回复!
[03:44] 控制室: 所有单位注意，Alpha小组失联。启动应急预案Sigma-7。
[03:44] Bravo小组: Bravo收到，是否需要前往B区?
[03:44] 控制室: 负面Bravo。保持位置。等待快速反应小组。
[03:45] 控制室: 快速反应小组已集结。B区全面封锁。
[03:47] 控制室: B区封锁确认完毕。进入事故处理流程。

[通讯记录结束]

通讯官备注:
03:42的静电干扰频率经分析后，
与SCP-682收容设施的电磁泄露特征高度相似。
这一发现已上报。
此通讯记录的完整技术分析见机密目录。
```

## comms/email_archive.txt

```
内部邮件存档
检索条件: 事故 #2024-0117 相关

========================================
发件人: Dr. Bright <bright@scp.foundation>
收件人: Dr. Zhang <zhang@scp.foundation>
日期: 2024-01-18 14:22
主题: 关于B区事故的初步判断

Zhang:

我看了你发来的现场报告。
墙壁上的物质样本分析结果我这边也拿到了。
角蛋白基质配合那种未知有机物......
这个组合我太熟悉了。

是682。或者至少和682有关。

但问题是，682在事故发生时
一直在收容池里——这一点有监控确认。
所以要么是682有了我们不知道的新能力，
要么是有什么东西在模仿682的生物特征。

不管是哪种情况，都够让人头疼的。

建议你重点查一下事故发生时
682收容池的波动数据。
我赌一包糖那不是巧合。

- Jack

P.S. 你的调查组权限够吗?
如果遇到墙，试试用事故编号加Alpha代号。
你懂我意思。

========================================
发件人: Dr. Zhang <zhang@scp.foundation>
收件人: Dr. Bright <bright@scp.foundation>
日期: 2024-01-20 09:15
主题: Re: 关于B区事故的初步判断

Jack:

你说得对。682收容池的波动数据
和B区停电的时间完全吻合。
精确到毫秒级。

但更让我不安的是，
我在数据库里搜索这种电磁模式时，
找到了一个古老的项目档案。
Project Origin。

这个项目从基金会成立之初就存在。
但相关文件都被锁在最高权限之下。
我只看到了项目名称和一段描述:

"起源不是开始，而是我们所恐惧之物的影子。"

我需要更高的权限。
如果你有O5级别的门路......

- Zhang

========================================
发件人: Dr. Bright <bright@scp.foundation>
收件人: Dr. Zhang <zhang@scp.foundation>
日期: 2024-01-20 10:03
主题: Re: Re: 关于B区事故的初步判断

记住这句话:

We are the light.

该知道的时候你会知道怎么用它。
别在不安全的频道上讨论了。

- Jack
```

## classified/project_origin.txt

```
绝密文件
项目代号: PROJECT ORIGIN
权限要求: 四级

文件编号: O-001
创建日期: 1924-██-██
最后修改: 2024-01-25

项目概述:

Project Origin 是基金会最早期的研究项目之一。
该项目旨在研究一种被称为"起源实体"的异常存在。

起源实体的特征:
1. 无固定物理形态
2. 能够模仿已收容SCP项目的特征和能力
3. 活动周期约为每25年一次
4. 活动时会释放特定频率的电磁脉冲
5. 电磁脉冲会干扰附近的电子设备和收容系统

历史记录:
- 1924年: 首次发现，基金会成立的原因之一
- 1949年: 第二次活动，Site-01遭受重大破坏
- 1974年: 第三次活动，三个SCP项目收容失效
- 1999年: 第四次活动，通过提前预警成功抑制
- 2024年: 第五次活动......

2024年活动分析:
起源实体在2024年1月17日再次活动。
此次它选择模仿了SCP-682的部分特征，
包括极强的物理力量和角蛋白基质分泌。

B区事故正是起源实体活动的直接结果。
Agent K是此次活动中已知的唯一受害者。

关键发现:
起源实体似乎并非在"攻击"。
对历次活动的分析表明，
它更像是在"寻找"某样东西。
每次活动的模式都暗示着一种......渴望。

完整的行为分析和预测模型
收录在O5监督者备忘录中。

这是你最后的机会回头。
继续深入需要O5级权限。
如果你已经读到了Bright博士的建议，
你应该知道最后的密码。

那句话，全部小写，没有空格。
```

## classified/overseer_memo.txt

```
O5监督者委员会备忘录
编号: O5-MEMO-2024-0117
权限等级: 五级 (最高)

致: 持有本备忘录阅读权限的人员

如果你正在阅读这份文件，
说明你已经走过了整条调查链。
从一个简单的欢迎信息开始，
穿过层层权限壁垒，来到了这里。

现在，你将了解全部真相。

关于起源实体:

起源实体不是一个"怪物"。
它是SCP基金会存在的根本原因。
1924年，几名科学家在████████发现了它，
并为了收容和研究它而建立了基金会。

但一百年过去了，我们逐渐明白了一件事:
起源实体无法被收容。
它是一种超越物理法则的存在。
每25年，它会穿透我们所有的防线活动一次。
而我们能做的，只是将损失降到最低。

关于Agent K:

Agent K没有死亡。
至少不是传统意义上的死亡。
起源实体每次活动都会"带走"一个人。
分析表明，被带走的人会成为
起源实体"理解"人类的媒介。

Agent K现在是起源实体的一部分。
或者说，起源实体正在通过Agent K
尝试理解什么是"人"。

关于未来:

下一次活动将在2049年。
届时，我们中的许多人已经不在了。
但基金会会继续存在。
这是我们的使命。

控制。收容。保护。

这不仅仅是口号。
这是我们面对无法理解之物时，
唯一能做的事。

致阅读者:
你的调查到此结束。
感谢你的付出。
请在终端中输入 status 查看你的最终调查状态。

此文件将在你关闭终端后自动加密。

- O5 监督者委员会

We are the light that holds back the darkness.
We are the foundation upon which humanity stands.

[文件结束]
```

---

## 打包方法

1. 创建一个文件夹，把以上所有文件按目录结构放好
2. 全选文件夹内的所有内容（不是选文件夹本身）
3. 右键 → 压缩为 `.zip`
4. 将 `.zip` 后缀改为 `.scp`
5. 放入 `vdisc/` 目录
6. 运行程序，输入 `scan`

## 测试路线

```
开始 → welcome.txt (获得密码线索 bright963)
  → unlock bright963 (等级1)
  → personnel/dr_bright.txt (线索指向682和0117alpha)
  → notice.txt (确认密码 0117alpha)
  → unlock 0117alpha (等级2)
  → comms/email_archive.txt (线索指向hard2kill和origin)
  → reports/incident_0117.txt (确认 hard to kill → hard2kill)
  → unlock hard2kill (等级3)
  → reports/scp_682.txt (确认 origin)
  → unlock origin (等级4)
  → classified/project_origin.txt (线索指向 wearethelight)
  → unlock wearethelight (等级5)
  → classified/overseer_memo.txt → 调查完成
```

### USER
存在问题：软件不识别manifest.json，还存在其它问题，我给你所有main.gd文件，你仔细检查一下再把需要修改的地方发给我。注意不要发全部代码不然会导致对话卡死。

### ASSISTANT
根据你提供的代码，我仔细检查了权限系统和manifest加载相关的逻辑。以下是我发现的问题和修复方案：

## 问题分析

`main.gd` 本身不直接读取 `manifest.json`，它依赖 `StoryLoader` 类来解析 `.scp` 包。问题很可能出在 `StoryLoader` 中——它可能没有解析 `permissions` 和 `passwords` 这两个新增的字段。[1]

此外，代码中的权限变量虽然已经声明了，但 `_load_story_file` 中需要确保正确读取这些字段。[1]

**请你把 `StoryLoader` 的完整代码（`story_loader.gd`）发给我**，我需要检查它是如何解析 `manifest.json` 的。

在此之前，以下是 `main.gd` 中我已经能确认需要修改的地方：

---

## 修改1：确保 `_load_story_file` 正确读取 permissions 和 passwords

找到 `_load_story_file` 函数中的：

```gdscript
	# 读取权限表
	story_permissions.clear()
	if story_manifest.has("permissions"):
		var perms: Dictionary = story_manifest["permissions"]
		for perm_path in perms.keys():
			story_permissions[perm_path] = int(perms[perm_path])
```

在这段后面添加调试输出，确认是否成功读取：

```gdscript
	# 读取权限表
	story_permissions.clear()
	if story_manifest.has("permissions"):
		var perms: Dictionary = story_manifest["permissions"]
		for perm_path in perms.keys():
			story_permissions[perm_path] = int(perms[perm_path])
		print("[StoryLoader] 权限表已加载，共 " + str(story_permissions.size()) + " 条规则")
	else:
		print("[StoryLoader] 警告: manifest中未找到permissions字段")
	
	# 验证passwords字段
	if story_manifest.has("passwords"):
		print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
	else:
		print("[StoryLoader] 警告: manifest中未找到passwords字段")
```

## 修改2：`_cmd_scan` 中重新加载后需要输出权限信息

找到 `_cmd_scan` 中成功加载后输出文件数量的那行：

```gdscript
		append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "[/color]\n", false)
```

在它**后面**添加：

```gdscript
		append_output("[color=#AAAAAA]权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
		append_output("[color=#AAAAAA]当前权限等级: " + str(player_clearance) + "[/color]\n", false)
```

## 修改3：`_cmd_reboot` 中需要重置权限变量

找到 `_cmd_reboot` 中的：

```gdscript
	# 清空所有状态
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false
	command_history.clear()
	history_index = -1
	file_system.clear()
	story_manifest.clear()
	current_story_path = ""
	current_path = "/"
	has_new_mail = false
```

**替换为：**

```gdscript
	# 清空所有状态
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false
	command_history.clear()
	history_index = -1
	file_system.clear()
	story_manifest.clear()
	story_permissions.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	has_new_mail = false
	player_clearance = 0
	read_files.clear()
	unlocked_passwords.clear()
```

---

## 下一步

**请把 `story_loader.gd` 的代码发给我**，这是关键——如果 `StoryLoader` 没有把 `manifest.json` 中的 `permissions` 和 `passwords` 字段传递给 `story_manifest`，那 `main.gd` 再怎么读都是空的。问题大概率出在那里。

### USER
story_loader.gd给你了，继续检查并把需要修改的地方发给我。注意不要发全部代码不然会导致对话卡死。

### ASSISTANT
从提供的 `story_loader.gd` 片段中 [2]，我只能看到很少的代码。我需要看到 `load_story` 函数的**完整实现**，特别是：

1. 它如何读取 ZIP 中的 `manifest.json`
2. 它如何解析 JSON 并赋值给 `manifest` 变量
3. 它如何构建 `file_system` 字典

目前只能看到函数开头 [2]：

```gdscript
func load_story(path: String) -> bool:
    file_system.clear()
    manifest.clear()
    error_message = ""
```

**请你把 `story_loader.gd` 的完整代码直接复制粘贴发给我**。这个文件应该不大，不会导致对话卡死。我需要看到：

- `load_story` 函数的完整内容
- 解析 `manifest.json` 的部分
- 构建 `file_system` 的部分

如果你担心太长，至少把 `load_story` 函数的完整代码发给我，这是定位问题的关键。

根据目前已知信息，**最可能的问题是**：`story_loader.gd` 在解析 `manifest.json` 时，可能只读取了 `story`、`settings` 这些旧字段，而没有把整个 JSON 内容完整传递给 `manifest` 字典。如果它是选择性解析的，那 `permissions` 和 `passwords` 字段就会丢失。

请发完整的 `story_loader.gd`，我来定位具体问题。

### USER
class_name StoryLoader
extends RefCounted
# 加载结果
var file_system: Dictionary = {}
var manifest: Dictionary = {}
var error_message: String = ""
# 从 .scp (ZIP) 文件加载剧本
func load_story(path: String) -> bool:
file_system.clear()
manifest.clear()
error_message = ""
# 打开ZIP文件
var reader := ZIPReader.new()
var err := reader.open(path)
if err != OK:
error_message = "无法打开文件: " + path
return false
# 获取ZIP内所有文件路径
var files := reader.get_files()
# 第一遍：收集所有文件夹路径
var folders: Dictionary = {}
folders["/"] = true
for file_path in files:
# 跳过空路径
if file_path.strip_edges().is_empty():
continue
# 标准化路径：确保以 / 开头
var clean_path: String = _clean_zip_path(file_path)
# 收集所有父级文件夹
var parts := clean_path.split("/", false)
var current := ""
for i in range(parts.size() - 1):
current += "/" + parts[i]
folders[current] = true
# 如果路径本身以 / 结尾，它是文件夹
if file_path.ends_with("/"):
folders[clean_path.rstrip("/")] = true
# 注册所有文件夹
for folder_path in folders.keys():
if folder_path == "/":
continue
file_system[folder_path] = {
"type": "folder"
}
# 第二遍：读取所有文件内容
for file_path in files:
if file_path.strip_edges().is_empty():
continue
if file_path.ends_with("/"):
continue
var clean_path: String = _clean_zip_path(file_path)
# 读取文件内容
var content_bytes := reader.read_file(file_path)
if content_bytes == null:
continue
var content: String = content_bytes.get_string_from_utf8()
# 检查是否是 manifest.cfg
var filename: String = clean_path.get_file()
if filename == "manifest.cfg":
_parse_manifest(content)
continue
# 注册为文件
file_system[clean_path] = {
"type": "file",
"content": content
}
reader.close()
return true
# 清理ZIP内部路径，统一为 /开头 的格式
func _clean_zip_path(zip_path: String) -> String:
# 去除开头的 ./
var path: String = zip_path
if path.begins_with("./"):
path = path.substr(2)
# 去除末尾的 /
path = path.rstrip("/")
# 确保以 / 开头
if not path.begins_with("/"):
path = "/" + path
return path
# 解析 manifest.cfg
func _parse_manifest(content: String) -> void:
var current_section: String = ""
for line in content.split("\n"):
line = line.strip_edges()
# 跳过空行和注释
if line.is_empty() or line.begins_with("#") or line.begins_with(";"):
continue
# 段落标记 [section]
if line.begins_with("[") and line.ends_with("]"):
current_section = line.substr(1, line.length() - 2)
if not manifest.has(current_section):
manifest[current_section] = {}
continue
# 键值对 key=value
var eq_pos: int = line.find("=")
if eq_pos > 0 and not current_section.is_empty():
var key: String = line.substr(0, eq_pos).strip_edges()
var value: String = line.substr(eq_pos + 1).strip_edges()
manifest[current_section][key] = value

### ASSISTANT
找到根本问题了！

## 问题根源

`StoryLoader` 有两个关键问题：

**问题1：** 它查找的是 `manifest.cfg`（INI格式），而不是 `manifest.json`（JSON格式）[2]。你的 `.scp` 包里放的是 `manifest.json`，但代码只认 `manifest.cfg`。

**问题2：** `_parse_manifest` 是一个简单的 INI 解析器（`[section]` + `key=value`），它无法处理 JSON 格式，更无法处理嵌套的 `permissions` 和 `passwords` 字典。

## 解决方案

需要修改 `story_loader.gd`，让它同时支持 `manifest.json` 和 `manifest.cfg`。

### 修改1：修改文件识别部分

在 `story_loader.gd` 中找到第二遍读取文件的循环里的：

```gdscript
		# 检查是否是 manifest.cfg
		var filename: String = clean_path.get_file()
		if filename == "manifest.cfg":
			_parse_manifest(content)
			continue
```

**替换为：**

```gdscript
		# 检查是否是 manifest 文件
		var filename: String = clean_path.get_file()
		if filename == "manifest.json":
			_parse_manifest_json(content)
			continue
		if filename == "manifest.cfg":
			_parse_manifest(content)
			continue
```

### 修改2：添加 JSON 解析函数

在 `_parse_manifest` 函数**前面**添加：

```gdscript
# 解析 manifest.json
func _parse_manifest_json(content: String) -> void:
	var json := JSON.new()
	var err := json.parse(content)
	if err != OK:
		error_message = "manifest.json 解析失败: 第" + str(json.get_error_line()) + "行 " + json.get_error_message()
		print("[StoryLoader] " + error_message)
		return
	
	if json.data is Dictionary:
		manifest = json.data
		print("[StoryLoader] manifest.json 已加载")
		print("[StoryLoader] 包含字段: " + str(manifest.keys()))
	else:
		error_message = "manifest.json 格式错误：根元素必须是对象"
		print("[StoryLoader] " + error_message)
```

---

### 修改3：main.gd 中 `_load_story_file` 的权限读取需要兼容类型

因为 JSON 解析后数字可能是 `float` 类型，找到 `_load_story_file` 中的：

```gdscript
	# 读取权限表
	story_permissions.clear()
	if story_manifest.has("permissions"):
		var perms: Dictionary = story_manifest["permissions"]
		for perm_path in perms.keys():
			story_permissions[perm_path] = int(perms[perm_path])
```

**替换为：**

```gdscript
	# 读取权限表
	story_permissions.clear()
	if story_manifest.has("permissions"):
		var perms: Dictionary = story_manifest["permissions"]
		for perm_path in perms.keys():
			story_permissions[perm_path] = int(perms[perm_path])
		print("[StoryLoader] 权限表已加载，共 " + str(story_permissions.size()) + " 条规则")
	else:
		print("[StoryLoader] 警告: manifest中未找到permissions字段")
	
	if story_manifest.has("passwords"):
		print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
	else:
		print("[StoryLoader] 警告: manifest中未找到passwords字段")
```

### 修改4：`_cmd_unlock` 中密码等级的类型兼容

找到 `_cmd_unlock` 中的：

```gdscript
		var grant_level: int = int(pwd_info.get("grants_clearance", 0))
```

**替换为：**

```gdscript
		var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
```

---

## 总结

| 文件 | 修改 | 原因 |
|------|------|------|
| `story_loader.gd` | 添加 `manifest.json` 识别 | 原来只认 `manifest.cfg` |
| `story_loader.gd` | 添加 `_parse_manifest_json` 函数 | 解析JSON格式的manifest |
| `main.gd` | 权限读取添加调试输出 | 便于确认是否加载成功 |
| `main.gd` | unlock的类型兼容 | JSON数字默认是float |

保存两个文件，`Ctrl+S`，`F5` 测试。用 `.console.exe` 或编辑器运行，观察控制台输出是否显示：

```
[StoryLoader] manifest.json 已加载
[StoryLoader] 包含字段: ["story", "settings", "permissions", "passwords"]
[StoryLoader] 权限表已加载，共 4 条规则
[StoryLoader] 密码表已加载，共 5 个密码
```

### USER
下面是最初的阶段计划，请检查反思一下当前完成的阶段与正在进行的阶段，给当前阶段做一个较为详细的工作流程表。
**阶段一：基础框架（MVP）**
*   Godot项目基础搭建、场景树结构
    
*   基础CRT Shader实现与渲染管线
    
*   命令行输入框与基础命令解析（ls、cd、open、back、clear、help、exit）
    
*   ZIP文件读取与虚拟文件系统
    
*   基础TXT文件显示（纯文本，暂无CRT-ML解析）
    
*   打字机效果
    
*   状态栏
    
**阶段二：核心功能**
*   CRT-ML解析器（基本格式：标题、粗体、分割线、分页）
    
*   用户注册/登录系统
    
*   存档与数据持久化
    
*   头文件解析（权限、密码）
    
*   清单文件解析
    
*   文件滚动与翻页
    
*   命令自动补全与历史记录
    
*   模拟加载动画
    
**阶段三：多媒体与模板**
*   图片查看器（CRT效果覆盖、缩放、逐行扫描加载动画）
    
*   音频播放器（播放控制、简介显示、进度条）
    
*   视频播放器（基础播放控制、CRT效果覆盖）
    
*   环境音系统（循环播放、跨目录持续、自动降低音量）
    
*   CRT-ML多媒体标记解析（![image]、![audio]、![video]）
    
*   CRT-ML超链接解析（内部跳转与外部链接）
    
*   document 模板完善
    
*   email 模板实现
    
*   chat 聊天记录模板实现（逐条消息动画、打字指示器、多说话人颜色区分）
    
*   report SCP报告模板实现
    
*   聊天记录回放模式（实时回放与手动推进两种模式）
    
**阶段四：触发器与邮件系统**
*   触发器系统核心实现（条件检测、动作执行、触发链）
    
*   基础触发条件实现（on_enter、on_first_enter、on_open_file）
    
*   基础触发动作实现（new_mail、level_up、sound、text、redirect）
    
*   高级触发条件实现（on_level_reach、on_read_complete、on_idle、on_command）
    
*   高级触发动作实现（glitch、screen_off、reboot、color_scheme、lock_folder、unlock_folder）
    
*   复合触发器（分号分隔多动作顺序执行）
    
*   一次性触发器与可重复触发器逻辑
    
*   触发链深度限制与循环检测
    
*   邮件系统实现（邮件触发、延迟投递、收件箱列表、邮件阅读）
    
*   邮件图标提示与系统通知
    
*   邮件中动态变量替换（{username} 等）
    
**阶段五：特殊效果与沉浸感**
*   Jumpscare效果系统（图片闪现、屏幕震动、音效配合）
    
*   Glitch故障效果系统（屏幕撕裂、色偏、噪点、文字乱码）
    
*   CRT-ML内联效果标记实现（{glitch}、{shake}、{delay}、{sound}、{clear}）
    
*   SCP风格特殊标记实现（[REDACTED]、[DATA EXPUNGED]、||遮蔽文本||）
    
*   CRT开机动画（磷光渐亮、中心线扩展）
    
*   CRT关机动画（画面收缩为白线消失）
    
*   操作音效体系（键盘敲击、硬盘读取、电流底噪、命令反馈音）
    
*   自定义载入画面系统（loading.cfg 解析与渲染）
    
*   效果强度分级设置（完整/温和/关闭）
    
*   光敏性癫痫安全选项（关闭闪烁效果）
    
**阶段六：CRT效果优化与设置系统**
*   CRT Shader全面优化（参考cool-retro-term）
    
    *   扫描线精细调节
        
    *   RGB子像素模拟
        
    *   屏幕曲面扭曲
        
    *   边缘渐暗
        
    *   色彩渗透
        
    *   磷光余辉/拖影
        
    *   屏幕闪烁频率模拟
        
    *   亮度抖动
        
*   设置系统完整实现（显示、音频、文本、效果与安全四大分类）
    
*   配色方案切换（绿色磷光、琥珀色、白色、冰蓝、红色警戒）
    
*   设置即时预览与即时保存
    
*   设置持久化存储
    
**阶段七：调试工具与错误处理**
*   开发者模式实现（debug on/off）
    
*   开发者命令集实现（debug show_hidden、debug set_level、debug trigger 等）
    
*   实时日志面板（分级着色输出）
    
*   全面错误处理覆盖
    
    *   文件系统错误（损坏、缺失、格式不支持）
        
    *   用户操作错误（命令错误、权限不足、密码错误）
        
    *   CRT-ML解析错误（语法错误、引用缺失、编码异常）
        
    *   触发器错误（引用缺失、循环检测、深度限制）
        
    *   音视频播放错误（格式不支持、文件损坏）
        
    *   用户数据错误（存档损坏、磁盘空间不足）
        
*   错误密码惩罚机制（连续错误触发锁定或特殊事件）
    
*   超大文档分段加载渲染
    
**阶段八：扩展与打磨**
*   条件触发器实现（if_level>=、if_read: 等高级判断逻辑）
    
*   自定义模板机制（内容包内 templates/ 目录支持）
    
*   内容包文件关联（双击 .scp 文件直接用阅读器打开）
    
*   鼠标交互完善（复制粘贴、超链接点击、图片点击放大）
    
*   命令行彩蛋指令（ping、sudo、whoami 等趣味/恐怖回应）
    
*   性能优化与内存管理
    
*   全面测试与Bug修复
    
*   用户体验打磨（动画节奏、音效时机、错误提示措辞）
    
**阶段九：远期规划（视项目发展情况）**
*   主题包系统（独立于内容包的视觉主题安装机制）
    
*   插件/Mod系统预留接口
    
*   多语言支持（阅读器界面i18n）
    
*   CRT-ML语法高亮编辑器插件（VSCode等主流编辑器）
    
*   内容包结构验证与打包辅助工具
    
*   macOS平台适配
    
*   Web导出版本
    
*   社区内容包分享平台对接（远景）

### ASSISTANT
## 当前进度检查

### 阶段一：基础框架（MVP）— ✅ 已完成

| 子项 | 状态 |
|------|------|
| Godot项目基础搭建、场景树结构 | ✅ |
| 基础CRT Shader实现与渲染管线 | ⚠️ 未开始（目前无Shader） |
| 命令行输入框与基础命令解析 | ✅ |
| ZIP文件读取与虚拟文件系统 | ✅ [2] |
| 基础TXT文件显示 | ✅ |
| 打字机效果 | ✅ |
| 状态栏 | ✅ |

### 阶段二：核心功能 — 🔄 进行中（约60%）

| 子项 | 状态 | 说明 |
|------|------|------|
| CRT-ML解析器 | ❌ 未开始 | 目前只支持纯文本+BBCode |
| 用户注册/登录系统 | ❌ 未开始 | |
| 存档与数据持久化 | ✅ 已完成 | `_auto_save` / `_load_save` 已实现 [1] |
| 头文件解析（权限、密码） | ✅ 刚完成 | `manifest.json` 中的 `permissions` 和 `passwords` [1] |
| 清单文件解析 | ✅ 已完成 | `manifest.json` 完整解析 [2] |
| 文件滚动与翻页 | ⚠️ 部分完成 | 有滚动，无翻页（分页） |
| 命令自动补全与历史记录 | ✅ 已完成 | |
| 模拟加载动画 | ✅ 已完成 | 进度条动画 |

---

## 阶段二剩余工作详细流程表

### 第一优先级：修复与稳定当前功能

| 序号 | 任务 | 预估工作量 | 说明 |
|------|------|-----------|------|
| 2.0.1 | 权限系统全面测试 | 小 | 用测试包验证 `ls` 锁标记、`cd`/`open` 拦截、`unlock` 解锁全流程 |
| 2.0.2 | 存档系统全面测试 | 小 | 验证 `reboot`/`scan` 后存档隔离、跨剧本不串权限 |
| 2.0.3 | 边界情况修复 | 小 | 空目录、不存在的路径、重复unlock、错误密码连续输入 |

### 第二优先级：CRT-ML 解析器（核心新功能）

| 序号 | 任务 | 预估工作量 | 说明 |
|------|------|-----------|------|
| 2.1.1 | 设计CRT-ML语法规范 | 中 | 定义标题(`# ## ###`)、粗体(`**text**`)、分割线(`---`)、分页(`===`)等标记语法 |
| 2.1.2 | 创建 `crt_ml_parser.gd` | 大 | 新建解析器类，将CRT-ML转换为BBCode供RichTextLabel渲染 |
| 2.1.3 | 标题解析 | 中 | `# 一级标题` → 大字号+颜色，`## 二级标题` → 中字号 |
| 2.1.4 | 粗体/斜体解析 | 小 | `**粗体**` → `[b]...[/b]`，`*斜体*` → `[i]...[/i]` |
| 2.1.5 | 分割线解析 | 小 | `---` → `════════════════` 等装饰线 |
| 2.1.6 | 分页支持 | 中 | `===` 标记分页断点，打字机在此暂停，等待用户按键继续 |
| 2.1.7 | 集成到 `_cmd_open` | 中 | 打开文件时判断是否含CRT-ML标记，自动调用解析器 |
| 2.1.8 | CRT-ML与纯文本兼容 | 小 | 不含标记的文件按纯文本显示，不报错 |

### 第三优先级：用户注册/登录系统

| 序号 | 任务 | 预估工作量 | 说明 |
|------|------|-----------|------|
| 2.2.1 | 设计登录流程 | 小 | 首次运行→输入用户名注册；再次运行→自动登录或选择用户 |
| 2.2.2 | `register`/`login` 命令 | 中 | 注册新用户、切换用户 |
| 2.2.3 | 用户数据与存档绑定 | 中 | 存档路径改为 `user://saves/{username}/save_{story_id}.json` |
| 2.2.4 | `whoami` 命令完善 | 小 | 显示真实用户名、权限等级等 |
| 2.2.5 | 欢迎信息动态化 | 小 | 根据是否已登录显示不同欢迎语 |

### 第四优先级：文件翻页与阅读体验

| 序号 | 任务 | 预估工作量 | 说明 |
|------|------|-----------|------|
| 2.3.1 | 长文件分页显示 | 中 | 超过一屏的文件自动分页，底部提示"按空格继续" |
| 2.3.2 | 分页状态管理 | 小 | 记录当前页码，支持翻页/退出 |
| 2.3.3 | CRT-ML手动分页 | 小 | `===` 标记处强制分页 |

### 第五优先级：CRT Shader（补完阶段一遗留）

| 序号 | 任务 | 预估工作量 | 说明 |
|------|------|-----------|------|
| 2.4.1 | 基础CRT Shader | 中 | 扫描线 + 轻微曲面 + 边缘渐暗 |
| 2.4.2 | 挂载到主场景 | 小 | CanvasLayer + ColorRect + ShaderMaterial |
| 2.4.3 | 性能测试 | 小 | 确保Shader不影响文字可读性和帧率 |

---

## 建议的开发顺序

```
2.0 修复测试（当前权限系统）
  ↓
2.4 基础CRT Shader（视觉效果立竿见影，提升开发动力）
  ↓
2.1 CRT-ML解析器（核心内容呈现能力）
  ↓
2.3 文件翻页（改善长文阅读体验）
  ↓
2.2 用户登录系统（可推迟到阶段三前）
```

**建议先从 2.0（测试修复当前权限系统）开始，确认一切稳定后，进入 2.4（CRT Shader）给项目加上视觉辨识度。** 要开始哪一项？

### USER
先完善一下当前的权限系统，目前没有实现权限和密码功能。输入密码最好以弹窗或者类似的实现。我给你所有的main.gd，检查并增改内容，将需要修改的部分发回给我，不要发全部代码防止对话卡死。

### ASSISTANT


### USER
先完善一下当前的权限系统，目前没有实现权限和密码功能。输入密码最好以弹窗或者类似的实现。我给你所有的main.gd，检查并增改内容，将需要修改的部分发回给我，不要发全部代码防止对话卡死。
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false
# 打字机效果
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
# 权限系统
var player_clearance: int = 0              # 当前权限等级
var story_permissions: Dictionary = {}      # 路径 -> 所需权限等级
var story_id: String = ""                   # 当前剧本唯一ID
var read_files: Array[String] = []          # 已读文件列表
var unlocked_passwords: Array[String] = []  # 已解锁的密码
# ============================================================
# 初始化
# ============================================================
# 尝试加载剧本，如果失败则用测试数据
func _ready() -> void:
# 确保stories目录存在
_ensure_stories_dir()
# 尝试加载剧本，如果失败则用测试数据
if not _try_load_story():
_init_test_file_system()
output_text.text = ""
output_text.bbcode_enabled = true
# 启用鼠标选择和交互（为超链接做准备）
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
input_field.focus_mode = Control.FOCUS_ALL
# 阻止Tab键切换焦点，让我们自己处理
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
# 不再用 text_submitted 信号，改为手动监听回车键
input_field.grab_focus()
_update_status_bar()
_show_welcome_message()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 鼠标滚轮滚动
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 点击任意位置聚焦输入框
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
# 点击任何键都确保输入框有焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果正在打字或加载，按空格或ESC跳过动画
if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
_typewriter_instant = true
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
# 如果正在打字，忽略回车（防止干扰）
if _is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
command_history.append(raw_input)
history_index = -1
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 命令回显用即时显示（不走打字机）
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
# 执行命令（命令输出走打字机效果）
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
# 重置打字机为动画模式
_typewriter_instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
_cmd_story_info()
"unlock":
_cmd_unlock(args)
"scan":
await _cmd_scan()
"reboot", "restart":
await _cmd_reboot()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]vdisc[/color]         查看当前载入的虚拟磁盘信息")
lines.append("  [color=#66FF66]scan[/color]          重新扫描虚拟磁盘")
lines.append("  [color=#66FF66]unlock <密码>[/color] 输入密码提升权限等级")
lines.append("  [color=#66FF66]reboot[/color]        重启终端")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
var item_required: int = _get_required_clearance(item_path)
var is_locked: bool = not _has_clearance(item_path)
if node.type == "folder":
if is_locked:
lines.append("  [color=#FF6666][DIR]  " + item + "/  🔒 等级" + str(item_required) + "[/color]")
else:
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
if is_locked:
lines.append("  [color=#FF6666][FILE] " + item + "  🔒 等级" + str(item_required) + "[/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(new_path)
if not _has_clearance(new_path):
append_output("[color=#FF6666][ACCESS DENIED] 权限不足 - 需要等级: " + str(required) + "  当前: " + str(player_clearance) + "[/color]\n", false)
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(file_path)
if not _has_clearance(file_path):
append_output("[color=#FF6666]╔══════════════════════════════════════╗[/color]", false)
append_output("[color=#FF6666]║  [ACCESS DENIED] 权限不足           ║[/color]", false)
append_output("[color=#FF6666]║  需要等级: " + str(required) + "  当前等级: " + str(player_clearance) + " ║[/color]", false)
append_output("[color=#FF6666]╚══════════════════════════════════════╝[/color]\n", false)
return
# 先等待打字队列全部完成
while _is_typing:
await get_tree().process_frame
# 显示进度条（直接操作output_text，不走打字队列）
var content_size: int = node.content.length()
await _show_progress_bar(content_size)
# 进度条完成后等待一小会
await get_tree().create_timer(0.5).timeout
# 清屏进入阅读模式
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
# 显示文件头
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
# 记录已读
if not read_files.has(file_path):
read_files.append(file_path)
_auto_save()
# 显示文件内容（走打字机，不加额外空行）
# 清理内容：去除首尾空白，统一换行符为\n
var clean_content: String = node.content.strip_edges()
clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
append_output(clean_content, false)
# 文件尾放入队列，等内容打完后显示
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名: [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]" + str(player_clearance) + "[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
if not story_id.is_empty():
lines.append("  剧本ID: [color=#AAAAAA]" + story_id + "[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后重启终端。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 虚拟磁盘信息 ═══════════[/color]")
if story_manifest.has("story"):
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签:   [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者: [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本:    [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述:    [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数:   [color=#66FF66]" + str(file_system.size()) + "[/color]")
lines.append("  磁盘来源:   [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态:   [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_unlock(args: Array) -> void:
if args.is_empty():
append_output("[color=#FFB000]用法: unlock <密码>[/color]\n", false)
append_output("[color=#AAAAAA]在文件中寻找密码线索来提升权限等级。[/color]\n", false)
return
var password: String = args[0]
# 从manifest中查找密码
if not story_manifest.has("passwords"):
append_output("[color=#FF6666][ERROR] 密码验证失败。[/color]\n", false)
return
var passwords: Dictionary = story_manifest["passwords"]
if passwords.has(password):
var pwd_info: Dictionary = passwords[password]
var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
if unlocked_passwords.has(password):
append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(player_clearance) + "[/color]\n", false)
return
if grant_level <= player_clearance:
append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。[/color]\n", false)
return
# 解锁成功
unlocked_passwords.append(password)
player_clearance = grant_level
_auto_save()
append_output("[color=#33FF33]╔══════════════════════════════════════╗[/color]", false)
append_output("[color=#33FF33]║  [ACCESS GRANTED] 权限已提升 ║[/color]", false)
append_output("[color=#33FF33]║  新权限等级: " + str(player_clearance) + " ║[/color]", false)
append_output("[color=#33FF33]╚══════════════════════════════════════╝[/color]\n", false)
# 显示提示信息（如果有）
if pwd_info.has("message"):
append_output("[color=#AAAAAA]" + pwd_info["message"] + "[/color]\n", false)
else:
append_output("[color=#FF6666][ERROR] 密码验证失败。[/color]\n", false)
func _cmd_scan() -> void:
append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
# 显示扫描进度条
await _show_progress_bar(500)
await get_tree().create_timer(0.3).timeout
# 保存旧状态用于对比
var old_story_path: String = current_story_path
var old_manifest: Dictionary = story_manifest.duplicate()
# 重置文件系统和权限
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
# 重新扫描
if _try_load_story():
var title: String = "未知"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
if current_story_path == old_story_path:
append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]\n", false)
else:
append_output("[color=#33FF33][OK] 发现并加载新剧本: " + title + "[/color]\n", false)
append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "[/color]\n", false)
append_output("[color=#AAAAAA]权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
append_output("[color=#AAAAAA]当前权限等级: " + str(player_clearance) + "[/color]\n", false)
# 重置到起始路径
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
else:
current_path = "/"
_update_status_bar()
append_output("[color=#AAAAAA]当前路径已重置为: " + current_path + "[/color]\n", false)
else:
_init_test_file_system()
current_path = "/"
_update_status_bar()
append_output("[color=#FFB000][WARN] 未找到剧本文件，已加载内置测试数据。[/color]", false)
append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
func _cmd_reboot() -> void:
append_output("[color=#AAAAAA]正在重启终端...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 清空所有状态
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
command_history.clear()
history_index = -1
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
current_path = "/"
has_new_mail = false
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
# 重新加载
_ensure_stories_dir()
if not _try_load_story():
_init_test_file_system()
_update_status_bar()
# 模拟重启效果
output_text.append_text("[color=#AAAAAA]...[/color]\n")
await get_tree().create_timer(0.3).timeout
output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
await get_tree().create_timer(0.5).timeout
output_text.text = ""
# 重新显示欢迎信息
_show_welcome_message()
input_field.grab_focus()
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
# 只输入了一个词：补全命令
if parts.size() == 1:
# 检查是否已经是完整命令，后面有空格表示要补全参数
if current_text.ends_with(" "):
# 命令已输入完，补全文件名（无前缀匹配，列出所有）
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只补全文件夹，open/cat只补全文件
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
_do_scroll()
else:
# 补全命令名
var partial_cmd: String = parts[0].to_lower()
var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
"scan", "reboot", "restart", "unlock"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 两个词：命令 + 部分文件名
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只匹配文件夹，open/cat只匹配文件
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
# 找公共前缀，补全到最长公共部分
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 查找多个字符串的最长公共前缀
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
if not _is_typing:
_process_typewriter_queue()
func _process_typewriter_queue() -> void:
if _typewriter_queue.is_empty():
_is_typing = false
return
_is_typing = true
var entry = _typewriter_queue.pop_front()
var text: String = entry["text"]
var extra_newline: bool = entry["extra_newline"]
if _typewriter_instant:
output_text.append_text(text)
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
else:
_typewrite_text(text, extra_newline)
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
var i: int = 0
var length: int = text.length()
_current_char_speed = _typewriter_speed
while i < length:
# 如果中途切换为即时模式，把剩余文本一次性输出
if _typewriter_instant:
output_text.append_text(text.substr(i))
break
# 检查是否是BBCode标签
if text[i] == "[":
var close_bracket: int = text.find("]", i)
if close_bracket != -1:
var tag: String = text.substr(i, close_bracket - i + 1)
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 判断是否是合法的BBCode标签（以字母或/开头）
var tag_inner: String = tag.substr(1, tag.length() - 2)
if tag_inner.length() > 0 and (tag_inner[0] == "/" or tag_inner[0].unicode_at(0) >= 65 and tag_inner[0].unicode_at(0) <= 122):
# 看起来像BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 不是BBCode标签，转义方括号后逐字输出
output_text.append_text("[lb]")
i += 1
continue
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 普通BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 普通字符
var ch: String = text[i]
# 换行符不单独append，而是收集连续的换行一次性输出
if ch == "\n":
var newlines: String = "\n"
i += 1
while i < length and text[i] == "\n":
newlines += "\n"
i += 1
output_text.append_text(newlines)
# 换行后的停顿
if not _typewriter_instant:
await get_tree().create_timer(_typewriter_period_pause).timeout
_do_scroll()
continue
output_text.append_text(ch)
i += 1
# 根据字符类型决定延迟
var delay: float = _current_char_speed
# 标点符号额外停顿（制造顿挫感）
if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
delay += _typewriter_period_pause
elif ch in ["、", "—", "-", "…"]:
delay += _typewriter_comma_pause
else:
# 随机顿挫：有一定概率额外停顿
if randf() < _typewriter_pause_chance:
delay += _typewriter_pause_duration
await get_tree().create_timer(delay).timeout
# 每隔几个字符滚动一次
if i % 8 == 0:
_do_scroll()
# 当前文本打完
if extra_newline:
output_text.append_text("\n")
_do_scroll()
# 继续处理队列
_process_typewriter_queue()
func _do_scroll() -> void:
_needs_scroll = true
func _process(_delta: float) -> void:
if _needs_scroll:
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
scroll_container.scroll_vertical = int(v_scroll.max_value)
_needs_scroll = false
# 显示文件加载进度条
# file_size: 文件内容长度，影响进度条速度
# speed_override: 速度倍率覆盖，-1表示用默认
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
var bar_width: int = 30  # 进度条总长度（字符数）
var speed: float = _progress_bar_speed
if speed_override > 0.0:
speed = speed_override
# 文件越大，每格停顿越长（但有上下限）
var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
base_delay /= speed
# 起始行
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("[color=#66FF66]加载中 [[/color]")
for i in range(bar_width):
if _typewriter_instant:
# 跳过动画，直接填满
var remaining: int = bar_width - i
output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
break
output_text.append_text("[color=#33FF33]█[/color]")
_do_scroll()
# 随机波动让进度条不匀速，更真实
var jitter: float = randf_range(0.7, 1.5)
await get_tree().create_timer(base_delay * jitter).timeout
output_text.append_text("[color=#66FF66]] 完成[/color]\n")
_do_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
path_label.text = "[" + current_path + "]"
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
# 处理RichTextLabel中的超链接点击
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
# 如果是命令链接，直接执行
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
# 如果是文件链接，打开文件
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
# 计算框的宽度：取较长的那行，两侧各留3个空格
var max_len: int = max(title.length(), subtitle.length())
# 中英文混排时，中文字符占2个宽度，英文占1个
var title_display_len: int = _display_width(title)
var subtitle_display_len: int = _display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
# 居中填充
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func _display_width(text: String) -> int:
var width: int = 0
for ch in text:
var code: int = ch.unicode_at(0)
if code >= 0x4E00 and code <= 0x9FFF:
width += 2  # CJK统一汉字
elif code >= 0x3000 and code <= 0x303F:
width += 2  # CJK标点
elif code >= 0xFF00 and code <= 0xFFEF:
width += 2  # 全角字符
else:
width += 1
return width
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
# 检查路径是否需要权限，返回所需等级（0表示无需权限）
func _get_required_clearance(path: String) -> int:
path = _normalize_path(path)
var highest: int = 0
for perm_path in story_permissions.keys():
var normalized_perm: String = _normalize_path(perm_path)
# 精确匹配文件
if path == normalized_perm:
highest = max(highest, int(story_permissions[perm_path]))
# 目录匹配（目录权限影响其下所有内容）
elif normalized_perm.ends_with("/") or story_permissions.has(perm_path):
var dir_prefix: String = normalized_perm.rstrip("/") + "/"
if path.begins_with(dir_prefix) or path == normalized_perm.rstrip("/"):
highest = max(highest, int(story_permissions[perm_path]))
return highest
# 检查玩家是否有权限访问该路径
func _has_clearance(path: String) -> bool:
return player_clearance >= _get_required_clearance(path)
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
var content: String = entry.get("content", "")
# 统一换行符，防止\r\n导致双倍行距
content = content.replace("\r\n", "\n").replace("\r", "\n")
return FSNode.new(entry.get("type", "file"), content)
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 存档读档功能
# ============================================================
func _get_save_path() -> String:
return "user://saves/save_" + story_id + ".json"
func _auto_save() -> void:
if story_id.is_empty():
return
# 确保存档目录存在
var save_dir: String = "user://saves/"
if not DirAccess.dir_exists_absolute(save_dir):
DirAccess.make_dir_absolute(save_dir)
var save_data: Dictionary = {
"story_id": story_id,
"player_clearance": player_clearance,
"read_files": read_files,
"unlocked_passwords": unlocked_passwords,
"current_path": current_path
}
var file := FileAccess.open(_get_save_path(), FileAccess.WRITE)
if file:
file.store_string(JSON.stringify(save_data, "\t"))
file.close()
print("[Save] 已保存: " + _get_save_path())
func _load_save() -> bool:
var path: String = _get_save_path()
if not FileAccess.file_exists(path):
return false
var file := FileAccess.open(path, FileAccess.READ)
if file == null:
return false
var json_text: String = file.get_as_text()
file.close()
var json := JSON.new()
if json.parse(json_text) != OK:
return false
var data: Dictionary = json.data
if data.get("story_id", "") != story_id:
return false
player_clearance = int(data.get("player_clearance", 0))
read_files.clear()
if data.has("read_files"):
for f in data["read_files"]:
read_files.append(str(f))
unlocked_passwords.clear()
if data.has("unlocked_passwords"):
for p in data["unlocked_passwords"]:
unlocked_passwords.append(str(p))
if data.has("current_path"):
current_path = data["current_path"]
print("[Save] 已加载存档: " + path)
print("[Save] 权限等级: " + str(player_clearance))
return true
# ============================================================
# 测试文件系统初始化
# ============================================================
func _ensure_stories_dir() -> void:
var vdisc_path: String
if OS.has_feature("editor"):
vdisc_path = ProjectSettings.globalize_path("res://") + "vdisc/"
else:
vdisc_path = OS.get_executable_path().get_base_dir() + "/vdisc/"
if not DirAccess.dir_exists_absolute(vdisc_path):
var err := DirAccess.make_dir_absolute(vdisc_path)
if err == OK:
print("[StoryLoader] 已创建vdisc目录: " + vdisc_path)
else:
print("[StoryLoader] 创建vdisc目录失败: " + str(err))
else:
print("[StoryLoader] vdisc目录已存在: " + vdisc_path)
# 尝试从 vdisc 目录加载第一个 .scp 文件
func _try_load_story() -> bool:
var search_dirs: Array[String] = []
# 导出后：exe同级目录下的vdisc/
var exe_dir: String = OS.get_executable_path().get_base_dir()
search_dirs.append(exe_dir + "/vdisc/")
# 编辑器中运行时：项目根目录下的vdisc/
if OS.has_feature("editor"):
search_dirs.append(ProjectSettings.globalize_path("res://") + "vdisc/")
# 用户数据目录（备用）
search_dirs.append(OS.get_user_data_dir() + "/vdisc/")
for vdisc_dir in search_dirs:
print("[StoryLoader] 搜索目录: " + vdisc_dir)
if _try_load_from_dir(vdisc_dir):
return true
print("[StoryLoader] 未找到剧本文件，使用测试数据")
return false
func _try_load_from_dir(stories_dir: String) -> bool:
if not DirAccess.dir_exists_absolute(stories_dir):
return false
var dir := DirAccess.open(stories_dir)
if dir == null:
return false
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = stories_dir + file_name
print("[StoryLoader] 发现剧本: " + full_path)
return _load_story_file(full_path)
file_name = dir.get_next()
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据
file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 读取剧本ID
if story_manifest.has("story") and story_manifest["story"].has("id"):
story_id = story_manifest["story"]["id"]
else:
# 没有id就用文件名的哈希作为id
story_id = str(path.get_file().hash())
# 读取权限表
story_permissions.clear()
if story_manifest.has("permissions"):
var perms: Dictionary = story_manifest["permissions"]
for perm_path in perms.keys():
story_permissions[perm_path] = int(perms[perm_path])
print("[StoryLoader] 权限表已加载，共 " + str(story_permissions.size()) + " 条规则")
else:
print("[StoryLoader] 警告: manifest中未找到permissions字段")
if story_manifest.has("passwords"):
print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
else:
print("[StoryLoader] 警告: manifest中未找到passwords字段")
# 应用 manifest 中的设置
var start_clearance: int = 0
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
_typewriter_speed = settings["typing_speed"].to_float()
if settings.has("start_clearance"):
start_clearance = int(settings["start_clearance"])
# 尝试加载该剧本的存档
if not _load_save():
# 没有存档，用初始权限
player_clearance = start_clearance
read_files.clear()
unlocked_passwords.clear()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 剧本ID: " + story_id)
print("[StoryLoader] 文件数量: " + str(file_system.size()))
print("[StoryLoader] 权限等级: " + str(player_clearance))
return true
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
我仔细检查了完整的 `main.gd` 代码，权限和密码的**代码逻辑本身是正确的**。问题出在之前确认的 `story_loader.gd` 只识别 `manifest.cfg` 而不识别 `manifest.json`。

确认一下：**你之前是否已经修改了 `story_loader.gd`，添加了 `manifest.json` 的支持？** 如果还没改，那就是问题根源。

下面我同时给出 `story_loader.gd` 的修改（确保能用）以及 `main.gd` 的改进（加入密码输入弹窗模式）。

---

## story_loader.gd 修改（确保已修改）

找到第二遍读取文件循环中的：

```gdscript
		# 检查是否是 manifest.cfg
		var filename: String = clean_path.get_file()
		if filename == "manifest.cfg":
			_parse_manifest(content)
			continue
```

**替换为：**

```gdscript
		# 检查是否是 manifest 文件
		var filename: String = clean_path.get_file()
		if filename == "manifest.json":
			_parse_manifest_json(content)
			continue
		if filename == "manifest.cfg":
			_parse_manifest(content)
			continue
```

在 `_parse_manifest` 函数**前面**添加：

```gdscript
# 解析 manifest.json
func _parse_manifest_json(content: String) -> void:
	var json := JSON.new()
	var err := json.parse(content)
	if err != OK:
		error_message = "manifest.json 解析失败: 第" + str(json.get_error_line()) + "行 " + json.get_error_message()
		print("[StoryLoader] " + error_message)
		return
	
	if json.data is Dictionary:
		manifest = json.data
		print("[StoryLoader] manifest.json 已加载")
		print("[StoryLoader] 包含字段: " + str(manifest.keys()))
	else:
		error_message = "manifest.json 格式错误：根元素必须是对象"
		print("[StoryLoader] " + error_message)
```

---

## main.gd 修改：添加密码输入弹窗

### 修改1：添加弹窗状态变量

找到：

```gdscript
var unlocked_passwords: Array[String] = []  # 已解锁的密码
```

在它**后面**添加：

```gdscript
# 密码输入弹窗状态
var _password_mode: bool = false            # 是否处于密码输入模式
var _password_target_path: String = ""      # 密码输入针对的路径（空表示通用unlock）
```

### 修改2：修改 `_cmd_unlock` 为弹窗交互模式

找到整个 `_cmd_unlock` 函数，**替换为：**

```gdscript
func _cmd_unlock(args: Array) -> void:
	# 如果带了参数，直接验证（兼容旧用法）
	if not args.is_empty():
		_verify_password(args[0])
		return
	
	# 无参数，进入密码输入模式
	_enter_password_mode()

func _enter_password_mode(target_path: String = "") -> void:
	_password_mode = true
	_password_target_path = target_path
	
	var lines: Array[String] = []
	lines.append("[color=#FFB000]╔══════════════════════════════════════╗[/color]")
	lines.append("[color=#FFB000]║     SECURITY AUTHENTICATION         ║[/color]")
	lines.append("[color=#FFB000]║     安全认证系统                    ║[/color]")
	lines.append("[color=#FFB000]╠══════════════════════════════════════╣[/color]")
	lines.append("[color=#FFB000]║  请输入访问密码:                    ║[/color]")
	lines.append("[color=#FFB000]║  (输入 cancel 取消)                 ║[/color]")
	lines.append("[color=#FFB000]╚══════════════════════════════════════╝[/color]")
	append_output("\n".join(lines) + "\n", false)
	
	# 修改输入框提示
	input_field.placeholder_text = "输入密码..."

func _verify_password(password: String) -> void:
	# 从manifest中查找密码
	if not story_manifest.has("passwords"):
		append_output("[color=#FF6666][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
		return
	
	var passwords: Dictionary = story_manifest["passwords"]
	
	if passwords.has(password):
		var pwd_info: Dictionary = passwords[password]
		var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
		
		if unlocked_passwords.has(password):
			append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(player_clearance) + "[/color]\n", false)
			return
		
		if grant_level <= player_clearance:
			append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。当前: " + str(player_clearance) + "[/color]\n", false)
			return
		
		# 解锁成功
		unlocked_passwords.append(password)
		var old_level: int = player_clearance
		player_clearance = grant_level
		_auto_save()
		
		# 成功动画
		append_output("[color=#33FF33]╔══════════════════════════════════════╗[/color]", false)
		append_output("[color=#33FF33]║       ACCESS GRANTED                ║[/color]", false)
		append_output("[color=#33FF33]║       权限认证通过                  ║[/color]", false)
		append_output("[color=#33FF33]╠══════════════════════════════════════╣[/color]", false)
		append_output("[color=#33FF33]║  权限等级: " + str(old_level) + " → " + str(player_clearance) + "                       ║[/color]", false)
		append_output("[color=#33FF33]╚══════════════════════════════════════╝[/color]\n", false)
		
		# 显示提示信息（如果有）
		if pwd_info.has("message"):
			append_output("[color=#AAAAAA]" + str(pwd_info["message"]) + "[/color]\n", false)
	else:
		append_output("[color=#FF6666]╔══════════════════════════════════════╗[/color]", false)
		append_output("[color=#FF6666]║       ACCESS DENIED                 ║[/color]", false)
		append_output("[color=#FF6666]║       密码验证失败                  ║[/color]", false)
		append_output("[color=#FF6666]╚══════════════════════════════════════╝[/color]\n", false)
```

### 修改3：修改 `_on_command_submitted` 支持密码模式

找到 `_on_command_submitted` 函数，**替换为：**

```gdscript
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	input_field.clear()
	
	if raw_input.is_empty():
		return
	
	# 如果处于密码输入模式
	if _password_mode:
		_password_mode = false
		input_field.placeholder_text = "> 输入命令..."
		
		# 等待打字队列完成
		while _is_typing:
			await get_tree().process_frame
		
		# 密码回显用星号
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
		
		if raw_input.to_lower() == "cancel":
			append_output("[color=#AAAAAA]已取消密码输入。[/color]\n", false)
			return
		
		_verify_password(raw_input)
		return
	
	command_history.append(raw_input)
	history_index = -1
	
	# 等待打字队列完成
	while _is_typing:
		await get_tree().process_frame
	
	# 命令回显用即时显示（不走打字机）
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text("> " + raw_input + "\n")
	
	# 执行命令（命令输出走打字机效果）
	await _execute_command(raw_input)
```

### 修改4：权限不足时自动弹出密码输入

找到 `_cmd_open` 中的权限检查部分：

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(file_path)
	if not _has_clearance(file_path):
		append_output("[color=#FF6666]╔══════════════════════════════════════╗[/color]", false)
		append_output("[color=#FF6666]║  [ACCESS DENIED] 权限不足           ║[/color]", false)
		append_output("[color=#FF6666]║  需要等级: " + str(required) + "  当前等级: " + str(player_clearance) + " ║[/color]", false)
		append_output("[color=#FF6666]╚══════════════════════════════════════╝[/color]\n", false)
		return
```

**替换为：**

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(file_path)
	if not _has_clearance(file_path):
		append_output("[color=#FF6666]╔══════════════════════════════════════╗[/color]", false)
		append_output("[color=#FF6666]║  [ACCESS DENIED] 权限不足           ║[/color]", false)
		append_output("[color=#FF6666]║  需要等级: " + str(required) + "  当前等级: " + str(player_clearance) + "                   ║[/color]", false)
		append_output("[color=#FF6666]╠══════════════════════════════════════╣[/color]", false)
		append_output("[color=#FF6666]║  输入 unlock 尝试密码认证           ║[/color]", false)
		append_output("[color=#FF6666]╚══════════════════════════════════════╝[/color]\n", false)
		return
```

同样修改 `_cmd_cd` 中的权限检查部分：

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(new_path)
	if not _has_clearance(new_path):
		append_output("[color=#FF6666][ACCESS DENIED] 权限不足 - 需要等级: " + str(required) + "  当前: " + str(player_clearance) + "[/color]\n", false)
		return
```

**替换为：**

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(new_path)
	if not _has_clearance(new_path):
		append_output("[color=#FF6666][ACCESS DENIED] 权限不足 - 需要等级: " + str(required) + "  当前: " + str(player_clearance) + "[/color]", false)
		append_output("[color=#AAAAAA]输入 unlock 尝试密码认证。[/color]\n", false)
		return
```

### 修改5：状态栏显示权限等级

找到 `_update_status_bar` 函数，**替换为：**

```gdscript
func _update_status_bar() -> void:
	path_label.text = "[" + current_path + "]  LV:" + str(player_clearance)
	if has_new_mail:
		mail_icon.text = "[Mail NEW]"
	else:
		mail_icon.text = "[Mail]"
```

### 修改6：`_get_required_clearance` 逻辑修复

当前的目录匹配逻辑有问题——`story_permissions.has(perm_path)` 永远为 true（因为它就是从 `story_permissions` 遍历出来的）。找到整个 `_get_required_clearance` 函数，**替换为：**

```gdscript
# 检查路径是否需要权限，返回所需等级（0表示无需权限）
func _get_required_clearance(path: String) -> int:
	path = _normalize_path(path)
	var highest: int = 0
	
	for perm_path in story_permissions.keys():
		var normalized_perm: String = _normalize_path(perm_path)
		
		# 精确匹配
		if path == normalized_perm:
			highest = max(highest, int(story_permissions[perm_path]))
			continue
		
		# 目录匹配：如果 perm_path 原始值以 / 结尾，说明是目录规则
		# 或者 normalized_perm 在 file_system 中是 folder 类型
		var is_dir_rule: bool = perm_path.ends_with("/")
		if not is_dir_rule:
			# 检查是否在文件系统中注册为文件夹
			if file_system.has(normalized_perm):
				is_dir_rule = file_system[normalized_perm].get("type", "") == "folder"
		
		if is_dir_rule:
			var dir_prefix: String = normalized_perm.rstrip("/") + "/"
			# 路径在该目录下
			if path.begins_with(dir_prefix):
				highest = max(highest, int(story_permissions[perm_path]))
			# 路径就是该目录本身
			elif path == normalized_perm.rstrip("/"):
				highest = max(highest, int(story_permissions[perm_path]))
	
	return highest
```

### 修改7：修改 `_cmd_help` 中 unlock 的说明

找到：

```gdscript
	lines.append("  [color=#66FF66]unlock <密码>[/color] 输入密码提升权限等级")
```

**替换为：**

```gdscript
	lines.append("  [color=#66FF66]unlock[/color]        进入密码认证（也可 unlock <密码>）")
```

---

## 总结修改清单

| 文件 | 修改位置 | 内容 |
|------|---------|------|
| `story_loader.gd` | 文件识别 | 添加 `manifest.json` 支持 |
| `story_loader.gd` | 新函数 | 添加 `_parse_manifest_json` |
| `main.gd` | 变量声明 | 添加 `_password_mode` 等 |
| `main.gd` | `_cmd_unlock` | 重写为弹窗+直接两种模式 |
| `main.gd` | `_on_command_submitted` | 添加密码模式拦截 |
| `main.gd` | `_cmd_open` 权限提示 | 添加 unlock 提示 |
| `main.gd` | `_cmd_cd` 权限提示 | 添加 unlock 提示 |
| `main.gd` | `_update_status_bar` | 显示权限等级 |
| `main.gd` | `_get_required_clearance` | 修复目录匹配逻辑 |
| `main.gd` | `_cmd_help` | 更新 unlock 说明 |

### USER
为什么我现在一打开就进入了classified文件夹，以及现在软件完全没有阻止我访问的行动，请想办法解决。

### ASSISTANT
## 问题分析

### 问题1：一打开就进入classified文件夹

这是因为上次存档保存了 `current_path` 为 `/classified`。`_load_save()` 加载存档时会恢复路径 [1]。你之前测试时进入了classified目录，存档记住了这个位置。

**解决方法：** 删除旧存档，或者在代码中修复。

找到 `_load_save` 函数中的：

```gdscript
	if data.has("current_path"):
		current_path = data["current_path"]
```

**替换为：**

```gdscript
	if data.has("current_path"):
		var saved_path: String = data["current_path"]
		# 验证存档路径是否有权限访问，没有则重置到起始路径
		if _has_clearance(saved_path):
			current_path = saved_path
		else:
			current_path = "/"
			if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
				current_path = story_manifest["settings"]["start_path"]
```

同时，**手动删除旧存档**：在文件管理器中打开 `%APPDATA%\Godot\app_userdata\你的项目名\saves\` 目录，删除里面所有 `.json` 文件。

---

### 问题2：权限系统完全不起作用

权限检查依赖 `story_permissions` 字典，如果这个字典是空的，`_get_required_clearance()` 永远返回 0，权限检查形同虚设 [1]。

**最可能的原因：** `story_loader.gd` 中的 `manifest.json` 支持还没有生效。请确认你的 `story_loader.gd` 已经做了以下修改：

找到第二遍读取文件循环中的：

```gdscript
		var filename: String = clean_path.get_file()
		if filename == "manifest.cfg":
			_parse_manifest(content)
			continue
```

**替换为：**

```gdscript
		var filename: String = clean_path.get_file()
		if filename == "manifest.json":
			_parse_manifest_json(content)
			continue
		if filename == "manifest.cfg":
			_parse_manifest(content)
			continue
```

确认 `_parse_manifest_json` 函数已经添加到 `story_loader.gd` 中 [2]：

```gdscript
func _parse_manifest_json(content: String) -> void:
	var json := JSON.new()
	var err := json.parse(content)
	if err != OK:
		error_message = "manifest.json 解析失败: 第" + str(json.get_error_line()) + "行 " + json.get_error_message()
		print("[StoryLoader] " + error_message)
		return
	
	if json.data is Dictionary:
		manifest = json.data
		print("[StoryLoader] manifest.json 已加载")
		print("[StoryLoader] 包含字段: " + str(manifest.keys()))
	else:
		error_message = "manifest.json 格式错误"
		print("[StoryLoader] " + error_message)
```

---

### 问题3：在 `_load_story_file` 中添加验证输出

找到 `_load_story_file` 中的 `return true` 之前，确认有以下调试输出：

```gdscript
	print("[StoryLoader] 权限等级: " + str(player_clearance))
	print("[StoryLoader] story_permissions 内容: " + str(story_permissions))
```

如果没有，在 `return true` **前面**添加：

```gdscript
	print("[StoryLoader] story_permissions 内容: " + str(story_permissions))
```

---

## 验证步骤

1. 保存所有修改
2. 删除旧存档（`%APPDATA%\Godot\app_userdata\项目名\saves\`）
3. `F5` 运行
4. 观察控制台是否输出：
   ```
   [StoryLoader] manifest.json 已加载
   [StoryLoader] 包含字段: ["story", "settings", "permissions", "passwords"]
   [StoryLoader] 权限表已加载，共 6 条规则
   [StoryLoader] story_permissions 内容: {"/personnel/": 1, "/comms/": 2, ...}
   ```
5. 输入 `ls`，检查是否有🔒标记
6. 输入 `cd personnel`，应该提示权限不足

**如果控制台没有 "manifest.json 已加载" 这行输出，说明 `story_loader.gd` 的修改没有生效，请把你当前的 `story_loader.gd` 完整代码发给我。**

### USER
我没有%APPDATA%\Godot\app_userdata\你的项目名\saves\这个路径，我们是不是忘记建立存档文件了？不要把存档放在其它地方，放在游戏根目录。
下面是我的story_loader.gd，你再检查一下。
class_name StoryLoader
extends RefCounted
# 加载结果
var file_system: Dictionary = {}
var manifest: Dictionary = {}
var error_message: String = ""
# 从 .scp (ZIP) 文件加载剧本
func load_story(path: String) -> bool:
file_system.clear()
manifest.clear()
error_message = ""
# 打开ZIP文件
var reader := ZIPReader.new()
var err := reader.open(path)
if err != OK:
error_message = "无法打开文件: " + path
return false
# 获取ZIP内所有文件路径
var files := reader.get_files()
# 第一遍：收集所有文件夹路径
var folders: Dictionary = {}
folders["/"] = true
for file_path in files:
# 跳过空路径
if file_path.strip_edges().is_empty():
continue
# 标准化路径：确保以 / 开头
var clean_path: String = _clean_zip_path(file_path)
# 收集所有父级文件夹
var parts := clean_path.split("/", false)
var current := ""
for i in range(parts.size() - 1):
current += "/" + parts[i]
folders[current] = true
# 如果路径本身以 / 结尾，它是文件夹
if file_path.ends_with("/"):
folders[clean_path.rstrip("/")] = true
# 注册所有文件夹
for folder_path in folders.keys():
if folder_path == "/":
continue
file_system[folder_path] = {
"type": "folder"
}
# 第二遍：读取所有文件内容
for file_path in files:
if file_path.strip_edges().is_empty():
continue
if file_path.ends_with("/"):
continue
var clean_path: String = _clean_zip_path(file_path)
# 读取文件内容
var content_bytes := reader.read_file(file_path)
if content_bytes == null:
continue
var content: String = content_bytes.get_string_from_utf8()
# 检查是否是 manifest 文件
var filename: String = clean_path.get_file()
if filename == "manifest.json":
_parse_manifest_json(content)
continue
if filename == "manifest.cfg":
_parse_manifest(content)
continue
# 注册为文件
file_system[clean_path] = {
"type": "file",
"content": content
}
reader.close()
return true
# 清理ZIP内部路径，统一为 /开头 的格式
func _clean_zip_path(zip_path: String) -> String:
# 去除开头的 ./
var path: String = zip_path
if path.begins_with("./"):
path = path.substr(2)
# 去除末尾的 /
path = path.rstrip("/")
# 确保以 / 开头
if not path.begins_with("/"):
path = "/" + path
return path
# 解析 manifest.json
func _parse_manifest_json(content: String) -> void:
var json := JSON.new()
var err := json.parse(content)
if err != OK:
error_message = "manifest.json 解析失败: 第" + str(json.get_error_line()) + "行 " + json.get_error_message()
print("[StoryLoader] " + error_message)
return
if json.data is Dictionary:
manifest = json.data
print("[StoryLoader] manifest.json 已加载")
print("[StoryLoader] 包含字段: " + str(manifest.keys()))
else:
error_message = "manifest.json 格式错误"
print("[StoryLoader] " + error_message)
# 解析 manifest.cfg
func _parse_manifest(content: String) -> void:
var current_section: String = ""
for line in content.split("\n"):
line = line.strip_edges()
# 跳过空行和注释
if line.is_empty() or line.begins_with("#") or line.begins_with(";"):
continue
# 段落标记 [section]
if line.begins_with("[") and line.ends_with("]"):
current_section = line.substr(1, line.length() - 2)
if not manifest.has(current_section):
manifest[current_section] = {}
continue
# 键值对 key=value
var eq_pos: int = line.find("=")
if eq_pos > 0 and not current_section.is_empty():
var key: String = line.substr(0, eq_pos).strip_edges()
var value: String = line.substr(eq_pos + 1).strip_edges()
manifest[current_section][key] = value

### ASSISTANT
## 检查结果

### story_loader.gd：没有问题

你的 `story_loader.gd` 已经包含了 `manifest.json` 支持，代码正确。

### 存档路径问题

Godot 的 `user://` 路径在 Windows 上确实是 `%APPDATA%\Godot\app_userdata\项目名\`。存档目录需要在第一次保存时才会被创建 [1]。但你说要放在**游戏根目录**，那我们改存档路径。

---

## main.gd 修改

### 修改1：添加获取游戏根目录的工具函数

找到 `_ensure_stories_dir` 函数，在它**前面**添加：

```gdscript
# 获取游戏根目录（编辑器中为项目目录，导出后为exe所在目录）
func _get_game_root_dir() -> String:
	if OS.has_feature("editor"):
		return ProjectSettings.globalize_path("res://")
	else:
		return OS.get_executable_path().get_base_dir() + "/"
```

### 修改2：修改存档路径

找到 `_get_save_path` 函数 [1]：

```gdscript
func _get_save_path() -> String:
	return "user://saves/save_" + story_id + ".json"
```

**替换为：**

```gdscript
func _get_save_path() -> String:
	return _get_game_root_dir() + "saves/save_" + story_id + ".json"
```

### 修改3：修改 `_auto_save` 中的目录创建

找到 `_auto_save` 函数中的 [1]：

```gdscript
	# 确保存档目录存在
	var save_dir: String = "user://saves/"
	if not DirAccess.dir_exists_absolute(save_dir):
		DirAccess.make_dir_absolute(save_dir)
	
	var save_data: Dictionary = {
		"story_id": story_id,
		"player_clearance": player_clearance,
		"read_files": read_files,
		"unlocked_passwords": unlocked_passwords,
		"current_path": current_path
	}
	
	var file := FileAccess.open(_get_save_path(), FileAccess.WRITE)
```

**替换为：**

```gdscript
	# 确保存档目录存在
	var save_dir: String = _get_game_root_dir() + "saves/"
	if not DirAccess.dir_exists_absolute(save_dir):
		var err := DirAccess.make_dir_absolute(save_dir)
		if err == OK:
			print("[Save] 已创建存档目录: " + save_dir)
		else:
			print("[Save] 创建存档目录失败: " + str(err))
			return
	
	var save_data: Dictionary = {
		"story_id": story_id,
		"player_clearance": player_clearance,
		"read_files": read_files,
		"unlocked_passwords": unlocked_passwords,
		"current_path": current_path
	}
	
	var save_path: String = _get_save_path()
	print("[Save] 存档路径: " + save_path)
	var file := FileAccess.open(save_path, FileAccess.WRITE)
```

### 修改4：修改 `_load_save` 中的路径

找到 `_load_save` 函数开头的：

```gdscript
	var path: String = _get_save_path()
	if not FileAccess.file_exists(path):
		return false
```

**替换为：**

```gdscript
	var path: String = _get_save_path()
	print("[Save] 尝试加载存档: " + path)
	if not FileAccess.file_exists(path):
		print("[Save] 存档不存在，使用默认设置")
		return false
```

### 修改5：修改 `_ensure_stories_dir` 使用新的根目录函数

找到整个 `_ensure_stories_dir` 函数：

```gdscript
func _ensure_stories_dir() -> void:
	var vdisc_path: String
	if OS.has_feature("editor"):
		vdisc_path = ProjectSettings.globalize_path("res://") + "vdisc/"
	else:
		vdisc_path = OS.get_executable_path().get_base_dir() + "/vdisc/"
```

**替换为：**

```gdscript
func _ensure_stories_dir() -> void:
	var vdisc_path: String = _get_game_root_dir() + "vdisc/"
```

后面的 `if not DirAccess.dir_exists_absolute(vdisc_path):` 部分保持不变。

### 修改6：修改 `_try_load_story` 简化搜索路径

找到整个 `_try_load_story` 函数：

```gdscript
func _try_load_story() -> bool:
	var search_dirs: Array[String] = []
	
	# 导出后：exe同级目录下的vdisc/
	var exe_dir: String = OS.get_executable_path().get_base_dir()
	search_dirs.append(exe_dir + "/vdisc/")
	
	# 编辑器中运行时：项目根目录下的vdisc/
	if OS.has_feature("editor"):
		search_dirs.append(ProjectSettings.globalize_path("res://") + "vdisc/")
	
	# 用户数据目录（备用）
	search_dirs.append(OS.get_user_data_dir() + "/vdisc/")
	
	for vdisc_dir in search_dirs:
		print("[StoryLoader] 搜索目录: " + vdisc_dir)
		if _try_load_from_dir(vdisc_dir):
			return true
	
	print("[StoryLoader] 未找到剧本文件，使用测试数据")
	return false
```

**替换为：**

```gdscript
func _try_load_story() -> bool:
	var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
	print("[StoryLoader] 搜索目录: " + vdisc_dir)
	if _try_load_from_dir(vdisc_dir):
		return true
	
	print("[StoryLoader] 未找到剧本文件，使用测试数据")
	return false
```

### 修改7：在 `_load_story_file` 末尾添加权限调试输出

找到 `_load_story_file` 中的 `return true`，在它**前面**添加：

```gdscript
	print("[StoryLoader] story_permissions 内容: " + str(story_permissions))
	print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
```

---

## 修改后的目录结构

```
SCRT-Reader.exe
vdisc/
    └── test_story.scp
saves/                        ← 自动创建
    └── save_site19_incident_0117.json
```

保存后 `F5` 运行，观察控制台输出。**重点看这几行是否出现：**

```
[StoryLoader] manifest.json 已加载
[StoryLoader] 包含字段: ["story", "settings", "permissions", "passwords"]
[StoryLoader] 权限表已加载，共 6 条规则
[StoryLoader] story_permissions 内容: {"/personnel/": 1, "/comms/": 2, ...}
```

如果没有出现，把控制台的完整输出发给我。

### USER
在修改7中，代码如下，没有return true
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false

### ASSISTANT
你说得对，你只看到了 `_load_story_file` 函数的开头部分。`return true` 在函数的**末尾**。

修改7的意思是：找到 `_load_story_file` 函数中**已有的** `return true` 那一行（它在函数最底部），在它**前面**添加两行调试输出。

具体操作：在 `_load_story_file` 函数中找到最后的：

```gdscript
	print("[StoryLoader] 成功加载: " + title)
	print("[StoryLoader] 剧本ID: " + story_id)
	print("[StoryLoader] 文件数量: " + str(file_system.size()))
	print("[StoryLoader] 权限等级: " + str(player_clearance))
	return true
```

**替换为：**

```gdscript
	print("[StoryLoader] 成功加载: " + title)
	print("[StoryLoader] 剧本ID: " + story_id)
	print("[StoryLoader] 文件数量: " + str(file_system.size()))
	print("[StoryLoader] 权限等级: " + str(player_clearance))
	print("[StoryLoader] story_permissions 内容: " + str(story_permissions))
	print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
	return true
```

就是在 `return true` **前面**插入两行 `print`，`return true` 保持不动。这样运行时控制台会输出权限表的实际内容，帮助你确认 manifest.json 是否被正确解析。

### USER
控制台输出如下，但仍然没有阻止我进入有密码和权限的文档和文件夹
Godot Engine v4.6.stable.official.89cea1439 - https://godotengine.org
OpenGL API 3.3.0 - Build 31.0.101.2111 - Compatibility - Using Device: Intel - Intel(R) UHD Graphics
[StoryLoader] vdisc目录已存在: D:/Godot/Projects/SCRT/vdisc/
[StoryLoader] 搜索目录: D:/Godot/Projects/SCRT/vdisc/
[StoryLoader] 发现剧本: D:/Godot/Projects/SCRT/vdisc/test_story.scp
[StoryLoader] manifest.json 已加载
[StoryLoader] 包含字段: ["story", "settings", "permissions", "passwords"]
[StoryLoader] 权限表已加载，共 6 条规则
[StoryLoader] 密码表已加载，共 5 个密码
[Save] 尝试加载存档: D:/Godot/Projects/SCRT/saves/save_site19_incident_0117.json
[Save] 存档不存在，使用默认设置
[StoryLoader] 成功加载: Site-19 事故调查
[StoryLoader] 剧本ID: site19_incident_0117
[StoryLoader] 文件数量: 18
[StoryLoader] 权限等级: 0
[StoryLoader] story_permissions 内容: { "/personnel/": 1, "/comms/": 2, "/reports/incident_0117.txt": 2, "/reports/scp_682.txt": 3, "/classified/": 4, "/classified/overseer_memo.txt": 5 }
[StoryLoader] passwords 存在: true

### ASSISTANT
控制台输出显示 manifest.json 已正确加载，权限表和密码表都存在 [1]。问题出在**权限检查代码虽然存在，但可能没有被正确执行**。

我需要看你当前 `main.gd` 中以下三个函数的**实际代码**来定位问题：

1. `_get_required_clearance` 函数
2. `_has_clearance` 函数
3. `_cmd_cd` 函数中权限检查的部分
4. `_cmd_open` 函数中权限检查的部分

请你在游戏中做以下测试，然后告诉我结果：

**测试1：** 输入 `cd personnel`，终端显示了什么？（是"权限不足"还是直接进去了？）

**测试2：** 输入 `open reports/incident_0117.txt`，终端显示了什么？

同时，请在 `_cmd_cd` 函数中，找到权限检查部分，看看它**是否存在**。应该长这样：

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(new_path)
	if not _has_clearance(new_path):
```

如果这段代码在你的 `_cmd_cd` 中**不存在**，那就是之前的修改没有成功应用。请将你当前的 `_cmd_cd` 函数和 `_cmd_open` 函数的完整代码发给我，我来确认权限检查是否到位。

另外，请在 `_cmd_cd` 中权限检查**之前**临时添加一行调试输出来定位问题：

找到 `_cmd_cd` 中的 `if node.type != "folder":` 判断**之后**，添加：

```gdscript
	# 调试输出
	print("[DEBUG] cd 目标: " + new_path + " 需要权限: " + str(_get_required_clearance(new_path)) + " 当前权限: " + str(player_clearance))
```

同样在 `_cmd_open` 中找到 `if node.type != "file":` 判断**之后**，添加：

```gdscript
	# 调试输出
	print("[DEBUG] open 目标: " + file_path + " 需要权限: " + str(_get_required_clearance(file_path)) + " 当前权限: " + str(player_clearance))
```

再次运行并尝试 `cd personnel` 和 `open reports/incident_0117.txt`，把控制台新增的 `[DEBUG]` 输出发给我，我就能确定问题在哪里。

### USER
1.cd personnel，我直接进入了personnel文件夹
2.open reports/incident_0117.txt，我直接阅读了这个txt，你说的那段# 权限检查代码是存在的
我运行并输入cd personnel和open reports/incident_0117.txt之后没有输出debug，是什么问题？

### ASSISTANT
没有输出 DEBUG 说明**你添加调试代码的位置不对**，或者代码根本没有执行到那里。

但更关键的是：权限检查代码存在却不起作用，最大的可能性是 **`_get_required_clearance` 函数返回了0**。

请你在 `_get_required_clearance` 函数的**最开头**添加调试输出。

找到 [1]：

```gdscript
func _get_required_clearance(path: String) -> int:
	path = _normalize_path(path)
	var highest: int = 0
```

**替换为：**

```gdscript
func _get_required_clearance(path: String) -> int:
	path = _normalize_path(path)
	var highest: int = 0
	print("[DEBUG] _get_required_clearance 被调用, path=" + path)
	print("[DEBUG] story_permissions 大小=" + str(story_permissions.size()))
```

然后找到这个函数的 `return highest` 那行，在它**前面**添加：

```gdscript
	print("[DEBUG] 最终返回权限等级: " + str(highest))
```

同时，请把你当前的 **`_get_required_clearance` 函数完整代码**发给我。我怀疑这个函数的目录匹配逻辑有问题——`/

### USER
_目前get_required_clearance函数完整代码
# 检查路径是否需要权限，返回所需等级（0表示无需权限）
func _get_required_clearance(path: String) -> int:
path = _normalize_path(path)
var highest: int = 0
for perm_path in story_permissions.keys():
var normalized_perm: String = _normalize_path(perm_path)
# 精确匹配
if path == normalized_perm:
highest = max(highest, int(story_permissions[perm_path]))
continue
# 目录匹配：如果 perm_path 原始值以 / 结尾，说明是目录规则
# 或者 normalized_perm 在 file_system 中是 folder 类型
var is_dir_rule: bool = perm_path.ends_with("/")
if not is_dir_rule:
# 检查是否在文件系统中注册为文件夹
if file_system.has(normalized_perm):
is_dir_rule = file_system[normalized_perm].get("type", "") == "folder"
if is_dir_rule:
var dir_prefix: String = normalized_perm.rstrip("/") + "/"
# 路径在该目录下
if path.begins_with(dir_prefix):
highest = max(highest, int(story_permissions[perm_path]))
# 路径就是该目录本身
elif path == normalized_perm.rstrip("/"):
highest = max(highest, int(story_permissions[perm_path]))
return highest

### ASSISTANT
找到问题了！

## 问题根源

你的 `manifest.json` 中权限定义用的是 **带斜杠结尾** 的目录路径：

```json
"/personnel/": 1,
"/comms/": 2,
"/classified/": 4
```

但 `_normalize_path` 函数会**去掉末尾斜杠**。所以：

- `perm_path` = `"/personnel/"` (原始key，带斜杠)
- `normalized_perm` = `_normalize_path("/personnel/")` = `"/personnel"` (去掉了斜杠)

然后看精确匹配逻辑：
- 用户输入 `cd personnel`，`path` 被标准化为 `"/personnel"`
- `normalized_perm` = `"/personnel"`
- **精确匹配成功**，`highest` 设为 1，然后 `continue` 跳过后续

这看起来应该能工作……但等等，**让我再检查 `int(story_permissions[perm_path])` 这一行**。

`story_permissions[perm_path]` 中的 `perm_path` 是 `"/personnel/"`（带斜杠），而 JSON 解析后数字类型是 **float**，不是 int。`int(1.0)` = `1`，这应该没问题。

**真正的问题在于**：你的 `_normalize_path` 把 `"/personnel/"` 变成了 `"/personnel"`，但精确匹配时 `path`（也是 `"/personnel"`）确实等于 `normalized_perm`。这应该匹配上……

**除非** `story_permissions` 的 key 在被存入时路径没有正确处理。让我看看 `_load_story_file` 中的存储逻辑 [1]：

```gdscript
story_permissions[perm_path] = int(perms[perm_path])
```

这里 `perm_path` 保留了原始的 `"/personnel/"`。然后在 `_get_required_clearance` 遍历时，`perm_path` = `"/personnel/"`，经过 `_normalize_path` 后变成 `"/personnel"`，精确匹配成功。

**我终于发现了！问题出在 `int()` 转换！** JSON解析后的值可能是 `float` 类型，`int(story_permissions[perm_path])` 在 Godot 4 中如果值类型不对，可能返回 0。

---

## 解决方案：完整替换 `_get_required_clearance`

找到整个 `_get_required_clearance` 函数，**替换为：**

```gdscript
# 检查路径是否需要权限，返回所需等级（0表示无需权限）
func _get_required_clearance(path: String) -> int:
	path = _normalize_path(path)
	var highest: int = 0
	
	print("[PERM] 检查路径: " + path)
	
	for perm_path in story_permissions.keys():
		var perm_value: int = int(float(story_permissions[perm_path]))
		var normalized_perm: String = _normalize_path(perm_path)
		
		# 精确匹配
		if path == normalized_perm:
			print("[PERM] 精确匹配: " + perm_path + " = " + str(perm_value))
			highest = max(highest, perm_value)
			continue
		
		# 目录前缀匹配：检查path是否在该目录下
		var dir_prefix: String = normalized_perm + "/"
		if path.begins_with(dir_prefix):
			print("[PERM] 目录匹配: " + perm_path + " = " + str(perm_value))
			highest = max(highest, perm_value)
	
	print("[PERM] 最终权限要求: " + str(highest))
	return highest
```

这个新版本做了三个关键改进：

1. **`int(float(...))`** 双重转换，确保 JSON 的数字不论是 int 还是 float 都能正确处理
2. **去掉了复杂的 `is_dir_rule` 判断**，直接用 `normalized_perm + "/"` 作为前缀匹配，更简洁不容易出错
3. **添加了 `[PERM]` 调试输出**，运行后能立即看到权限检查过程

保存后 `F5` 运行，输入 `cd personnel`，把控制台的 `[PERM]` 输出发给我。

### USER
cd personnel之后输出了
[PERM] 检查路径: /test_story/personnel
[PERM] 最终权限要求: 0
[PERM] 检查路径: /test_story/personnel
[PERM] 最终权限要求: 0
[PERM] 检查路径: /test_story/personnel/agent_k.txt
[PERM] 最终权限要求: 0
[PERM] 检查路径: /test_story/personnel/agent_k.txt
[PERM] 最终权限要求: 0
[PERM] 检查路径: /test_story/personnel/dr_bright.txt
[PERM] 最终权限要求: 0
[PERM] 检查路径: /test_story/personnel/dr_bright.txt
[PERM] 最终权限要求: 0
[PERM] 检查路径: /test_story/personnel/dr_zhang.txt
[PERM] 最终权限要求: 0
[PERM] 检查路径: /test_story/personnel/dr_zhang.txt
[PERM] 最终权限要求: 0

### ASSISTANT
## 找到根本原因了！

路径是 `/test_story/personnel` 而不是 `/personnel`！

你的 `.scp` 包在压缩时，**文件被包在了一个 `test_story/` 文件夹里**。ZIP 内部结构是：

```
test_story/
    manifest.json
    welcome.txt
    personnel/
    ...
```

所以所有文件路径都变成了 `/test_story/personnel`、`/test_story/reports/` 等。

但你的 `manifest.json` 中权限定义的是 `/personnel/`、`/comms/` 这样的路径 [1]。两边不匹配，所以权限检查永远返回 0。

## 解决方案（二选一）

### 方案A：重新打包 .scp（推荐）

打包时不要把外层文件夹包进去。正确做法：

1. **进入** `test_story/` 文件夹**内部**
2. **全选**里面的所有文件和文件夹（manifest.json、welcome.txt、reports/、personnel/ 等）
3. 右键 → 压缩为 ZIP
4. 改后缀为 `.scp`

这样 ZIP 内部结构就是：

```
manifest.json        ← 直接在根目录
welcome.txt
personnel/
reports/
...
```

### 方案B：在代码中自动去除多余前缀

如果你不想重新打包，可以修改 `story_loader.gd` 来自动处理这种情况。

找到 `_clean_zip_path` 函数，**替换为：**

```gdscript
# 清理ZIP内部路径，统一为 /开头 的格式
func _clean_zip_path(zip_path: String) -> String:
	var path: String = zip_path
	# 去除开头的 ./
	if path.begins_with("./"):
		path = path.substr(2)
	# 去除末尾的 /
	path = path.rstrip("/")
	# 确保以 / 开头
	if not path.begins_with("/"):
		path = "/" + path
	return path
```

然后在 `load_story` 函数中 `reader.close()` **之前**，`return true` **之前**，添加去前缀逻辑：

```gdscript
	# 检测并去除多余的顶层文件夹前缀
	# 如果所有路径都以同一个文件夹开头，且该文件夹下有manifest，则去除它
	var common_prefix: String = _detect_root_prefix()
	if not common_prefix.is_empty():
		print("[StoryLoader] 检测到顶层文件夹前缀: " + common_prefix + "，自动去除")
		var new_fs: Dictionary = {}
		for key in file_system.keys():
			var new_key: String = key.substr(common_prefix.length())
			if new_key.is_empty():
				continue
			if not new_key.begins_with("/"):
				new_key = "/" + new_key
			new_fs[new_key] = file_system[key]
		file_system = new_fs
	
	reader.close()
	return true
```

然后在 `_clean_zip_path` 函数**后面**添加：

```gdscript
# 检测是否所有文件都在同一个顶层文件夹下
func _detect_root_prefix() -> String:
	if file_system.is_empty():
		return ""
	
	# 收集所有顶层名称
	var first_parts: Dictionary = {}
	for key in file_system.keys():
		var parts := key.split("/", false)
		if parts.size() > 0:
			first_parts[parts[0]] = true
	
	# 如果只有一个顶层文件夹，且它在file_system中是folder类型
	if first_parts.size() == 1:
		var prefix_name: String = first_parts.keys()[0]
		var prefix_path: String = "/" + prefix_name
		if file_system.has(prefix_path) and file_system[prefix_path].get("type", "") == "folder":
			return prefix_path
	
	return ""
```

---

**建议用方案A重新打包**，简单干净。方案B作为长期兼容方案后续加入。

重新打包后再运行测试，控制台应该会显示 `[PERM] 检查路径: /personnel` 而不是 `/test_story/personnel`。

### USER
我采用了第二种方法，但是有如下报错：
错误 (133, 22)： Cannot infer the type of "parts" variable because the value doesn't have a set type.
我提供story_loader.gd完整代码给你，你仔细检查反馈给我需要修改的地方。
class_name StoryLoader
extends RefCounted
# 加载结果
var file_system: Dictionary = {}
var manifest: Dictionary = {}
var error_message: String = ""
# 从 .scp (ZIP) 文件加载剧本
func load_story(path: String) -> bool:
file_system.clear()
manifest.clear()
error_message = ""
# 打开ZIP文件
var reader := ZIPReader.new()
var err := reader.open(path)
if err != OK:
error_message = "无法打开文件: " + path
return false
# 获取ZIP内所有文件路径
var files := reader.get_files()
# 第一遍：收集所有文件夹路径
var folders: Dictionary = {}
folders["/"] = true
for file_path in files:
# 跳过空路径
if file_path.strip_edges().is_empty():
continue
# 标准化路径：确保以 / 开头
var clean_path: String = _clean_zip_path(file_path)
# 收集所有父级文件夹
var parts := clean_path.split("/", false)
var current := ""
for i in range(parts.size() - 1):
current += "/" + parts[i]
folders[current] = true
# 如果路径本身以 / 结尾，它是文件夹
if file_path.ends_with("/"):
folders[clean_path.rstrip("/")] = true
# 注册所有文件夹
for folder_path in folders.keys():
if folder_path == "/":
continue
file_system[folder_path] = {
"type": "folder"
}
# 第二遍：读取所有文件内容
for file_path in files:
if file_path.strip_edges().is_empty():
continue
if file_path.ends_with("/"):
continue
var clean_path: String = _clean_zip_path(file_path)
# 读取文件内容
var content_bytes := reader.read_file(file_path)
if content_bytes == null:
continue
var content: String = content_bytes.get_string_from_utf8()
# 检查是否是 manifest 文件
var filename: String = clean_path.get_file()
if filename == "manifest.json":
_parse_manifest_json(content)
continue
if filename == "manifest.cfg":
_parse_manifest(content)
continue
# 注册为文件
file_system[clean_path] = {
"type": "file",
"content": content
}
# 检测并去除多余的顶层文件夹前缀
# 如果所有路径都以同一个文件夹开头，且该文件夹下有manifest，则去除它
var common_prefix: String = _detect_root_prefix()
if not common_prefix.is_empty():
print("[StoryLoader] 检测到顶层文件夹前缀: " + common_prefix + "，自动去除")
var new_fs: Dictionary = {}
for key in file_system.keys():
var new_key: String = key.substr(common_prefix.length())
if new_key.is_empty():
continue
if not new_key.begins_with("/"):
new_key = "/" + new_key
new_fs[new_key] = file_system[key]
file_system = new_fs
reader.close()
return true
reader.close()
return true
# 清理ZIP内部路径，统一为 /开头 的格式
func _clean_zip_path(zip_path: String) -> String:
var path: String = zip_path
# 去除开头的 ./
if path.begins_with("./"):
path = path.substr(2)
# 去除末尾的 /
path = path.rstrip("/")
# 确保以 / 开头
if not path.begins_with("/"):
path = "/" + path
return path
# 检测是否所有文件都在同一个顶层文件夹下
func _detect_root_prefix() -> String:
if file_system.is_empty():
return ""
# 收集所有顶层名称
var first_parts: Dictionary = {}
for key in file_system.keys():
var parts := key.split("/", false)
if parts.size() > 0:
first_parts[parts[0]] = true
# 如果只有一个顶层文件夹，且它在file_system中是folder类型
if first_parts.size() == 1:
var prefix_name: String = first_parts.keys()[0]
var prefix_path: String = "/" + prefix_name
if file_system.has(prefix_path) and file_system[prefix_path].get("type", "") == "folder":
return prefix_path
return ""
# 解析 manifest.json
func _parse_manifest_json(content: String) -> void:
var json := JSON.new()
var err := json.parse(content)
if err != OK:
error_message = "manifest.json 解析失败: 第" + str(json.get_error_line()) + "行 " + json.get_error_message()
print("[StoryLoader] " + error_message)
return
if json.data is Dictionary:
manifest = json.data
print("[StoryLoader] manifest.json 已加载")
print("[StoryLoader] 包含字段: " + str(manifest.keys()))
else:
error_message = "manifest.json 格式错误"
print("[StoryLoader] " + error_message)
# 解析 manifest.cfg
func _parse_manifest(content: String) -> void:
var current_section: String = ""
for line in content.split("\n"):
line = line.strip_edges()
# 跳过空行和注释
if line.is_empty() or line.begins_with("#") or line.begins_with(";"):
continue
# 段落标记 [section]
if line.begins_with("[") and line.ends_with("]"):
current_section = line.substr(1, line.length() - 2)
if not manifest.has(current_section):
manifest[current_section] = {}
continue
# 键值对 key=value
var eq_pos: int = line.find("=")
if eq_pos > 0 and not current_section.is_empty():
var key: String = line.substr(0, eq_pos).strip_edges()
var value: String = line.substr(eq_pos + 1).strip_edges()
manifest[current_section][key] = value

### ASSISTANT
我发现了两个问题：

## 问题1：第133行类型推断错误

在 `_detect_root_prefix` 函数中，`key` 是从 `Dictionary.keys()` 遍历出来的，类型是 `Variant`，所以 `key.split()` 返回的类型不确定，Godot 无法推断。

找到 `_detect_root_prefix` 函数中的：

```gdscript
	for key in file_system.keys():
		var parts := key.split("/", false)
```

**替换为：**

```gdscript
	for key in file_system.keys():
		var key_str: String = str(key)
		var parts: PackedStringArray = key_str.split("/", false)
```

## 问题2：重复的 `reader.close()` 和 `return true`

`load_story` 函数末尾有两组重复的 `reader.close()` + `return true`，会导致第二组变成不可达代码。

找到 `load_story` 函数末尾的：

```gdscript
		file_system = new_fs
	
	reader.close()
	return true

	reader.close()
	return true
```

**替换为：**

```gdscript
		file_system = new_fs
	
	reader.close()
	return true
```

删掉重复的那组即可。

---

这两处改完后保存运行，权限系统应该就能正常工作了，因为路径前缀 `/test_story` 会被自动去除，文件路径会变成 `/personnel`、`/comms` 等，和 `manifest.json` 中的权限定义匹配。

### USER
目前存在三个问题，我们最好一步一步解决，你决定哪个更重要就先整哪个：
1.不能同时识别多个.scp包，且无法切换，想办法解决这个问题。
2.密码和权限两个应该是平行的，权限是之后通过事件/触发器赋予；密码是打开特定文件、文档的（例如一个文档要求3级权限的同时要求输入密码）。
3.格式和文字问题：如图，access denied后面和“输入unlock尝试密码认证”接在一起了，本来应当是不同行的；ACCESS GRANTED提示框显示错误，应该学习软件启动时“SCP FOUNDATION TERMINAL”框一样自动调整居中和方框大小；使用锁emoji风格太不搭了，换成文字。
下面我为你提供目前的main.gd所有代码，你仔细检查并帮我解决问题。注意：不要把修改后的代码全部发我，只需把需要修改的部分反馈回来，不然对话会中断。

### ASSISTANT
我建议先解决**问题3（格式和显示问题）**，因为这是最直观影响体验的，而且修改量可控。然后解决**问题2（密码与权限分离）**，最后解决**问题1（多包切换）**。

---

## 第一步：解决问题3 - 格式和显示问题

### 修改1：修复 ACCESS DENIED 换行问题（_cmd_cd）

找到 `_cmd_cd` 中的权限检查部分：

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(new_path)
	if not _has_clearance(new_path):
		append_output("[color=#FF6666][ACCESS DENIED] 权限不足 - 需要等级: " + str(required) + "  当前: " + str(player_clearance) + "[/color]", false)
		append_output("[color=#AAAAAA]输入 unlock 尝试密码认证。[/color]\n", false)
		return
```

**替换为：**

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(new_path)
	if not _has_clearance(new_path):
		append_output("[color=#FF6666][ACCESS DENIED] 权限不足 - 需要等级: " + str(required) + "  当前: " + str(player_clearance) + "[/color]\n[

### USER
目前存在三个问题，我们最好一步一步解决，你决定哪个更重要就先整哪个：  
1.不能同时识别多个.scp包，且无法切换，想办法解决这个问题。  
2.密码和权限两个应该是平行的，权限是之后通过事件/触发器赋予；密码是打开特定文件、文档的（例如一个文档要求3级权限的同时要求输入密码）。  
3.格式和文字问题：如图，access denied后面和“输入unlock尝试密码认证”接在一起了，本来应当是不同行的；ACCESS GRANTED提示框显示错误，应该学习软件启动时“SCP FOUNDATION TERMINAL”框一样自动调整居中和方框大小；使用锁emoji风格太不搭了，换成文字。  
下面我为你提供目前的main.gd所有代码，你仔细检查并帮我解决问题。注意：不要把修改后的代码全部发我，只需把需要修改的部分反馈回来，不然对话会中断。
下面是main.gd代码：
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false
# 打字机效果
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
# 权限系统
var player_clearance: int = 0              # 当前权限等级
var story_permissions: Dictionary = {}      # 路径 -> 所需权限等级
var story_id: String = ""                   # 当前剧本唯一ID
var read_files: Array[String] = []          # 已读文件列表
var unlocked_passwords: Array[String] = []  # 已解锁的密码
# 密码输入弹窗状态
var _password_mode: bool = false            # 是否处于密码输入模式
var _password_target_path: String = ""      # 密码输入针对的路径（空表示通用unlock）
# ============================================================
# 初始化
# ============================================================
# 尝试加载剧本，如果失败则用测试数据
func _ready() -> void:
# 确保stories目录存在
_ensure_stories_dir()
# 尝试加载剧本，如果失败则用测试数据
if not _try_load_story():
_init_test_file_system()
output_text.text = ""
output_text.bbcode_enabled = true
# 启用鼠标选择和交互（为超链接做准备）
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
input_field.focus_mode = Control.FOCUS_ALL
# 阻止Tab键切换焦点，让我们自己处理
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
# 不再用 text_submitted 信号，改为手动监听回车键
input_field.grab_focus()
_update_status_bar()
_show_welcome_message()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 鼠标滚轮滚动
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 点击任意位置聚焦输入框
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
# 点击任何键都确保输入框有焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果正在打字或加载，按空格或ESC跳过动画
if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
_typewriter_instant = true
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
# 如果正在打字，忽略回车（防止干扰）
if _is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
# 如果处于密码输入模式
if _password_mode:
_password_mode = false
input_field.placeholder_text = "> 输入命令..."
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 密码回显用星号
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消密码输入。[/color]\n", false)
return
_verify_password(raw_input)
return
command_history.append(raw_input)
history_index = -1
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 命令回显用即时显示（不走打字机）
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
# 执行命令（命令输出走打字机效果）
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
# 重置打字机为动画模式
_typewriter_instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
_cmd_story_info()
"unlock":
_cmd_unlock(args)
"scan":
await _cmd_scan()
"reboot", "restart":
await _cmd_reboot()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]vdisc[/color]         查看当前载入的虚拟磁盘信息")
lines.append("  [color=#66FF66]scan[/color]          重新扫描虚拟磁盘")
lines.append("  [color=#66FF66]unlock[/color]        进入密码认证（或 unlock <密码>）")
lines.append("  [color=#66FF66]reboot[/color]        重启终端")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
var item_required: int = _get_required_clearance(item_path)
var is_locked: bool = not _has_clearance(item_path)
if node.type == "folder":
if is_locked:
lines.append("  [color=#FF6666][DIR]  " + item + "/  🔒 等级" + str(item_required) + "[/color]")
else:
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
if is_locked:
lines.append("  [color=#FF6666][FILE] " + item + "  🔒 等级" + str(item_required) + "[/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
# 调试输出
print("[DEBUG] cd 目标: " + new_path + " 需要权限: " + str(_get_required_clearance(new_path)) + " 当前权限: " + str(player_clearance))
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(new_path)
if not _has_clearance(new_path):
append_output("[color=#FF6666][ACCESS DENIED] 权限不足 - 需要等级: " + str(required) + "  当前: " + str(player_clearance) + "[/color]", false)
append_output("[color=#AAAAAA]输入 unlock 尝试密码认证。[/color]\n", false)
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
# 调试输出
print("[DEBUG] open 目标: " + file_path + " 需要权限: " + str(_get_required_clearance(file_path)) + " 当前权限: " + str(player_clearance))
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(file_path)
if not _has_clearance(file_path):
append_output("[color=#FF6666]╔══════════════════════════════════════╗[/color]", false)
append_output("[color=#FF6666]║  [ACCESS DENIED] 权限不足    ║[/color]", false)
append_output("[color=#FF6666]║  需要等级: " + str(required) + "  当前等级: " + str(player_clearance) + "    ║[/color]", false)
append_output("[color=#FF6666]╠══════════════════════════════════════╣[/color]", false)
append_output("[color=#FF6666]║  输入 unlock 尝试密码认证    ║[/color]", false)
append_output("[color=#FF6666]╚══════════════════════════════════════╝[/color]\n", false)
return
# 先等待打字队列全部完成
while _is_typing:
await get_tree().process_frame
# 显示进度条（直接操作output_text，不走打字队列）
var content_size: int = node.content.length()
await _show_progress_bar(content_size)
# 进度条完成后等待一小会
await get_tree().create_timer(0.5).timeout
# 清屏进入阅读模式
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
# 显示文件头
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
# 记录已读
if not read_files.has(file_path):
read_files.append(file_path)
_auto_save()
# 显示文件内容（走打字机，不加额外空行）
# 清理内容：去除首尾空白，统一换行符为\n
var clean_content: String = node.content.strip_edges()
clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
append_output(clean_content, false)
# 文件尾放入队列，等内容打完后显示
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名: [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]" + str(player_clearance) + "[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
if not story_id.is_empty():
lines.append("  剧本ID: [color=#AAAAAA]" + story_id + "[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后重启终端。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 虚拟磁盘信息 ═══════════[/color]")
if story_manifest.has("story"):
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签:   [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者: [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本:    [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述:    [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数:   [color=#66FF66]" + str(file_system.size()) + "[/color]")
lines.append("  磁盘来源:   [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态:   [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_unlock(args: Array) -> void:
# 如果带了参数，直接验证（兼容旧用法）
if not args.is_empty():
_verify_password(args[0])
return
# 无参数，进入密码输入模式
_enter_password_mode()
func _enter_password_mode(target_path: String = "") -> void:
_password_mode = true
_password_target_path = target_path
var lines: Array[String] = []
lines.append("[color=#FFB000]╔══════════════════════════════════════╗[/color]")
lines.append("[color=#FFB000]║ SECURITY AUTHENTICATION ║[/color]")
lines.append("[color=#FFB000]║ 安全认证系统 ║[/color]")
lines.append("[color=#FFB000]╠══════════════════════════════════════╣[/color]")
lines.append("[color=#FFB000]║  请输入访问密码: ║[/color]")
lines.append("[color=#FFB000]║  (输入 cancel 取消) ║[/color]")
lines.append("[color=#FFB000]╚══════════════════════════════════════╝[/color]")
append_output("\n".join(lines) + "\n", false)
# 修改输入框提示
input_field.placeholder_text = "输入密码..."
func _verify_password(password: String) -> void:
# 从manifest中查找密码
if not story_manifest.has("passwords"):
append_output("[color=#FF6666][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
return
var passwords: Dictionary = story_manifest["passwords"]
if passwords.has(password):
var pwd_info: Dictionary = passwords[password]
var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
if unlocked_passwords.has(password):
append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(player_clearance) + "[/color]\n", false)
return
if grant_level <= player_clearance:
append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。当前: " + str(player_clearance) + "[/color]\n", false)
return
# 解锁成功
unlocked_passwords.append(password)
var old_level: int = player_clearance
player_clearance = grant_level
_auto_save()
# 成功动画
append_output("[color=#33FF33]╔══════════════════════════════════════╗[/color]", false)
append_output("[color=#33FF33]║    ACCESS GRANTED ║[/color]", false)
append_output("[color=#33FF33]║    权限认证通过   ║[/color]", false)
append_output("[color=#33FF33]╠══════════════════════════════════════╣[/color]", false)
append_output("[color=#33FF33]║  权限等级: " + str(old_level) + " → " + str(player_clearance) + "    ║[/color]", false)
append_output("[color=#33FF33]╚══════════════════════════════════════╝[/color]\n", false)
# 显示提示信息（如果有）
if pwd_info.has("message"):
append_output("[color=#AAAAAA]" + str(pwd_info["message"]) + "[/color]\n", false)
else:
append_output("[color=#FF6666]╔══════════════════════════════════════╗[/color]", false)
append_output("[color=#FF6666]║    ACCESS DENIED ║[/color]", false)
append_output("[color=#FF6666]║    密码验证失败   ║[/color]", false)
append_output("[color=#FF6666]╚══════════════════════════════════════╝[/color]\n", false)
func _cmd_scan() -> void:
append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
# 显示扫描进度条
await _show_progress_bar(500)
await get_tree().create_timer(0.3).timeout
# 保存旧状态用于对比
var old_story_path: String = current_story_path
var old_manifest: Dictionary = story_manifest.duplicate()
# 重置文件系统和权限
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
# 重新扫描
if _try_load_story():
var title: String = "未知"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
if current_story_path == old_story_path:
append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]\n", false)
else:
append_output("[color=#33FF33][OK] 发现并加载新剧本: " + title + "[/color]\n", false)
append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "[/color]\n", false)
append_output("[color=#AAAAAA]权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
append_output("[color=#AAAAAA]当前权限等级: " + str(player_clearance) + "[/color]\n", false)
# 重置到起始路径
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
else:
current_path = "/"
_update_status_bar()
append_output("[color=#AAAAAA]当前路径已重置为: " + current_path + "[/color]\n", false)
else:
_init_test_file_system()
current_path = "/"
_update_status_bar()
append_output("[color=#FFB000][WARN] 未找到剧本文件，已加载内置测试数据。[/color]", false)
append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
func _cmd_reboot() -> void:
append_output("[color=#AAAAAA]正在重启终端...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 清空所有状态
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
command_history.clear()
history_index = -1
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
current_path = "/"
has_new_mail = false
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
# 重新加载
_ensure_stories_dir()
if not _try_load_story():
_init_test_file_system()
_update_status_bar()
# 模拟重启效果
output_text.append_text("[color=#AAAAAA]...[/color]\n")
await get_tree().create_timer(0.3).timeout
output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
await get_tree().create_timer(0.5).timeout
output_text.text = ""
# 重新显示欢迎信息
_show_welcome_message()
input_field.grab_focus()
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
# 只输入了一个词：补全命令
if parts.size() == 1:
# 检查是否已经是完整命令，后面有空格表示要补全参数
if current_text.ends_with(" "):
# 命令已输入完，补全文件名（无前缀匹配，列出所有）
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只补全文件夹，open/cat只补全文件
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
_do_scroll()
else:
# 补全命令名
var partial_cmd: String = parts[0].to_lower()
var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
"scan", "reboot", "restart", "unlock"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 两个词：命令 + 部分文件名
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只匹配文件夹，open/cat只匹配文件
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
# 找公共前缀，补全到最长公共部分
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 查找多个字符串的最长公共前缀
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
if not _is_typing:
_process_typewriter_queue()
func _process_typewriter_queue() -> void:
if _typewriter_queue.is_empty():
_is_typing = false
return
_is_typing = true
var entry = _typewriter_queue.pop_front()
var text: String = entry["text"]
var extra_newline: bool = entry["extra_newline"]
if _typewriter_instant:
output_text.append_text(text)
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
else:
_typewrite_text(text, extra_newline)
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
var i: int = 0
var length: int = text.length()
_current_char_speed = _typewriter_speed
while i < length:
# 如果中途切换为即时模式，把剩余文本一次性输出
if _typewriter_instant:
output_text.append_text(text.substr(i))
break
# 检查是否是BBCode标签
if text[i] == "[":
var close_bracket: int = text.find("]", i)
if close_bracket != -1:
var tag: String = text.substr(i, close_bracket - i + 1)
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 判断是否是合法的BBCode标签（以字母或/开头）
var tag_inner: String = tag.substr(1, tag.length() - 2)
if tag_inner.length() > 0 and (tag_inner[0] == "/" or tag_inner[0].unicode_at(0) >= 65 and tag_inner[0].unicode_at(0) <= 122):
# 看起来像BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 不是BBCode标签，转义方括号后逐字输出
output_text.append_text("[lb]")
i += 1
continue
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 普通BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 普通字符
var ch: String = text[i]
# 换行符不单独append，而是收集连续的换行一次性输出
if ch == "\n":
var newlines: String = "\n"
i += 1
while i < length and text[i] == "\n":
newlines += "\n"
i += 1
output_text.append_text(newlines)
# 换行后的停顿
if not _typewriter_instant:
await get_tree().create_timer(_typewriter_period_pause).timeout
_do_scroll()
continue
output_text.append_text(ch)
i += 1
# 根据字符类型决定延迟
var delay: float = _current_char_speed
# 标点符号额外停顿（制造顿挫感）
if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
delay += _typewriter_period_pause
elif ch in ["、", "—", "-", "…"]:
delay += _typewriter_comma_pause
else:
# 随机顿挫：有一定概率额外停顿
if randf() < _typewriter_pause_chance:
delay += _typewriter_pause_duration
await get_tree().create_timer(delay).timeout
# 每隔几个字符滚动一次
if i % 8 == 0:
_do_scroll()
# 当前文本打完
if extra_newline:
output_text.append_text("\n")
_do_scroll()
# 继续处理队列
_process_typewriter_queue()
func _do_scroll() -> void:
_needs_scroll = true
func _process(_delta: float) -> void:
if _needs_scroll:
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
scroll_container.scroll_vertical = int(v_scroll.max_value)
_needs_scroll = false
# 显示文件加载进度条
# file_size: 文件内容长度，影响进度条速度
# speed_override: 速度倍率覆盖，-1表示用默认
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
var bar_width: int = 30  # 进度条总长度（字符数）
var speed: float = _progress_bar_speed
if speed_override > 0.0:
speed = speed_override
# 文件越大，每格停顿越长（但有上下限）
var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
base_delay /= speed
# 起始行
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("[color=#66FF66]加载中 [[/color]")
for i in range(bar_width):
if _typewriter_instant:
# 跳过动画，直接填满
var remaining: int = bar_width - i
output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
break
output_text.append_text("[color=#33FF33]█[/color]")
_do_scroll()
# 随机波动让进度条不匀速，更真实
var jitter: float = randf_range(0.7, 1.5)
await get_tree().create_timer(base_delay * jitter).timeout
output_text.append_text("[color=#66FF66]] 完成[/color]\n")
_do_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
path_label.text = "[" + current_path + "]  LV:" + str(player_clearance)
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
# 处理RichTextLabel中的超链接点击
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
# 如果是命令链接，直接执行
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
# 如果是文件链接，打开文件
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
# 计算框的宽度：取较长的那行，两侧各留3个空格
var max_len: int = max(title.length(), subtitle.length())
# 中英文混排时，中文字符占2个宽度，英文占1个
var title_display_len: int = _display_width(title)
var subtitle_display_len: int = _display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
# 居中填充
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func _display_width(text: String) -> int:
var width: int = 0
for ch in text:
var code: int = ch.unicode_at(0)
if code >= 0x4E00 and code <= 0x9FFF:
width += 2  # CJK统一汉字
elif code >= 0x3000 and code <= 0x303F:
width += 2  # CJK标点
elif code >= 0xFF00 and code <= 0xFFEF:
width += 2  # 全角字符
else:
width += 1
return width
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
# 检查路径是否需要权限，返回所需等级（0表示无需权限）
func _get_required_clearance(path: String) -> int:
path = _normalize_path(path)
var highest: int = 0
print("[PERM] 检查路径: " + path)
for perm_path in story_permissions.keys():
var perm_value: int = int(float(story_permissions[perm_path]))
var normalized_perm: String = _normalize_path(perm_path)
# 精确匹配
if path == normalized_perm:
print("[PERM] 精确匹配: " + perm_path + " = " + str(perm_value))
highest = max(highest, perm_value)
continue
# 目录前缀匹配：检查path是否在该目录下
var dir_prefix: String = normalized_perm + "/"
if path.begins_with(dir_prefix):
print("[PERM] 目录匹配: " + perm_path + " = " + str(perm_value))
highest = max(highest, perm_value)
print("[PERM] 最终权限要求: " + str(highest))
return highest
# 检查玩家是否有权限访问该路径
func _has_clearance(path: String) -> bool:
return player_clearance >= _get_required_clearance(path)
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
var content: String = entry.get("content", "")
# 统一换行符，防止\r\n导致双倍行距
content = content.replace("\r\n", "\n").replace("\r", "\n")
return FSNode.new(entry.get("type", "file"), content)
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 存档读档功能
# ============================================================
func _get_save_path() -> String:
return _get_game_root_dir() + "saves/save_" + story_id + ".json"
func _auto_save() -> void:
if story_id.is_empty():
return
# 确保存档目录存在
var save_dir: String = _get_game_root_dir() + "saves/"
if not DirAccess.dir_exists_absolute(save_dir):
var err := DirAccess.make_dir_absolute(save_dir)
if err == OK:
print("[Save] 已创建存档目录: " + save_dir)
else:
print("[Save] 创建存档目录失败: " + str(err))
return
var save_data: Dictionary = {
"story_id": story_id,
"player_clearance": player_clearance,
"read_files": read_files,
"unlocked_passwords": unlocked_passwords,
"current_path": current_path
}
var save_path: String = _get_save_path()
print("[Save] 存档路径: " + save_path)
var file := FileAccess.open(save_path, FileAccess.WRITE)
if file:
file.store_string(JSON.stringify(save_data, "\t"))
file.close()
print("[Save] 已保存: " + _get_save_path())
func _load_save() -> bool:
var path: String = _get_save_path()
print("[Save] 尝试加载存档: " + path)
if not FileAccess.file_exists(path):
print("[Save] 存档不存在，使用默认设置")
return false
var file := FileAccess.open(path, FileAccess.READ)
if file == null:
return false
var json_text: String = file.get_as_text()
file.close()
var json := JSON.new()
if json.parse(json_text) != OK:
return false
var data: Dictionary = json.data
if data.get("story_id", "") != story_id:
return false
player_clearance = int(data.get("player_clearance", 0))
read_files.clear()
if data.has("read_files"):
for f in data["read_files"]:
read_files.append(str(f))
unlocked_passwords.clear()
if data.has("unlocked_passwords"):
for p in data["unlocked_passwords"]:
unlocked_passwords.append(str(p))
if data.has("current_path"):
var saved_path: String = data["current_path"]
# 验证存档路径是否有权限访问，没有则重置到起始路径
if _has_clearance(saved_path):
current_path = saved_path
else:
current_path = "/"
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
print("[Save] 已加载存档: " + path)
print("[Save] 权限等级: " + str(player_clearance))
return true
# 获取游戏根目录（编辑器中为项目目录，导出后为exe所在目录）
func _get_game_root_dir() -> String:
if OS.has_feature("editor"):
return ProjectSettings.globalize_path("res://")
else:
return OS.get_executable_path().get_base_dir() + "/"
func _ensure_stories_dir() -> void:
var vdisc_path: String = _get_game_root_dir() + "vdisc/"
if not DirAccess.dir_exists_absolute(vdisc_path):
var err := DirAccess.make_dir_absolute(vdisc_path)
if err == OK:
print("[StoryLoader] 已创建vdisc目录: " + vdisc_path)
else:
print("[StoryLoader] 创建vdisc目录失败: " + str(err))
else:
print("[StoryLoader] vdisc目录已存在: " + vdisc_path)
# 尝试从 vdisc 目录加载第一个 .scp 文件
func _try_load_story() -> bool:
var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
print("[StoryLoader] 搜索目录: " + vdisc_dir)
if _try_load_from_dir(vdisc_dir):
return true
print("[StoryLoader] 未找到剧本文件，使用测试数据")
return false
func _try_load_from_dir(stories_dir: String) -> bool:
if not DirAccess.dir_exists_absolute(stories_dir):
return false
var dir := DirAccess.open(stories_dir)
if dir == null:
return false
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = stories_dir + file_name
print("[StoryLoader] 发现剧本: " + full_path)
return _load_story_file(full_path)
file_name = dir.get_next()
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据
file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 读取剧本ID
if story_manifest.has("story") and story_manifest["story"].has("id"):
story_id = story_manifest["story"]["id"]
else:
# 没有id就用文件名的哈希作为id
story_id = str(path.get_file().hash())
# 读取权限表
story_permissions.clear()
if story_manifest.has("permissions"):
var perms: Dictionary = story_manifest["permissions"]
for perm_path in perms.keys():
story_permissions[perm_path] = int(perms[perm_path])
print("[StoryLoader] 权限表已加载，共 " + str(story_permissions.size()) + " 条规则")
else:
print("[StoryLoader] 警告: manifest中未找到permissions字段")
if story_manifest.has("passwords"):
print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
else:
print("[StoryLoader] 警告: manifest中未找到passwords字段")
# 应用 manifest 中的设置
var start_clearance: int = 0
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
_typewriter_speed = settings["typing_speed"].to_float()
if settings.has("start_clearance"):
start_clearance = int(settings["start_clearance"])
# 尝试加载该剧本的存档
if not _load_save():
# 没有存档，用初始权限
player_clearance = start_clearance
read_files.clear()
unlocked_passwords.clear()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 剧本ID: " + story_id)
print("[StoryLoader] 文件数量: " + str(file_system.size()))
print("[StoryLoader] 权限等级: " + str(player_clearance))
print("[StoryLoader] story_permissions 内容: " + str(story_permissions))
print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
return true
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
我按优先级先解决**问题3（格式显示问题）**，因为这是最直观的体验问题。

---

## 问题3 修复：格式和显示

### 修改1：添加通用的自适应方框生成函数

在 `_display_width` 函数**后面**添加：

```gdscript
# 生成自适应宽度的文本框
# lines_data: 每行文本内容（纯文本，不含颜色标签）
# color: 框的颜色代码（如 #33FF33）
# 返回带BBCode的完整框字符串
func _build_box(lines_data: Array[String], color: String) -> String:
	# 计算最宽行的显示宽度
	var max_width: int = 0
	for line in lines_data:
		var w: int = _display_width(line)
		if w > max_width:
			max_width = w
	
	# 内部宽度 = 最宽行 + 左右各2个空格padding
	var inner_width: int = max_width + 4
	var border_h: String = "═".repeat(inner_width)
	
	var result: String = ""
	result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
	
	for i in range(lines_data.size()):
		var line: String = lines_data[i]
		var line_width: int = _display_width(line)
		var pad_total: int = inner_width - line_width
		var pad_left: int = pad_total / 2
		var pad_right: int = pad_total - pad_left
		result += "[color=" + color + "]║" + " ".repeat(pad_left) + line + " ".repeat(pad_right) + "║[/color]\n"
		
		# 如果不是最后一行，且下一行是分隔线标记，插入中间分隔
		# 用特殊标记 "---" 表示需要插入分隔线
	
	result += "[color=" + color + "]╚" + border_h + "╝[/color]"
	return result

# 生成带中间分隔线的自适应方框
# sections: 二维数组，每个元素是一组行文本，组之间用分隔线隔开
func _build_box_sectioned(sections: Array, color: String) -> String:
	# 计算所有行中最宽的显示宽度
	var max_width: int = 0
	for section in sections:
		for line in section:
			var w: int = _display_width(str(line))
			if w > max_width:
				max_width = w
	
	var inner_width: int = max_width + 4
	var border_h: String = "═".repeat(inner_width)
	var divider_h: String = "═".repeat(inner_width)
	
	var result: String = ""
	result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
	
	for s_idx in range(sections.size()):
		var section: Array = sections[s_idx]
		for line in section:
			var line_str: String = str(line)
			var line_width: int = _display_width(line_str)
			var pad_total: int = inner_width - line_width
			var pad_left: int = pad_total / 2
			var pad_right: int = pad_total - pad_left
			result += "[color=" + color + "]║" + " ".repeat(pad_left) + line_str + " ".repeat(pad_right) + "║[/color]\n"
		
		# 在 section 之间插入分隔线（最后一组不加）
		if s_idx < sections.size() - 1:
			result += "[color=" + color + "]╠" + divider_h + "╣[/color]\n"
	
	result += "[color=" + color + "]╚" + border_h + "╝[/color]"
	return result
```

### 修改2：修复 `_cmd_cd` 中 ACCESS DENIED 换行问题

找到 `_cmd_cd` 中的：

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(new_path)
	if not _has_clearance(new_path):
		append_output("[color=#FF6666][ACCESS DENIED] 权限不足 - 需要等级: " + str(required) + "  当前: " + str(player_clearance) + "[/color]", false)
		append_output("[color=#AAAAAA]输入 unlock 尝试密码认证。[/color]\n", false)
		return
```

**替换为：**

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(new_path)
	if not _has_clearance(new_path):
		var box: String = _build_box_sectioned([
			["ACCESS DENIED", "权限不足"],
			["需要等级: " + str(required) + "  当前等级: " + str(player_clearance)],
			["输入 unlock 尝试密码认证"]
		], "#FF6666")
		append_output(box + "\n", false)
		return
```

### 修改3：修复 `_cmd_open` 中 ACCESS DENIED 框

找到 `_cmd_open` 中的：

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(file_path)
	if not _has_clearance(file_path):
		append_output("[color=#FF6666]╔══════════════════════════════════════╗[/color]", false)
		append_output("[color=#FF6666]║  [ACCESS DENIED] 权限不足    ║[/color]", false)
		append_output("[color=#FF6666]║  需要等级: " + str(required) + "  当前等级: " + str(player_clearance) + "    ║[/color]", false)
		append_output("[color=#FF6666]╠══════════════════════════════════════╣[/color]", false)
		append_output("[color=#FF6666]║  输入 unlock 尝试密码认证    ║[/color]", false)
		append_output("[color=#FF6666]╚══════════════════════════════════════╝[/color]\n", false)
		return
```

**替换为：**

```gdscript
	# 权限检查
	var required: int = _get_required_clearance(file_path)
	if not _has_clearance(file_path):
		var box: String = _build_box_sectioned([
			["ACCESS DENIED", "权限不足"],
			["需要等级: " + str(required) + "  当前等级: " + str(player_clearance)],
			["输入 unlock 尝试密码认证"]
		], "#FF6666")
		append_output(box + "\n", false)
		return
```

### 修改4：修复 `_verify_password` 中的 ACCESS GRANTED 和 ACCESS DENIED 框

找到 `_verify_password` 函数中解锁成功的部分：

```gdscript
		# 成功动画
		append_output("[color=#33FF33]╔══════════════════════════════════════╗[/color]", false)
		append_output("[color=#33FF33]║    ACCESS GRANTED ║[/color]", false)
		append_output("[color=#33FF33]║    权限认证通过   ║[/color]", false)
		append_output("[color=#33FF33]╠══════════════════════════════════════╣[/color]", false)
		append_output("[color=#33FF33]║  权限等级: " + str(old_level) + " → " + str(player_clearance) + "    ║[/color]", false)
		append_output("[color=#33FF33]╚══════════════════════════════════════╝[/color]\n", false)
```

**替换为：**

```gdscript
		# 成功动画
		var box: String = _build_box_sectioned([
			["ACCESS GRANTED", "权限认证通过"],
			["权限等级: " + str(old_level) + " -> " + str(player_clearance)]
		], "#33FF33")
		append_output(box + "\n", false)
```

找到同一函数中密码验证失败的部分：

```gdscript
	else:
		append_output("[color=#FF6666]╔══════════════════════════════════════╗[/color]", false)
		append_output("[color=#FF6666]║    ACCESS DENIED ║[/color]", false)
		append_output("[color=#FF6666]║    密码验证失败   ║[/color]", false)
		append_output("[color=#FF6666]╚══════════════════════════════════════╝[/color]\n", false)
```

**替换为：**

```gdscript
	else:
		var box: String = _build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], "#FF6666")
		append_output(box + "\n", false)
```

### 修改5：修复 `_enter_password_mode` 中的框

找到 `_enter_password_mode` 函数中的：

```gdscript
	var lines: Array[String] = []
	lines.append("[color=#FFB000]╔══════════════════════════════════════╗[/color]")
	lines.append("[color=#FFB000]║ SECURITY AUTHENTICATION ║[/color]")
	lines.append("[color=#FFB000]║ 安全认证系统 ║[/color]")
	lines.append("[color=#FFB000]╠══════════════════════════════════════╣[/color]")
	lines.append("[color=#FFB000]║  请输入访问密码: ║[/color]")
	lines.append("[color=#FFB000]║  (输入 cancel 取消) ║[/color]")
	lines.append("[color=#FFB000]╚══════════════════════════════════════╝[/color]")
	append_output("\n".join(lines) + "\n", false)
```

**替换为：**

```gdscript
	var box: String = _build_box_sectioned([
		["SECURITY AUTHENTICATION", "安全认证系统"],
		["请输入访问密码:", "(输入 cancel 取消)"]
	], "#FFB000")
	append_output(box + "\n", false)
```

### 修改6：`_cmd_ls` 中替换锁emoji为文字

找到 `_cmd_ls` 中的四处 `🔒`：

```gdscript
				lines.append("  [color=#FF6666][DIR]  " + item + "/  🔒 等级" + str(item_required) + "[/color]")
```

和：

```gdscript
				lines.append("  [color=#FF6666][FILE] " + item + "  🔒 等级" + str(item_required) + "[/color]")
```

**替换为：**

```gdscript
				lines.append("  [color=#FF6666][DIR]  " + item + "/  [LOCKED LV." + str(item_required) + "][/color]")
```

和：

```gdscript
				lines.append("  [color=#FF6666][FILE] " + item + "  [LOCKED LV." + str(item_required) + "][/color]")
```

### 修改7：移除 `_get_required_clearance` 中的调试输出

找到 `_get_required_clearance` 函数中的所有 `print("[PERM]` 行（共4行），**全部删除**或注释掉：

```gdscript
	print("[PERM] 检查路径: " + path)
```

```gdscript
			print("[PERM] 精确匹配: " + perm_path + " = " + str(perm_value))
```

```gdscript
			print("[PERM] 目录匹配: " + perm_path + " = " + str(perm_value))
```

```gdscript
	print("[PERM] 最终权限要求: " + str(highest))
```

同样删除 `_cmd_cd` 和 `_cmd_open` 中的 `print("[DEBUG]` 行。

---

这些改完后保存运行测试。方框会自动根据内容宽度调整大小并居中对齐，锁emoji也替换成了文字标记。确认效果没问题后我们接着处理问题2（密码与权限分离）。

### USER
改完了，下面处理问题2

### ASSISTANT
好的，现在处理**问题2：密码与权限分离**。

## 设计思路

当前的 `manifest.json` 中 `passwords` 的作用是输入密码→提升权限等级。我们需要改为：

- **权限（clearance）**：数字等级，通过事件/触发器赋予（未来实现），或通过特定密码提升
- **文件密码（file_passwords）**：独立于权限，某些文件需要输入特定密码才能打开，即使权限足够也需要密码

### manifest.json 新结构

```json
{
    "passwords": {
        "omega7": {
            "grants_clearance": 2,
            "message": "权限已提升"
        }
    },
    "file_passwords": {
        "/reports/incident_0117.txt": {
            "password": "bright173",
            "hint": "Dr.Bright最常接触的SCP编号"
        },
        "/classified/overseer_memo.txt": {
            "password": "wearethelight",
            "hint": "我们是..."
        }
    }
}
```

- `passwords`：保持不变，用于 `unlock` 命令提升权限等级 [1]
- `file_passwords`：新增，路径→密码映射，打开文件时如果权限够但有文件密码，弹出密码输入

---

## main.gd 修改

### 修改1：添加文件密码相关变量

找到：

```gdscript
var _password_mode: bool = false            # 是否处于密码输入模式
var _password_target_path: String = ""      # 密码输入针对的路径（空表示通用unlock）
```

**替换为：**

```gdscript
# 密码输入弹窗状态
var _password_mode: bool = false            # 是否处于密码输入模式（unlock用）
var _password_target_path: String = ""      # 密码输入针对的路径（空表示通用unlock）

# 文件密码系统
var _file_password_mode: bool = false       # 是否处于文件密码输入模式
var _file_password_target: String = ""      # 当前等待密码的文件路径
var _file_password_filename: String = ""    # 当前等待密码的文件名（用于显示）
var story_file_passwords: Dictionary = {}   # 路径 -> {password, hint}
var unlocked_file_passwords: Array[String] = []  # 已解锁的文件路径列表
```

### 修改2：在 `_load_story_file` 中加载文件密码表

找到 `_load_story_file` 中的：

```gdscript
	if story_manifest.has("passwords"):
		print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
	else:
		print("[StoryLoader] 警告: manifest中未找到passwords字段")
```

在它**后面**添加：

```gdscript
	# 读取文件密码表
	story_file_passwords.clear()
	if story_manifest.has("file_passwords"):
		var fps: Dictionary = story_manifest["file_passwords"]
		for fp_path in fps.keys():
			story_file_passwords[fp_path] = fps[fp_path]
		print("[StoryLoader] 文件密码表已加载，共 " + str(story_file_passwords.size()) + " 条")
	else:
		print("[StoryLoader] 未配置文件密码表（file_passwords）")
```

### 修改3：在 `_load_save` 中加载已解锁的文件密码

找到 `_load_save` 中的：

```gdscript
	unlocked_passwords.clear()
	if data.has("unlocked_passwords"):
		for p in data["unlocked_passwords"]:
			unlocked_passwords.append(str(p))
```

在它**后面**添加：

```gdscript
	unlocked_file_passwords.clear()
	if data.has("unlocked_file_passwords"):
		for p in data["unlocked_file_passwords"]:
			unlocked_file_passwords.append(str(p))
```

### 修改4：在 `_auto_save` 中保存已解锁的文件密码

找到 `_auto_save` 中的：

```gdscript
	var save_data: Dictionary = {
		"story_id": story_id,
		"player_clearance": player_clearance,
		"read_files": read_files,
		"unlocked_passwords": unlocked_passwords,
		"current_path": current_path
	}
```

**替换为：**

```gdscript
	var save_data: Dictionary = {
		"story_id": story_id,
		"player_clearance": player_clearance,
		"read_files": read_files,
		"unlocked_passwords": unlocked_passwords,
		"unlocked_file_passwords": unlocked_file_passwords,
		"current_path": current_path
	}
```

### 修改5：修改 `_cmd_open` 添加文件密码检查

找到 `_cmd_open` 中权限检查通过之后、进度条之前的位置。也就是找到：

```gdscript
	# 先等待打字队列全部完成
	while _is_typing:
		await get_tree().process_frame
	
	# 显示进度条（直接操作output_text，不走打字队列）
```

在 `# 先等待打字队列全部完成` 这行**前面**插入：

```gdscript
	# 文件密码检查（独立于权限等级）
	var fp_key: String = _get_file_password_key(file_path)
	if not fp_key.is_empty() and not unlocked_file_passwords.has(file_path):
		# 需要文件密码且尚未解锁
		var fp_info: Dictionary = story_file_passwords[fp_key]
		var hint_text: String = fp_info.get("hint", "")
		var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
		if not hint_text.is_empty():
			box_lines.append(["提示: " + hint_text])
		box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
		var box: String = _build_box_sectioned(box_lines, "#FFB000")
		append_output(box + "\n", false)
		
		# 进入文件密码输入模式
		_file_password_mode = true
		_file_password_target = file_path
		_file_password_filename = filename
		input_field.placeholder_text = "输入文件密码..."
		return

```

### 修改6：添加文件密码检查辅助函数

在 `_has_clearance` 函数**后面**添加：

```gdscript
# 检查文件是否需要密码，返回对应的密码表key（空字符串表示不需要）
func _get_file_password_key(file_path: String) -> String:
	file_path = _normalize_path(file_path)
	# 精确匹配
	for fp_path in story_file_passwords.keys():
		var normalized_fp: String = _normalize_path(fp_path)
		if file_path == normalized_fp:
			return fp_path
	return ""

# 验证文件密码
func _verify_file_password(input_password: String) -> void:
	var fp_key: String = _get_file_password_key(_file_password_target)
	if fp_key.is_empty():
		append_output("[color=#FF6666][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
		return
	
	var fp_info: Dictionary = story_file_passwords[fp_key]
	var correct_password: String = str(fp_info.get("password", ""))
	
	if input_password == correct_password:
		# 密码正确
		unlocked_file_passwords.append(_file_password_target)
		_auto_save()
		
		var box: String = _build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], "#33FF33")
		append_output(box + "\n", false)
		
		# 等打字完成后自动打开文件
		while _is_typing:
			await get_tree().process_frame
		await get_tree().create_timer(0.5).timeout
		
		# 重新执行打开文件
		await _cmd_open([_file_password_filename])
	else:
		var box: String = _build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], "#FF6666")
		append_output(box + "\n", false)
```

### 修改7：在 `_on_command_submitted` 中处理文件密码模式

找到 `_on_command_submitted` 函数中的：

```gdscript
	# 如果处于密码输入模式
	if _password_mode:
```

在这个 `if` 块**前面**插入：

```gdscript
	# 如果处于文件密码输入模式
	if _file_password_mode:
		_file_password_mode = false
		input_field.placeholder_text = "> 输入命令..."
		
		# 等待打字队列完成
		while _is_typing:
			await get_tree().process_frame
		
		# 密码回显用星号
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
		
		if raw_input.to_lower() == "cancel":
			append_output("[color=#AAAAAA]已取消文件密码输入。[/color]\n", false)
			_file_password_target = ""
			_file_password_filename = ""
			return
		
		await _verify_file_password(raw_input)
		return
	
```

### 修改8：在 `_cmd_scan` 和 `_cmd_reboot` 中重置文件密码状态

找到 `_cmd_scan` 中的：

```gdscript
	unlocked_passwords.clear()
```

在它**后面**添加：

```gdscript
	unlocked_file_passwords.clear()
	story_file_passwords.clear()
```

找到 `_cmd_reboot` 中的：

```gdscript
	unlocked_passwords.clear()
```

在它**后面**添加：

```gdscript
	unlocked_file_passwords.clear()
	story_file_passwords.clear()
```

### 修改9：在 `_cmd_ls` 中显示文件密码标记

找到 `_cmd_ls` 中已有的文件未锁定的显示行：

```gdscript
			else:
				lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
```

**替换为：**

```gdscript
			else:
				# 检查是否需要文件密码
				var fp_key: String = _get_file_password_key(item_path)
				if not fp_key.is_empty() and not unlocked_file_passwords.has(item_path):
					lines.append("  [color=#FFB000][FILE] " + item + "  [PASSWORD][/color]")
				else:
					lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
```

### 修改10：在 `_cmd_status` 中显示文件密码信息

找到 `_cmd_status` 中的：

```gdscript
	lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
```

在它**后面**添加：

```gdscript
	lines.append("  已解锁文件: [color=#66FF66]" + str(unlocked_file_passwords.size()) + "[/color]")
```

---

## manifest.json 测试数据

更新你的 `manifest.json`，在现有的 `passwords` 之后添加 `file_passwords` 字段：

```json
{
    "story": { ... },
    "settings": { ... },
    "permissions": { ... },
    "passwords": { ... },
    "file_passwords": {
        "/reports/incident_0117.txt": {
            "password": "0117alpha",
            "hint": "事故编号+最先响应的小队代号"
        },
        "/classified/overseer_memo.txt": {
            "password": "wearethelight",
            "hint": "O5议会的信条"
        }
    }
}
```

---

## 总结

| 修改 | 作用 |
|------|------|
| 新变量 | 文件密码状态和数据 |
| `_load_story_file` | 加载 `file_passwords` 表 |
| `_auto_save` / `_load_save` | 持久化已解锁的文件密码 |
| `_cmd_open` | 权限通过后额外检查文件密码 |
| `_on_command_submitted` | 处理文件密码输入模式 |
| `_cmd_ls` | 显示 `[PASSWORD]` 标记 |
| 辅助函数 | `_get_file_password_key` 和 `_verify_file_password` |

改完后运行，打开一个有文件密码的文件应该会弹出密码输入框，输入正确密码后自动打开文件。

### USER
目前manifest.json的代码如下，你帮我整合一下，然后开始着手解决如何同时显示多个.scp包。
{
    "story": {
        "id": "site19_incident_0117",
        "title": "Site-19 事故调查",
        "author": "SCRT测试",
        "version": "1.0",
        "description": "2024年1月17日，Site-19发生了一起不明事故。你被授权接入终端系统展开调查。"
    },
    "settings": {
        "start_path": "/",
        "start_clearance": 0
    },
    "permissions": {
        "/personnel/": 1,
        "/comms/": 2,
        "/reports/incident_0117.txt": 2,
        "/reports/scp_682.txt": 3,
        "/classified/": 4,
        "/classified/overseer_memo.txt": 5
    },
    "passwords": {
        "bright963": {
            "grants_clearance": 1,
            "message": "一级权限已解锁。人员档案目录已开放访问。"
        },
        "0117alpha": {
            "grants_clearance": 2,
            "message": "二级权限已解锁。通讯记录与事故日志已开放访问。"
        },
        "hard2kill": {
            "grants_clearance": 3,
            "message": "三级权限已解锁。高危项目档案已开放。"
        },
        "origin": {
            "grants_clearance": 4,
            "message": "四级权限已解锁。机密目录已开放访问。\n请注意：你即将接触到高度敏感信息。"
        },
        "wearethelight": {
            "grants_clearance": 5,
            "message": "O5级权限已解锁。\n欢迎，监督者。\n愿你做好了面对真相的准备。"
        }
    }
}

### ASSISTANT
## 第一步：整合 manifest.json

加入上一轮新增的 `file_passwords` 字段：

```json
{
    "story": {
        "id": "site19_incident_0117",
        "title": "Site-19 事故调查",
        "author": "SCRT测试",
        "version": "1.0",
        "description": "2024年1月17日，Site-19发生了一起不明事故。你被授权接入终端系统展开调查。"
    },
    "settings": {
        "start_path": "/",
        "start_clearance": 0
    },
    "permissions": {
        "/personnel/": 1,
        "/comms/": 2,
        "/reports/incident_0117.txt": 2,
        "/reports/scp_682.txt": 3,
        "/classified/": 4,
        "/classified/overseer_memo.txt": 5
    },
    "passwords": {
        "bright963": {
            "grants_clearance": 1,
            "message": "一级权限已解锁。人员档案目录已开放访问。"
        },
        "0117alpha": {
            "grants_clearance": 2,
            "message": "二级权限已解锁。通讯记录与事故日志已开放访问。"
        },
        "hard2kill": {
            "grants_clearance": 3,
            "message": "三级权限已解锁。高危项目档案已开放。"
        },
        "origin": {
            "grants_clearance": 4,
            "message": "四级权限已解锁。机密目录已开放访问。\n请注意：你即将接触到高度敏感信息。"
        },
        "wearethelight": {
            "grants_clearance": 5,
            "message": "O5级权限已解锁。\n欢迎，监督者。\n愿你做好了面对真相的准备。"
        }
    },
    "file_passwords": {
        "/reports/incident_0117.txt": {
            "password": "0117alpha",
            "hint": "事故编号+最先响应的小队代号"
        },
        "/classified/overseer_memo.txt": {
            "password": "wearethelight",
            "hint": "O5议会的信条"
        }
    }
}
```

---

## 第二步：多 .scp 包同时识别与切换

### 设计思路

当前 `_try_load_from_dir` 只加载找到的第一个 `.scp` 文件就返回了 [2]。我们需要：

1. **启动时扫描所有 `.scp` 文件**，记录列表
2. **默认加载第一个**，但提供 `disc list` 和 `disc load <编号>` 命令切换
3. 状态栏显示当前加载的磁盘名称

### main.gd 修改

#### 修改1：添加多磁盘相关变量

找到：

```gdscript
var current_story_path: String = ""
```

在它**后面**添加：

```gdscript
var available_stories: Array[Dictionary] = []  # [{path, title, id}]
var current_story_index: int = -1              # 当前加载的剧本索引
```

#### 修改2：替换 `_try_load_story` 函数

找到整个 `_try_load_story` 函数：

```gdscript
func _try_load_story() -> bool:
	var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
	print("[StoryLoader] 搜索目录: " + vdisc_dir)
	if _try_load_from_dir(vdisc_dir):
		return true
	
	print("[StoryLoader] 未找到剧本文件，使用测试数据")
	return false
```

**替换为：**

```gdscript
func _try_load_story() -> bool:
	var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
	print("[StoryLoader] 搜索目录: " + vdisc_dir)
	
	# 扫描所有可用的 .scp 文件
	_scan_available_stories(vdisc_dir)
	
	if available_stories.is_empty():
		print("[StoryLoader] 未找到剧本文件，使用测试数据")
		return false
	
	# 加载第一个剧本
	return _load_story_by_index(0)
```

#### 修改3：添加扫描和按索引加载函数

在 `_try_load_story` 函数**后面**添加：

```gdscript
# 扫描 vdisc 目录下所有可用的 .scp/.zip 文件
func _scan_available_stories(vdisc_dir: String) -> void:
	available_stories.clear()
	
	if not DirAccess.dir_exists_absolute(vdisc_dir):
		return
	
	var dir := DirAccess.open(vdisc_dir)
	if dir == null:
		return
	
	dir.list_dir_begin()
	var file_name := dir.get_next()
	while file_name != "":
		if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
			var full_path: String = vdisc_dir + file_name
			# 快速预读 manifest 获取标题和ID
			var info: Dictionary = _peek_story_info(full_path)
			info["path"] = full_path
			info["filename"] = file_name
			available_stories.append(info)
			print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
		file_name = dir.get_next()
	
	print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")

# 快速预读 .scp 文件的 manifest，只提取标题和ID
func _peek_story_info(path: String) -> Dictionary:
	var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}
	
	var reader := ZIPReader.new()
	if reader.open(path) != OK:
		return info
	
	var files := reader.get_files()
	for file_path in files:
		var filename: String = file_path.get_file()
		if filename == "manifest.json":
			var content_bytes := reader.read_file(file_path)
			if content_bytes != null:
				var content: String = content_bytes.get_string_from_utf8()
				var json := JSON.new()
				if json.parse(content) == OK and json.data is Dictionary:
					var data: Dictionary = json.data
					if data.has("story"):
						var story_info: Dictionary = data["story"]
						info["title"] = story_info.get("title", "未知剧本")
						info["id"] = story_info.get("id", "")
						info["author"] = story_info.get("author", "未知")
			break
		elif filename == "manifest.cfg":
			var content_bytes := reader.read_file(file_path)
			if content_bytes != null:
				var content: String = content_bytes.get_string_from_utf8()
				# 简单解析 cfg 获取标题
				for line in content.split("\n"):
					line = line.strip_edges()
					if line.begins_with("title="):
						info["title"] = line.substr(6).strip_edges()
					elif line.begins_with("id="):
						info["id"] = line.substr(3).strip_edges()
					elif line.begins_with("author="):
						info["author"] = line.substr(7).strip_edges()
			break
	
	reader.close()
	return info

# 按索引加载指定剧本
func _load_story_by_index(index: int) -> bool:
	if index < 0 or index >= available_stories.size():
		return false
	
	var story_info: Dictionary = available_stories[index]
	var path: String = story_info["path"]
	
	if _load_story_file(path):
		current_story_index = index
		return true
	return false
```

#### 修改4：替换 `_try_load_from_dir`（不再需要）

找到整个 `_try_load_from_dir` 函数：

```gdscript
func _try_load_from_dir(stories_dir: String) -> bool:
	if not DirAccess.dir_exists_absolute(stories_dir):
		return false
	
	var dir := DirAccess.open(stories_dir)
	if dir == null:
		return false
	
	dir.list_dir_begin()
	var file_name := dir.get_next()
	while file_name != "":
		if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
			var full_path: String = stories_dir + file_name
			print("[StoryLoader] 发现剧本: " + full_path)
			return _load_story_file(full_path)
		file_name = dir.get_next()
	
	return false
```

**替换为：**

```gdscript
# 保留兼容性，但不再使用
func _try_load_from_dir(_stories_dir: String) -> bool:
	return false
```

#### 修改5：重写 `_cmd_story_info` 支持多磁盘操作

找到整个 `_cmd_story_info` 函数，**替换为：**

```gdscript
func _cmd_story_info() -> void:
	if story_manifest.is_empty() and available_stories.is_empty():
		append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
		return
	
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")
	
	if available_stories.size() > 0:
		lines.append("")
		lines.append("  已发现 [color=#66FF66]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
		lines.append("")
		
		for i in range(available_stories.size()):
			var info: Dictionary = available_stories[i]
			var marker: String = ""
			if i == current_story_index:
				marker = " [color=#33FF33]<< 当前[/color]"
			lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]" + marker)
			lines.append("     作者: [color=#AAAAAA]" + info.get("author", "未知") + "[/color]")
		
		lines.append("")
		lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 切换磁盘[/color]")
		lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]scan[/color][color=#AAAAAA] 重新扫描目录[/color]")
	
	# 当前加载的磁盘详细信息
	if story_manifest.has("story"):
		lines.append("")
		lines.append("[color=#66FF66]─────────── 当前磁盘详情 ───────────[/color]")
		var info: Dictionary = story_manifest["story"]
		lines.append("  磁盘标签: [color=#66FF66]" + info.get("title", "未知") + "[/color]")
		lines.append("  制作者:   [color=#66FF66]" + info.get("author", "未知") + "[/color]")
		lines.append("  版本:     [color=#66FF66]" + info.get("version", "未知") + "[/color]")
		if info.has("description"):
			lines.append("  描述:     [color=#AAAAAA]" + info["description"] + "[/color]")
		lines.append("  文件总数: [color=#66FF66]" + str(file_system.size()) + "[/color]")
		lines.append("  磁盘来源: [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
		lines.append("  磁盘状态: [color=#33FF33]已挂载[/color]")
	
	lines.append("[color=#66FF66]═══════════════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)
```

#### 修改6：修改 `_execute_command` 支持 `vdisc load` 子命令

找到 `_execute_command` 中的：

```gdscript
		"vdisc", "disc", "disk":
			_cmd_story_info()
```

**替换为：**

```gdscript
		"vdisc", "disc", "disk":
			if args.size() >= 1 and args[0].to_lower() == "load":
				await _cmd_vdisc_load(args.slice(1))
			else:
				_cmd_story_info()
```

#### 修改7：添加 `_cmd_vdisc_load` 函数

在 `_cmd_story_info` 函数**后面**添加：

```gdscript
func _cmd_vdisc_load(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: vdisc load <编号>[/color]\n[color=#AAAAAA]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
		return
	
	var index_str: String = args[0]
	if not index_str.is_valid_int():
		append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
		return
	
	var index: int = index_str.to_int() - 1  # 用户输入从1开始
	
	if index < 0 or index >= available_stories.size():
		append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return
	
	if index == current_story_index:
		append_output("[color=#AAAAAA]该磁盘已经是当前加载的磁盘。[/color]\n", false)
		return
	
	# 保存当前剧本存档
	_auto_save()
	
	append_output("[color=#AAAAAA]正在卸载当前磁盘...[/color]", false)
	
	# 等待打字完成
	while _is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.3).timeout
	
	# 重置状态
	file_system.clear()
	story_manifest.clear()
	story_permissions.clear()
	story_file_passwords.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	player_clearance = 0
	read_files.clear()
	unlocked_passwords.clear()
	unlocked_file_passwords.clear()
	
	# 显示加载进度条
	await _show_progress_bar(800)
	await get_tree().create_timer(0.3).timeout
	
	# 加载新剧本
	if _load_story_by_index(index):
		var title: String = available_stories[index].get("title", "未知")
		
		var box: String = _build_box_sectioned([
			["DISC LOADED", "磁盘加载完成"],
			[title]
		], "#33FF33")
		append_output(box + "\n", false)
		
		_update_status_bar()
		append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "  权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
		append_output("[color=#AAAAAA]当前路径: " + current_path + "  权限等级: " + str(player_clearance) + "[/color]\n", false)
	else:
		append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
		_init_test_file_system()
		_update_status_bar()
```

#### 修改8：修改 `_cmd_scan` 重新扫描时更新列表

找到 `_cmd_scan` 中的：

```gdscript
	# 重新扫描
	if _try_load_story():
```

在这行**前面**添加：

```gdscript
	available_stories.clear()
	current_story_index = -1
	
```

#### 修改9：修改 `_cmd_reboot` 重置列表

找到 `_cmd_reboot` 中的：

```gdscript
	unlocked_file_passwords.clear()
	story_file_passwords.clear()
```

在它**后面**添加：

```gdscript
	available_stories.clear()
	current_story_index = -1
```

#### 修改10：修改 `_cmd_help` 更新 vdisc 说明

找到：

```gdscript
	lines.append("  [color=#66FF66]vdisc[/color]         查看当前载入的虚拟磁盘信息")
```

**替换为：**

```gdscript
	lines.append("  [color=#66FF66]vdisc[/color]         查看虚拟磁盘列表和信息")
	lines.append("  [color=#66FF66]vdisc load <编号>[/color] 切换加载指定磁盘")
```

#### 修改11：修改状态栏显示当前磁盘名称

找到 `_update_status_bar` 函数：

```gdscript
func _update_status_bar() -> void:
	path_label.text = "[" + current_path + "]  LV:" + str(player_clearance)
	if has_new_mail:
		mail_icon.text = "[Mail NEW]"
	else:
		mail_icon.text = "[Mail]"
```

**替换为：**

```gdscript
func _update_status_bar() -> void:
	var disc_name: String = ""
	if current_story_index >= 0 and current_story_index < available_stories.size():
		disc_name = available_stories[current_story_index].get("title", "")
	
	if disc_name.is_empty():
		path_label.text = "[" + current_path + "]  LV:" + str(player_clearance)
	else:
		path_label.text = "[" + current_path + "]  LV:" + str(player_clearance) + "  DISC:" + disc_name
	
	if has_new_mail:
		mail_icon.text = "[Mail NEW]"
	else:
		mail_icon.text = "[Mail]"
```

---

## 总结

| 修改 | 作用 |
|------|------|
| manifest.json | 添加 `file_passwords` 字段 |
| `available_stories` 变量 | 存储所有发现的 .scp 文件信息 |
| `_scan_available_stories` | 扫描目录收集所有剧本 |
| `_peek_story_info` | 快速预读 manifest 获取标题 |
| `_load_story_by_index` | 按索引加载指定剧本 |
| `_cmd_story_info` 重写 | 显示所有磁盘列表 |
| `_cmd_vdisc_load` 新命令 | `vdisc load 2` 切换磁盘 |
| `_cmd_scan` / `_cmd_reboot` | 重置磁盘列表 |
| 状态栏 | 显示当前磁盘名称 |

改完后放两个 `.scp` 文件到 `vdisc/` 目录，运行后输入 `vdisc` 应该能看到列表，输入 `vdisc load 2` 能切换到第二个磁盘。

### USER
我觉得现在打开软件后应该有一个类似于“桌面”的主页面，而不是直接进入某一个.scp包；而且现在我觉得应该把main.gd脚本拆分一下，方便后续管理和我们的对话。
我会给出目前所有的main.gd代码，你先做“桌面”主页面这个功能，再拆分脚本。按老规矩仔细检查后返回给我需要增改的地方。注意不要全部发来，否则会导致会话中断。下面是所有代码：
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false
# 打字机效果
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []  # [{path, title, id}]
var current_story_index: int = -1              # 当前加载的剧本索引
# 权限系统
var player_clearance: int = 0              # 当前权限等级
var story_permissions: Dictionary = {}      # 路径 -> 所需权限等级
var story_id: String = ""                   # 当前剧本唯一ID
var read_files: Array[String] = []          # 已读文件列表
var unlocked_passwords: Array[String] = []  # 已解锁的密码
# 密码输入弹窗状态
var _password_mode: bool = false            # 是否处于密码输入模式（unlock用）
var _password_target_path: String = ""      # 密码输入针对的路径（空表示通用unlock）
# 文件密码系统
var _file_password_mode: bool = false       # 是否处于文件密码输入模式
var _file_password_target: String = ""      # 当前等待密码的文件路径
var _file_password_filename: String = ""    # 当前等待密码的文件名（用于显示）
var story_file_passwords: Dictionary = {}   # 路径 -> {password, hint}
var unlocked_file_passwords: Array[String] = []  # 已解锁的文件路径列表
# ============================================================
# 初始化
# ============================================================
# 尝试加载剧本，如果失败则用测试数据
func _ready() -> void:
# 确保stories目录存在
_ensure_stories_dir()
# 尝试加载剧本，如果失败则用测试数据
if not _try_load_story():
_init_test_file_system()
output_text.text = ""
output_text.bbcode_enabled = true
# 启用鼠标选择和交互（为超链接做准备）
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
input_field.focus_mode = Control.FOCUS_ALL
# 阻止Tab键切换焦点，让我们自己处理
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
# 不再用 text_submitted 信号，改为手动监听回车键
input_field.grab_focus()
_update_status_bar()
_show_welcome_message()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 鼠标滚轮滚动
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 点击任意位置聚焦输入框
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
# 点击任何键都确保输入框有焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果正在打字或加载，按空格或ESC跳过动画
if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
_typewriter_instant = true
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
# 如果正在打字，忽略回车（防止干扰）
if _is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
# 如果处于文件密码输入模式
if _file_password_mode:
_file_password_mode = false
input_field.placeholder_text = "> 输入命令..."
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 密码回显用星号
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消文件密码输入。[/color]\n", false)
_file_password_target = ""
_file_password_filename = ""
return
await _verify_file_password(raw_input)
return
# 如果处于密码输入模式
if _password_mode:
_password_mode = false
input_field.placeholder_text = "> 输入命令..."
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 密码回显用星号
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消密码输入。[/color]\n", false)
return
_verify_password(raw_input)
return
command_history.append(raw_input)
history_index = -1
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 命令回显用即时显示（不走打字机）
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
# 执行命令（命令输出走打字机效果）
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
# 重置打字机为动画模式
_typewriter_instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
if args.size() >= 1 and args[0].to_lower() == "load":
await _cmd_vdisc_load(args.slice(1))
else:
_cmd_story_info()
"unlock":
_cmd_unlock(args)
"scan":
await _cmd_scan()
"reboot", "restart":
await _cmd_reboot()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]vdisc[/color]         查看虚拟磁盘列表和信息")
lines.append("  [color=#66FF66]vdisc load <编号>[/color] 切换加载指定磁盘")
lines.append("  [color=#66FF66]scan[/color]          重新扫描虚拟磁盘")
lines.append("  [color=#66FF66]unlock[/color]        进入密码认证（或 unlock <密码>）")
lines.append("  [color=#66FF66]reboot[/color]        重启终端")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
var item_required: int = _get_required_clearance(item_path)
var is_locked: bool = not _has_clearance(item_path)
if node.type == "folder":
if is_locked:
lines.append("  [color=#FF6666][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
else:
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
if is_locked:
lines.append("  [color=#FF6666][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
else:
# 检查是否需要文件密码
var fp_key: String = _get_file_password_key(item_path)
if not fp_key.is_empty() and not unlocked_file_passwords.has(item_path):
lines.append("  [color=#FFB000][FILE] " + item + "  [PASSWORD][/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
# 调试输出
print("[DEBUG] cd 目标: " + new_path + " 需要权限: " + str(_get_required_clearance(new_path)) + " 当前权限: " + str(player_clearance))
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(new_path)
if not _has_clearance(new_path):
var box: String = _build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
# 调试输出
print("[DEBUG] open 目标: " + file_path + " 需要权限: " + str(_get_required_clearance(file_path)) + " 当前权限: " + str(player_clearance))
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(file_path)
if not _has_clearance(file_path):
var box: String = _build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
# 文件密码检查（独立于权限等级）
var fp_key: String = _get_file_password_key(file_path)
if not fp_key.is_empty() and not unlocked_file_passwords.has(file_path):
# 需要文件密码且尚未解锁
var fp_info: Dictionary = story_file_passwords[fp_key]
var hint_text: String = fp_info.get("hint", "")
var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
if not hint_text.is_empty():
box_lines.append(["提示: " + hint_text])
box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
var box: String = _build_box_sectioned(box_lines, "#FFB000")
append_output(box + "\n", false)
# 进入文件密码输入模式
_file_password_mode = true
_file_password_target = file_path
_file_password_filename = filename
input_field.placeholder_text = "输入文件密码..."
return
# 先等待打字队列全部完成
while _is_typing:
await get_tree().process_frame
# 显示进度条（直接操作output_text，不走打字队列）
var content_size: int = node.content.length()
await _show_progress_bar(content_size)
# 进度条完成后等待一小会
await get_tree().create_timer(0.5).timeout
# 清屏进入阅读模式
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
# 显示文件头
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
# 记录已读
if not read_files.has(file_path):
read_files.append(file_path)
_auto_save()
# 显示文件内容（走打字机，不加额外空行）
# 清理内容：去除首尾空白，统一换行符为\n
var clean_content: String = node.content.strip_edges()
clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
append_output(clean_content, false)
# 文件尾放入队列，等内容打完后显示
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名: [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]" + str(player_clearance) + "[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
lines.append("  已解锁文件: [color=#66FF66]" + str(unlocked_file_passwords.size()) + "[/color]")
if not story_id.is_empty():
lines.append("  盘ID: [color=#AAAAAA]" + story_id + "[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty() and available_stories.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")
if available_stories.size() > 0:
lines.append("")
lines.append("  已发现 [color=#66FF66]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
var marker: String = ""
if i == current_story_index:
marker = " [color=#33FF33]<< 当前[/color]"
lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]" + marker)
lines.append(" 作者: [color=#AAAAAA]" + info.get("author", "未知") + "[/color]")
lines.append("")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 切换磁盘[/color]")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]scan[/color][color=#AAAAAA] 重新扫描目录[/color]")
# 当前加载的磁盘详细信息
if story_manifest.has("story"):
lines.append("")
lines.append("[color=#66FF66]─────────── 当前磁盘详情 ───────────[/color]")
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签: [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者:   [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本: [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述: [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数: [color=#66FF66]" + str(file_system.size()) + "[/color]")
lines.append("  磁盘来源: [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态: [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_vdisc_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: vdisc load <编号>[/color]\n[color=#AAAAAA]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1  # 用户输入从1开始
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
if index == current_story_index:
append_output("[color=#AAAAAA]该磁盘已经是当前加载的磁盘。[/color]\n", false)
return
# 保存当前剧本存档
_auto_save()
append_output("[color=#AAAAAA]正在卸载当前磁盘...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.3).timeout
# 重置状态
file_system.clear()
story_manifest.clear()
story_permissions.clear()
story_file_passwords.clear()
current_story_path = ""
story_id = ""
current_path = "/"
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
# 显示加载进度条
await _show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
# 加载新剧本
if _load_story_by_index(index):
var title: String = available_stories[index].get("title", "未知")
var box: String = _build_box_sectioned([
["DISC LOADED", "磁盘加载完成"],
[title]
], "#33FF33")
append_output(box + "\n", false)
_update_status_bar()
append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "  权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
append_output("[color=#AAAAAA]当前路径: " + current_path + "  权限等级: " + str(player_clearance) + "[/color]\n", false)
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
_init_test_file_system()
_update_status_bar()
func _cmd_unlock(args: Array) -> void:
# 如果带了参数，直接验证（兼容旧用法）
if not args.is_empty():
_verify_password(args[0])
return
# 无参数，进入密码输入模式
_enter_password_mode()
func _enter_password_mode(target_path: String = "") -> void:
_password_mode = true
_password_target_path = target_path
var box: String = _build_box_sectioned([
["SECURITY AUTHENTICATION", "安全认证系统"],
["请输入访问密码:", "(输入 cancel 取消)"]
], "#FFB000")
append_output(box + "\n", false)
# 修改输入框提示
input_field.placeholder_text = "输入密码..."
func _verify_password(password: String) -> void:
# 从manifest中查找密码
if not story_manifest.has("passwords"):
append_output("[color=#FF6666][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
return
var passwords: Dictionary = story_manifest["passwords"]
if passwords.has(password):
var pwd_info: Dictionary = passwords[password]
var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
if unlocked_passwords.has(password):
append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(player_clearance) + "[/color]\n", false)
return
if grant_level <= player_clearance:
append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。当前: " + str(player_clearance) + "[/color]\n", false)
return
# 解锁成功
unlocked_passwords.append(password)
var old_level: int = player_clearance
player_clearance = grant_level
_auto_save()
# 成功动画
var box: String = _build_box_sectioned([
["ACCESS GRANTED", "权限认证通过"],
["权限等级: " + str(old_level) + " -> " + str(player_clearance)]
], "#33FF33")
append_output(box + "\n", false)
# 显示提示信息（如果有）
if pwd_info.has("message"):
append_output("[color=#AAAAAA]" + str(pwd_info["message"]) + "[/color]\n", false)
else:
var box: String = _build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _cmd_scan() -> void:
append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
# 显示扫描进度条
await _show_progress_bar(500)
await get_tree().create_timer(0.3).timeout
# 保存旧状态用于对比
var old_story_path: String = current_story_path
var old_manifest: Dictionary = story_manifest.duplicate()
# 重置文件系统和权限
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
story_file_passwords.clear()
available_stories.clear()
current_story_index = -1
# 重新扫描
if _try_load_story():
var title: String = "未知"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
if current_story_path == old_story_path:
append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]\n", false)
else:
append_output("[color=#33FF33][OK] 发现并加载新剧本: " + title + "[/color]\n", false)
append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "[/color]\n", false)
append_output("[color=#AAAAAA]权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
append_output("[color=#AAAAAA]当前权限等级: " + str(player_clearance) + "[/color]\n", false)
# 重置到起始路径
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
else:
current_path = "/"
_update_status_bar()
append_output("[color=#AAAAAA]当前路径已重置为: " + current_path + "[/color]\n", false)
else:
_init_test_file_system()
current_path = "/"
_update_status_bar()
append_output("[color=#FFB000][WARN] 未找到剧本文件，已加载内置测试数据。[/color]", false)
append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
func _cmd_reboot() -> void:
append_output("[color=#AAAAAA]正在重启终端...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 清空所有状态
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
command_history.clear()
history_index = -1
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
current_path = "/"
has_new_mail = false
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
story_file_passwords.clear()
available_stories.clear()
current_story_index = -1
# 重新加载
_ensure_stories_dir()
if not _try_load_story():
_init_test_file_system()
_update_status_bar()
# 模拟重启效果
output_text.append_text("[color=#AAAAAA]...[/color]\n")
await get_tree().create_timer(0.3).timeout
output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
await get_tree().create_timer(0.5).timeout
output_text.text = ""
# 重新显示欢迎信息
_show_welcome_message()
input_field.grab_focus()
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
# 只输入了一个词：补全命令
if parts.size() == 1:
# 检查是否已经是完整命令，后面有空格表示要补全参数
if current_text.ends_with(" "):
# 命令已输入完，补全文件名（无前缀匹配，列出所有）
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只补全文件夹，open/cat只补全文件
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
_do_scroll()
else:
# 补全命令名
var partial_cmd: String = parts[0].to_lower()
var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
"scan", "reboot", "restart", "unlock"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 两个词：命令 + 部分文件名
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只匹配文件夹，open/cat只匹配文件
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
# 找公共前缀，补全到最长公共部分
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 查找多个字符串的最长公共前缀
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
if not _is_typing:
_process_typewriter_queue()
func _process_typewriter_queue() -> void:
if _typewriter_queue.is_empty():
_is_typing = false
return
_is_typing = true
var entry = _typewriter_queue.pop_front()
var text: String = entry["text"]
var extra_newline: bool = entry["extra_newline"]
if _typewriter_instant:
output_text.append_text(text)
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
else:
_typewrite_text(text, extra_newline)
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
var i: int = 0
var length: int = text.length()
_current_char_speed = _typewriter_speed
while i < length:
# 如果中途切换为即时模式，把剩余文本一次性输出
if _typewriter_instant:
output_text.append_text(text.substr(i))
break
# 检查是否是BBCode标签
if text[i] == "[":
var close_bracket: int = text.find("]", i)
if close_bracket != -1:
var tag: String = text.substr(i, close_bracket - i + 1)
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 判断是否是合法的BBCode标签（以字母或/开头）
var tag_inner: String = tag.substr(1, tag.length() - 2)
if tag_inner.length() > 0 and (tag_inner[0] == "/" or tag_inner[0].unicode_at(0) >= 65 and tag_inner[0].unicode_at(0) <= 122):
# 看起来像BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 不是BBCode标签，转义方括号后逐字输出
output_text.append_text("[lb]")
i += 1
continue
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 普通BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 普通字符
var ch: String = text[i]
# 换行符不单独append，而是收集连续的换行一次性输出
if ch == "\n":
var newlines: String = "\n"
i += 1
while i < length and text[i] == "\n":
newlines += "\n"
i += 1
output_text.append_text(newlines)
# 换行后的停顿
if not _typewriter_instant:
await get_tree().create_timer(_typewriter_period_pause).timeout
_do_scroll()
continue
output_text.append_text(ch)
i += 1
# 根据字符类型决定延迟
var delay: float = _current_char_speed
# 标点符号额外停顿（制造顿挫感）
if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
delay += _typewriter_period_pause
elif ch in ["、", "—", "-", "…"]:
delay += _typewriter_comma_pause
else:
# 随机顿挫：有一定概率额外停顿
if randf() < _typewriter_pause_chance:
delay += _typewriter_pause_duration
await get_tree().create_timer(delay).timeout
# 每隔几个字符滚动一次
if i % 8 == 0:
_do_scroll()
# 当前文本打完
if extra_newline:
output_text.append_text("\n")
_do_scroll()
# 继续处理队列
_process_typewriter_queue()
func _do_scroll() -> void:
_needs_scroll = true
func _process(_delta: float) -> void:
if _needs_scroll:
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
scroll_container.scroll_vertical = int(v_scroll.max_value)
_needs_scroll = false
# 显示文件加载进度条
# file_size: 文件内容长度，影响进度条速度
# speed_override: 速度倍率覆盖，-1表示用默认
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
var bar_width: int = 30  # 进度条总长度（字符数）
var speed: float = _progress_bar_speed
if speed_override > 0.0:
speed = speed_override
# 文件越大，每格停顿越长（但有上下限）
var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
base_delay /= speed
# 起始行
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("[color=#66FF66]加载中 [[/color]")
for i in range(bar_width):
if _typewriter_instant:
# 跳过动画，直接填满
var remaining: int = bar_width - i
output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
break
output_text.append_text("[color=#33FF33]█[/color]")
_do_scroll()
# 随机波动让进度条不匀速，更真实
var jitter: float = randf_range(0.7, 1.5)
await get_tree().create_timer(base_delay * jitter).timeout
output_text.append_text("[color=#66FF66]] 完成[/color]\n")
_do_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
var disc_name: String = ""
if current_story_index >= 0 and current_story_index < available_stories.size():
disc_name = available_stories[current_story_index].get("title", "")
if disc_name.is_empty():
path_label.text = "[" + current_path + "]  LV:" + str(player_clearance)
else:
path_label.text = "[" + current_path + "]  LV:" + str(player_clearance) + "  DISC:" + disc_name
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
# 处理RichTextLabel中的超链接点击
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
# 如果是命令链接，直接执行
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
# 如果是文件链接，打开文件
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
# 计算框的宽度：取较长的那行，两侧各留3个空格
var max_len: int = max(title.length(), subtitle.length())
# 中英文混排时，中文字符占2个宽度，英文占1个
var title_display_len: int = _display_width(title)
var subtitle_display_len: int = _display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
# 居中填充
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func _display_width(text: String) -> int:
var width: int = 0
for ch in text:
var code: int = ch.unicode_at(0)
if code >= 0x4E00 and code <= 0x9FFF:
width += 2  # CJK统一汉字
elif code >= 0x3000 and code <= 0x303F:
width += 2  # CJK标点
elif code >= 0xFF00 and code <= 0xFFEF:
width += 2  # 全角字符
else:
width += 1
return width
# 生成自适应宽度的文本框
# lines_data: 每行文本内容（纯文本，不含颜色标签）
# color: 框的颜色代码（如 #33FF33）
# 返回带BBCode的完整框字符串
func _build_box(lines_data: Array[String], color: String) -> String:
# 计算最宽行的显示宽度
var max_width: int = 0
for line in lines_data:
var w: int = _display_width(line)
if w > max_width:
max_width = w
# 内部宽度 = 最宽行 + 左右各2个空格padding
var inner_width: int = max_width + 4
var border_h: String = "═".repeat(inner_width)
var result: String = ""
result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
for i in range(lines_data.size()):
var line: String = lines_data[i]
var line_width: int = _display_width(line)
var pad_total: int = inner_width - line_width
var pad_left: int = pad_total / 2
var pad_right: int = pad_total - pad_left
result += "[color=" + color + "]║" + " ".repeat(pad_left) + line + " ".repeat(pad_right) + "║[/color]\n"
# 如果不是最后一行，且下一行是分隔线标记，插入中间分隔
# 用特殊标记 "---" 表示需要插入分隔线
result += "[color=" + color + "]╚" + border_h + "╝[/color]"
return result
# 生成带中间分隔线的自适应方框
# sections: 二维数组，每个元素是一组行文本，组之间用分隔线隔开
func _build_box_sectioned(sections: Array, color: String) -> String:
# 计算所有行中最宽的显示宽度
var max_width: int = 0
for section in sections:
for line in section:
var w: int = _display_width(str(line))
if w > max_width:
max_width = w
var inner_width: int = max_width + 4
var border_h: String = "═".repeat(inner_width)
var divider_h: String = "═".repeat(inner_width)
var result: String = ""
result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
for s_idx in range(sections.size()):
var section: Array = sections[s_idx]
for line in section:
var line_str: String = str(line)
var line_width: int = _display_width(line_str)
var pad_total: int = inner_width - line_width
var pad_left: int = pad_total / 2
var pad_right: int = pad_total - pad_left
result += "[color=" + color + "]║" + " ".repeat(pad_left) + line_str + " ".repeat(pad_right) + "║[/color]\n"
# 在 section 之间插入分隔线（最后一组不加）
if s_idx < sections.size() - 1:
result += "[color=" + color + "]╠" + divider_h + "╣[/color]\n"
result += "[color=" + color + "]╚" + border_h + "╝[/color]"
return result
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
# 检查路径是否需要权限，返回所需等级（0表示无需权限）
func _get_required_clearance(path: String) -> int:
path = _normalize_path(path)
var highest: int = 0
for perm_path in story_permissions.keys():
var perm_value: int = int(float(story_permissions[perm_path]))
var normalized_perm: String = _normalize_path(perm_path)
# 精确匹配
if path == normalized_perm:
highest = max(highest, perm_value)
continue
# 目录前缀匹配：检查path是否在该目录下
var dir_prefix: String = normalized_perm + "/"
if path.begins_with(dir_prefix):
highest = max(highest, perm_value)
return highest
# 检查玩家是否有权限访问该路径
func _has_clearance(path: String) -> bool:
return player_clearance >= _get_required_clearance(path)
# 检查文件是否需要密码，返回对应的密码表key（空字符串表示不需要）
func _get_file_password_key(file_path: String) -> String:
file_path = _normalize_path(file_path)
# 精确匹配
for fp_path in story_file_passwords.keys():
var normalized_fp: String = _normalize_path(fp_path)
if file_path == normalized_fp:
return fp_path
return ""
# 验证文件密码
func _verify_file_password(input_password: String) -> void:
var fp_key: String = _get_file_password_key(_file_password_target)
if fp_key.is_empty():
append_output("[color=#FF6666][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
return
var fp_info: Dictionary = story_file_passwords[fp_key]
var correct_password: String = str(fp_info.get("password", ""))
if input_password == correct_password:
# 密码正确
unlocked_file_passwords.append(_file_password_target)
_auto_save()
var box: String = _build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], "#33FF33")
append_output(box + "\n", false)
# 等打字完成后自动打开文件
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 重新执行打开文件
await _cmd_open([_file_password_filename])
else:
var box: String = _build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
var content: String = entry.get("content", "")
# 统一换行符，防止\r\n导致双倍行距
content = content.replace("\r\n", "\n").replace("\r", "\n")
return FSNode.new(entry.get("type", "file"), content)
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 存档读档功能
# ============================================================
func _get_save_path() -> String:
return _get_game_root_dir() + "saves/save_" + story_id + ".json"
func _auto_save() -> void:
if story_id.is_empty():
return
# 确保存档目录存在
var save_dir: String = _get_game_root_dir() + "saves/"
if not DirAccess.dir_exists_absolute(save_dir):
var err := DirAccess.make_dir_absolute(save_dir)
if err == OK:
print("[Save] 已创建存档目录: " + save_dir)
else:
print("[Save] 创建存档目录失败: " + str(err))
return
var save_data: Dictionary = {
"story_id": story_id,
"player_clearance": player_clearance,
"read_files": read_files,
"unlocked_passwords": unlocked_passwords,
"unlocked_file_passwords": unlocked_file_passwords,
"current_path": current_path
}
var save_path: String = _get_save_path()
print("[Save] 存档路径: " + save_path)
var file := FileAccess.open(save_path, FileAccess.WRITE)
if file:
file.store_string(JSON.stringify(save_data, "\t"))
file.close()
print("[Save] 已保存: " + _get_save_path())
func _load_save() -> bool:
var path: String = _get_save_path()
print("[Save] 尝试加载存档: " + path)
if not FileAccess.file_exists(path):
print("[Save] 存档不存在，使用默认设置")
return false
var file := FileAccess.open(path, FileAccess.READ)
if file == null:
return false
var json_text: String = file.get_as_text()
file.close()
var json := JSON.new()
if json.parse(json_text) != OK:
return false
var data: Dictionary = json.data
if data.get("story_id", "") != story_id:
return false
player_clearance = int(data.get("player_clearance", 0))
read_files.clear()
if data.has("read_files"):
for f in data["read_files"]:
read_files.append(str(f))
unlocked_passwords.clear()
if data.has("unlocked_passwords"):
for p in data["unlocked_passwords"]:
unlocked_passwords.append(str(p))
unlocked_file_passwords.clear()
if data.has("unlocked_file_passwords"):
for p in data["unlocked_file_passwords"]:
unlocked_file_passwords.append(str(p))
if data.has("current_path"):
var saved_path: String = data["current_path"]
# 验证存档路径是否有权限访问，没有则重置到起始路径
if _has_clearance(saved_path):
current_path = saved_path
else:
current_path = "/"
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
print("[Save] 已加载存档: " + path)
print("[Save] 权限等级: " + str(player_clearance))
return true
# 获取游戏根目录（编辑器中为项目目录，导出后为exe所在目录）
func _get_game_root_dir() -> String:
if OS.has_feature("editor"):
return ProjectSettings.globalize_path("res://")
else:
return OS.get_executable_path().get_base_dir() + "/"
func _ensure_stories_dir() -> void:
var vdisc_path: String = _get_game_root_dir() + "vdisc/"
if not DirAccess.dir_exists_absolute(vdisc_path):
var err := DirAccess.make_dir_absolute(vdisc_path)
if err == OK:
print("[StoryLoader] 已创建vdisc目录: " + vdisc_path)
else:
print("[StoryLoader] 创建vdisc目录失败: " + str(err))
else:
print("[StoryLoader] vdisc目录已存在: " + vdisc_path)
# 尝试从 vdisc 目录加载第一个 .scp 文件
func _try_load_story() -> bool:
var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
print("[StoryLoader] 搜索目录: " + vdisc_dir)
# 扫描所有可用的 .scp 文件
_scan_available_stories(vdisc_dir)
if available_stories.is_empty():
print("[StoryLoader] 未找到剧本文件，使用测试数据")
return false
# 加载第一个剧本
return _load_story_by_index(0)
# 扫描 vdisc 目录下所有可用的 .scp/.zip 文件
func _scan_available_stories(vdisc_dir: String) -> void:
available_stories.clear()
if not DirAccess.dir_exists_absolute(vdisc_dir):
return
var dir := DirAccess.open(vdisc_dir)
if dir == null:
return
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = vdisc_dir + file_name
# 快速预读 manifest 获取标题和ID
var info: Dictionary = _peek_story_info(full_path)
info["path"] = full_path
info["filename"] = file_name
available_stories.append(info)
print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
file_name = dir.get_next()
print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")
# 快速预读 .scp 文件的 manifest，只提取标题和ID
func _peek_story_info(path: String) -> Dictionary:
var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}
var reader := ZIPReader.new()
if reader.open(path) != OK:
return info
var files := reader.get_files()
for file_path in files:
var filename: String = file_path.get_file()
if filename == "manifest.json":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
var json := JSON.new()
if json.parse(content) == OK and json.data is Dictionary:
var data: Dictionary = json.data
if data.has("story"):
var story_info: Dictionary = data["story"]
info["title"] = story_info.get("title", "未知剧本")
info["id"] = story_info.get("id", "")
info["author"] = story_info.get("author", "未知")
break
elif filename == "manifest.cfg":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
# 简单解析 cfg 获取标题
for line in content.split("\n"):
line = line.strip_edges()
if line.begins_with("title="):
info["title"] = line.substr(6).strip_edges()
elif line.begins_with("id="):
info["id"] = line.substr(3).strip_edges()
elif line.begins_with("author="):
info["author"] = line.substr(7).strip_edges()
break
reader.close()
return info
# 按索引加载指定剧本
func _load_story_by_index(index: int) -> bool:
if index < 0 or index >= available_stories.size():
return false
var story_info: Dictionary = available_stories[index]
var path: String = story_info["path"]
if _load_story_file(path):
current_story_index = index
return true
return false
# 保留兼容性，但不再使用
func _try_load_from_dir(_stories_dir: String) -> bool:
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据
file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 读取盘ID
if story_manifest.has("story") and story_manifest["story"].has("id"):
story_id = story_manifest["story"]["id"]
else:
# 没有id就用文件名的哈希作为id
story_id = str(path.get_file().hash())
# 读取权限表
story_permissions.clear()
if story_manifest.has("permissions"):
var perms: Dictionary = story_manifest["permissions"]
for perm_path in perms.keys():
story_permissions[perm_path] = int(perms[perm_path])
print("[StoryLoader] 权限表已加载，共 " + str(story_permissions.size()) + " 条规则")
else:
print("[StoryLoader] 警告: manifest中未找到permissions字段")
if story_manifest.has("passwords"):
print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
else:
print("[StoryLoader] 警告: manifest中未找到passwords字段")
# 读取文件密码表
story_file_passwords.clear()
if story_manifest.has("file_passwords"):
var fps: Dictionary = story_manifest["file_passwords"]
for fp_path in fps.keys():
story_file_passwords[fp_path] = fps[fp_path]
print("[StoryLoader] 文件密码表已加载，共 " + str(story_file_passwords.size()) + " 条")
else:
print("[StoryLoader] 未配置文件密码表（file_passwords）")
# 应用 manifest 中的设置
var start_clearance: int = 0
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
_typewriter_speed = settings["typing_speed"].to_float()
if settings.has("start_clearance"):
start_clearance = int(settings["start_clearance"])
# 尝试加载该剧本的存档
if not _load_save():
# 没有存档，用初始权限
player_clearance = start_clearance
read_files.clear()
unlocked_passwords.clear()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 盘ID: " + story_id)
print("[StoryLoader] 文件数量: " + str(file_system.size()))
print("[StoryLoader] 权限等级: " + str(player_clearance))
print("[StoryLoader] story_permissions 内容: " + str(story_permissions))
print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
return true
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
这是一个大工程，我分两部分来做。先做**"桌面"主页面**功能，再做**脚本拆分**。由于内容很多，我先给出桌面功能的修改，脚本拆分放到下一轮。

---

## Part 1：桌面主页面

### 设计思路

- 启动时显示"桌面"，不自动进入任何 .scp 包
- 桌面模式下：扫描 vdisc/ 目录，列出所有可用磁盘，用户输入编号选择加载
- 桌面模式下只有少数命令可用：`help`、`vdisc`、`scan`、`exit`、`clear`、`reboot`
- 加载磁盘后进入"终端模式"，所有命令可用
- 新增 `eject` 命令从终端模式退回桌面

### 修改1：添加桌面模式状态变量

找到状态变量区域的：

```gdscript
var _needs_scroll: bool = false
```

在它**后面**添加：

```gdscript

# 桌面/终端模式
var _desktop_mode: bool = true             # true=桌面模式，false=终端模式（已加载磁盘）
```

### 修改2：修改 `_ready` 函数

找到整个 `_ready` 函数，**替换为：**

```gdscript
func _ready() -> void:
	_ensure_stories_dir()
	
	# 启动时只扫描，不自动加载
	var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)
	
	output_text.text = ""
	output_text.bbcode_enabled = true
	output_text.selection_enabled = true
	output_text.meta_underlined = true
	output_text.meta_clicked.connect(_on_meta_clicked)
	
	input_field.focus_mode = Control.FOCUS_ALL
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
	input_field.grab_focus()
	
	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()
```

### 修改3：添加桌面欢迎界面函数

在 `_show_welcome_message` 函数**前面**添加：

```gdscript
# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
	var title: String = "SCP FOUNDATION TERMINAL v0.1"
	var subtitle: String = "SECURE - CONTAIN - PROTECT"
	
	var box: String = _build_box([title, subtitle] as Array[String], "#66FF66")
	output_text.append_text(box + "\n\n")
	
	# 显示磁盘列表
	if available_stories.is_empty():
		output_text.append_text("[color=#FFB000]未检测到虚拟磁盘。[/color]\n")
		output_text.append_text("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
	else:
		output_text.append_text("[color=#66FF66]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
		for i in range(available_stories.size()):
			var info: Dictionary = available_stories[i]
			output_text.append_text("  [color=#FFB000]" + str(i + 1) + ".[/color] [color=#66FF66]" + info.get("title", "未知") + "[/color]\n")
			output_text.append_text("     [color=#AAAAAA]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
		output_text.append_text("\n")
	
	output_text.append_text("[color=#AAAAAA]可用命令:[/color]\n")
	output_text.append_text("  [color=#66FF66]load <编号>[/color]   加载指定磁盘\n")
	output_text.append_text("  [color=#66FF66]scan[/color]          重新扫描磁盘目录\n")
	output_text.append_text("  [color=#66FF66]clear[/color]         清空屏幕\n")
	output_text.append_text("  [color=#66FF66]exit[/color]          退出终端\n")

func _cmd_desktop_load(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: load <编号>[/color]", false)
		if available_stories.size() > 0:
			append_output("[color=#AAAAAA]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return
	
	var index_str: String = args[0]
	if not index_str.is_valid_int():
		append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
		return
	
	var index: int = index_str.to_int() - 1
	
	if index < 0 or index >= available_stories.size():
		append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return
	
	append_output("[color=#AAAAAA]正在加载虚拟磁盘...[/color]", false)
	
	# 等待打字完成
	while _is_typing:
		await get_tree().process_frame
	
	# 显示加载进度条
	await _show_progress_bar(800)
	await get_tree().create_timer(0.3).timeout
	
	# 加载剧本
	if _load_story_by_index(index):
		_desktop_mode = false
		var title: String = available_stories[index].get("title", "未知")
		
		# 清屏并显示终端欢迎
		output_text.text = ""
		_typewriter_queue.clear()
		_is_typing = false
		_typewriter_instant = false
		
		_update_status_bar()
		_show_welcome_message()
	else:
		append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)

func _cmd_eject() -> void:
	if _desktop_mode:
		append_output("[color=#AAAAAA]当前已在桌面模式。[/color]\n", false)
		return
	
	# 保存当前剧本存档
	_auto_save()
	
	append_output("[color=#AAAAAA]正在卸载磁盘...[/color]", false)
	
	# 等待打字完成
	while _is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.5).timeout
	
	# 重置终端状态
	file_system.clear()
	story_manifest.clear()
	story_permissions.clear()
	story_file_passwords.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	player_clearance = 0
	read_files.clear()
	unlocked_passwords.clear()
	unlocked_file_passwords.clear()
	current_story_index = -1
	
	# 切换到桌面模式
	_desktop_mode = true
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false
	
	_update_status_bar()
	_show_desktop_welcome()
```

### 修改4：修改 `_execute_command` 加入桌面模式分流

找到整个 `_execute_command` 函数，**替换为：**

```gdscript
func _execute_command(raw_input: String) -> void:
	_typewriter_instant = false
	
	var parts := raw_input.split(" ", false)
	if parts.is_empty():
		return
	
	var command: String = parts[0].to_lower()
	var args := parts.slice(1)
	
	# 桌面模式：只允许少数命令
	if _desktop_mode:
		match command:
			"load":
				await _cmd_desktop_load(args)
			"scan":
				await _cmd_scan()
			"clear", "cls":
				_cmd_clear()
			"exit", "quit":
				await _cmd_exit()
			"help", "?":
				_cmd_desktop_help()
			"vdisc", "disc", "disk":
				_cmd_story_info()
			"reboot", "restart":
				await _cmd_reboot()
			_:
				append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n[color=#AAAAAA]输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n", false)
		return
	
	# 终端模式：所有命令可用
	match command:
		"help", "?":
			_cmd_help()
		"ls", "dir":
			_cmd_ls()
		"cd":
			_cmd_cd(args)
		"open", "cat":
			await _cmd_open(args)
		"back":
			_cmd_back()
		"clear", "cls":
			_cmd_clear()
		"status":
			_cmd_status()
		"mail":
			_cmd_mail(args)
		"exit", "quit":
			await _cmd_exit()
		"whoami":
			_cmd_whoami()
		"vdisc", "disc", "disk":
			if args.size() >= 1 and args[0].to_lower() == "load":
				await _cmd_vdisc_load(args.slice(1))
			else:
				_cmd_story_info()
		"unlock":
			_cmd_unlock(args)
		"scan":
			await _cmd_scan()
		"reboot", "restart":
			await _cmd_reboot()
		"eject":
			await _cmd_eject()
		"load":
			append_output("[color=#AAAAAA]磁盘已加载。使用 [/color][color=#66FF66]eject[/color][color=#AAAAAA] 返回桌面后再切换磁盘，或使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 直接切换。[/color]\n", false)
		_:
			append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
```

### 修改5：添加桌面模式的 help 命令

在 `_cmd_help` 函数**前面**添加：

```gdscript
func _cmd_desktop_help() -> void:
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════════ 桌面命令 ═══════════════[/color]")
	lines.append("  [color=#66FF66]load <编号>[/color]   加载指定虚拟磁盘")
	lines.append("  [color=#66FF66]scan[/color]          重新扫描vdisc目录")
	lines.append("  [color=#66FF66]vdisc[/color]         查看磁盘列表详情")
	lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
	lines.append("  [color=#66FF66]reboot[/color]        重启终端")
	lines.append("  [color=#66FF66]exit[/color]          退出终端")
	lines.append("[color=#66FF66]═══════════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)
```

### 修改6：修改 `_cmd_help` 加入 eject 命令

找到 `_cmd_help` 中的：

```gdscript
	lines.append("  [color=#66FF66]reboot[/color]        重启终端")
	lines.append("  [color=#66FF66]exit[/color]          退出终端")
```

**替换为：**

```gdscript
	lines.append("  [color=#66FF66]eject[/color]         卸载磁盘，返回桌面")
	lines.append("  [color=#66FF66]reboot[/color]        重启终端")
	lines.append("  [color=#66FF66]exit[/color]          退出终端")
```

### 修改7：修改 `_update_status_bar` 支持桌面模式

找到整个 `_update_status_bar` 函数，**替换为：**

```gdscript
func _update_status_bar() -> void:
	if _desktop_mode:
		path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
		mail_icon.text = "[Mail]"
		return
	
	var disc_name: String = ""
	if current_story_index >= 0 and current_story_index < available_stories.size():
		disc_name = available_stories[current_story_index].get("title", "")
	
	if disc_name.is_empty():
		path_label.text = "[" + current_path + "]  LV:" + str(player_clearance)
	else:
		path_label.text = "[" + current_path + "]  LV:" + str(player_clearance) + "  DISC:" + disc_name
	
	if has_new_mail:
		mail_icon.text = "[Mail NEW]"
	else:
		mail_icon.text = "[Mail]"
```

### 修改8：修改 `_cmd_scan` 适配桌面模式

找到 `_cmd_scan` 函数中的 `# 重新扫描` 注释后面的整个 `if _try_load_story():` 分支到函数结尾，**替换为：**

也就是找到从 `# 重新扫描` 开始到函数结尾的部分：

```gdscript
	# 重新扫描
	if _try_load_story():
		var title: String = "未知"
		...（中间省略）...
		append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
```

**替换为：**

```gdscript
	# 重新扫描
	var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)
	
	if _desktop_mode:
		# 桌面模式：只扫描，不自动加载
		if available_stories.is_empty():
			append_output("[color=#FFB000][WARN] 未找到虚拟磁盘文件。[/color]", false)
			append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
		else:
			append_output("[color=#33FF33][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]", false)
			for i in range(available_stories.size()):
				var info: Dictionary = available_stories[i]
				append_output("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]", false)
			append_output("\n[color=#AAAAAA]输入 [/color][color=#66FF66]load <编号>[/color][color=#AAAAAA] 加载磁盘。[/color]\n", false)
		_update_status_bar()
	else:
		# 终端模式：重新加载当前磁盘
		if available_stories.is_empty():
			_desktop_mode = true
			_init_test_file_system()
			current_path = "/"
			_update_status_bar()
			append_output("[color=#FFB000][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
		elif _load_story_by_index(0):
			var title: String = "未知"
			if story_manifest.has("story") and story_manifest["story"].has("title"):
				title = story_manifest["story"]["title"]
			append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]", false)
			append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "  权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
			if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
				current_path = story_manifest["settings"]["start_path"]
			else:
				current_path = "/"
			_update_status_bar()
		else:
			append_output("[color=#FF6666][ERROR] 重新加载失败。[/color]\n", false)
```

### 修改9：修改 `_cmd_reboot` 回到桌面模式

找到 `_cmd_reboot` 函数中从 `# 重新加载` 到函数结尾的部分：

```gdscript
	# 重新加载
	_ensure_stories_dir()
	if not _try_load_story():
		_init_test_file_system()
	_update_status_bar()
	
	# 模拟重启效果
	output_text.append_text("[color=#AAAAAA]...[/color]\n")
	await get_tree().create_timer(0.3).timeout
	output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
	await get_tree().create_timer(0.5).timeout
	output_text.text = ""
	
	# 重新显示欢迎信息
	_show_welcome_message()
	input_field.grab_focus()
```

**替换为：**

```gdscript
	# 重新加载
	_ensure_stories_dir()
	var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)
	
	# 模拟重启效果
	output_text.append_text("[color=#AAAAAA]...[/color]\n")
	await get_tree().create_timer(0.3).timeout
	output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
	await get_tree().create_timer(0.5).timeout
	output_text.text = ""
	
	# 回到桌面
	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()
	input_field.grab_focus()
```

### 修改10：修改 `_try_load_story` 不再自动加载

找到整个 `_try_load_story` 函数，**替换为：**

```gdscript
func _try_load_story() -> bool:
	var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
	print("[StoryLoader] 搜索目录: " + vdisc_dir)
	_scan_available_stories(vdisc_dir)
	# 不再自动加载，由桌面模式的 load 命令触发
	return not available_stories.is_empty()
```

### 修改11：修改 `_auto_complete` 加入桌面模式命令

找到 `_auto_complete` 中的命令列表：

```gdscript
			var commands := ["help", "ls", "dir", "cd", "open", "cat", "back",
				"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
				"scan", "reboot", "restart", "unlock"]
```

**替换为：**

```gdscript
			var commands: Array
			if _desktop_mode:
				commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
			else:
				commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
					"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
					"scan", "reboot", "restart", "unlock", "eject"]
```

### 修改12：删除不再需要的 `_try_load_from_dir`

找到：

```gdscript
# 保留兼容性，但不再使用
func _try_load_from_dir(_stories_dir: String) -> bool:
	return false
```

**直接删除。**

---

以上改完后保存运行测试。启动后应该看到桌面界面，列出所有 .scp 磁盘，输入 `load 1` 加载第一个磁盘进入终端，输入 `eject` 回到桌面。

**脚本拆分我们放到确认桌面功能正常之后再做**，因为拆分涉及创建多个新文件，改动量很大，确保基础功能稳定后再拆更安全。

### USER
目前发现两个问题：
1.输入scan后，“扫描完成，发现2个虚拟磁盘。” 和 两个虚拟磁盘名在同一行，调整一下排版格式。
2.页面最上面的状态栏和最下面的输入区分别加上方框，优化一下UI。

### ASSISTANT
好的，两个问题都不复杂，逐个解决。

---

## 问题1：修复 scan 命令的排版格式

找到 `_cmd_scan` 函数中桌面模式的扫描结果显示部分：

```gdscript
		else:
			append_output("[color=#33FF33][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]", false)
			for i in range(available_stories.size()):
				var info: Dictionary = available_stories[i]
				append_output("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]", false)
			append_output("\n[color=#AAAAAA]输入 [/color][color=#66FF66]load <编号>[/color][color=#AAAAAA] 加载磁盘。[/color]\n", false)
```

**替换为：**

```gdscript
		else:
			var scan_lines: Array[String] = []
			scan_lines.append("[color=#33FF33][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
			scan_lines.append("")
			for i in range(available_stories.size()):
				var info: Dictionary = available_stories[i]
				scan_lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]")
			scan_lines.append("")
			scan_lines.append("[color=#AAAAAA]输入 [/color][color=#66FF66]load <编号>[/color][color=#AAAAAA] 加载磁盘。[/color]")
			append_output("\n".join(scan_lines) + "\n", false)
```

这样扫描结果会变成一次性输出，每个磁盘独占一行，之间有适当的空行分隔。

---

## 问题2：状态栏和输入区加方框

这个需要修改场景树（.tscn文件）或者通过代码设置样式。我用代码方式实现，不需要改场景文件。

### 在 `_ready` 函数中添加样式设置

找到 `_ready` 函数中的：

```gdscript
	input_field.focus_mode = Control.FOCUS_ALL
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
	input_field.grab_focus()
```

在这段**前面**插入：

```gdscript
	# 状态栏样式：添加底部边框线
	var status_bar: HBoxContainer = $MainContent/StatusBar
	var status_style := StyleBoxFlat.new()
	status_style.bg_color = Color(0.0, 0.05, 0.0, 0.8)
	status_style.border_color = Color(0.4, 1.0, 0.4, 0.6)
	status_style.border_width_bottom = 1
	status_style.border_width_top = 1
	status_style.border_width_left = 1
	status_style.border_width_right = 1
	status_style.content_margin_left = 8
	status_style.content_margin_right = 8
	status_style.content_margin_top = 4
	status_style.content_margin_bottom = 4
	status_bar.add_theme_stylebox_override("panel", status_style)
	
	# 输入区样式：添加顶部边框线
	var input_area: HBoxContainer = $MainContent/InputArea
	var input_style := StyleBoxFlat.new()
	input_style.bg_color = Color(0.0, 0.05, 0.0, 0.8)
	input_style.border_color = Color(0.4, 1.0, 0.4, 0.6)
	input_style.border_width_top = 1
	input_style.border_width_bottom = 1
	input_style.border_width_left = 1
	input_style.border_width_right = 1
	input_style.content_margin_left = 8
	input_style.content_margin_right = 8
	input_style.content_margin_top = 4
	input_style.content_margin_bottom = 4
	input_area.add_theme_stylebox_override("panel", input_style)
```

**注意：** `HBoxContainer` 默认不会绘制 `panel` 样式。如果你的 StatusBar 和 InputArea 是 `HBoxContainer`，需要改为 `PanelContainer` 包裹，或者改用 `Panel` 节点。

最简单的方案是直接改场景中的节点类型。但如果不想改场景文件，可以用以下替代方案：

### 替代方案：用代码给输入框本身加样式

把上面插入的代码**替换为这个版本**（只改 input_field 的样式，以及用 Label 的字体颜色来区分状态栏）：

```gdscript
	# 输入框样式
	var input_style := StyleBoxFlat.new()
	input_style.bg_color = Color(0.0, 0.08, 0.0, 0.9)
	input_style.border_color = Color(0.4, 1.0, 0.4, 0.5)
	input_style.border_width_top = 1
	input_style.border_width_bottom = 1
	input_style.border_width_left = 1
	input_style.border_width_right = 1
	input_style.content_margin_left = 8
	input_style.content_margin_right = 8
	input_style.content_margin_top = 4
	input_style.content_margin_bottom = 4
	input_style.corner_radius_top_left = 0
	input_style.corner_radius_top_right = 0
	input_style.corner_radius_bottom_left = 0
	input_style.corner_radius_bottom_right = 0
	input_field.add_theme_stylebox_override("normal", input_style)
	
	var input_focus_style := input_style.duplicate()
	input_focus_style.border_color = Color(0.4, 1.0, 0.4, 0.8)
	input_field.add_theme_stylebox_override("focus", input_focus_style)
```

然后对于**状态栏**，最可靠的做法是在场景中做调整。请在 Godot 编辑器中：

1. 选中 `MainContent/StatusBar` 节点
2. 在右侧属性面板中，将节点类型从 `HBoxContainer` 改为 `PanelContainer`（或者在 StatusBar 外面套一层 `PanelContainer`）

如果不想改场景，还有一个纯代码方案——在 `_ready` 中通过 `_draw` 来画边框。但最简单的方法是：

### 最终推荐方案：修改场景节点类型

在 Godot 编辑器中做以下调整：

**StatusBar：**
1. 右键 `StatusBar`（HBoxContainer）→ Change Type → 改为 `PanelContainer`
2. 在 StatusBar 里面新建一个 `HBoxContainer`，命名为 `StatusContent`
3. 把原来 StatusBar 下的 `PathLabel` 和 `MailIcon` 拖到 `StatusContent` 里面

**InputArea：**
1. 右键 `InputArea`（HBoxContainer）→ Change Type → 改为 `PanelContainer`
2. 在 InputArea 里面新建一个 `HBoxContainer`，命名为 `InputContent`
3. 把原来 InputArea 下的 `InputField` 等子节点拖到 `InputContent` 里面

然后修改代码中的节点引用路径和样式设置。

**但这改动比较大。我推荐一个更简单的折中方案：**

### 最简方案：在 `_update_status_bar` 中用文字边框装饰

找到整个 `_update_status_bar` 函数，**替换为：** [1]

```gdscript
func _update_status_bar() -> void:
	if _desktop_mode:
		path_label.text = "║ DESKTOP ║  " + str(available_stories.size()) + " disc(s) found"
		mail_icon.text = "║ Mail ║"
		return
	
	var disc_name: String = ""
	if current_story_index >= 0 and current_story_index < available_stories.size():
		disc_name = available_stories[current_story_index].get("title", "")
	
	if disc_name.is_empty():
		path_label.text = "║ " + current_path + " ║  LV:" + str(player_clearance)
	else:
		path_label.text = "║ " + current_path + " ║  LV:" + str(player_clearance) + "  DISC:" + disc_name
	
	if has_new_mail:
		mail_icon.text = "║ Mail NEW ║"
	else:
		mail_icon.text = "║ Mail ║"
```

**不，这样太丑了。** 还是用代码加 StyleBox 吧，但直接对 Label 和 InputField 本身操作：

### 最终方案（推荐）

在 `_ready` 函数中，找到：

```gdscript
	input_field.focus_mode = Control.FOCUS_ALL
```

在这行**前面**插入：

```gdscript
	# === UI 边框样式 ===
	# 状态栏 PathLabel 样式
	var label_style := StyleBoxFlat.new()
	label_style.bg_color = Color(0.0, 0.06, 0.0, 0.9)
	label_style.border_color = Color(0.3, 0.8, 0.3, 0.5)
	label_style.set_border_width_all(1)
	label_style.content_margin_left = 10
	label_style.content_margin_right = 10
	label_style.content_margin_top = 3
	label_style.content_margin_bottom = 3
	path_label.add_theme_stylebox_override("normal", label_style)
	
	# 状态栏 MailIcon 样式
	var mail_style := label_style.duplicate()
	mail_icon.add_theme_stylebox_override("normal", mail_style)
	
	# 输入框样式
	var input_normal := StyleBoxFlat.new()
	input_normal.bg_color = Color(0.0, 0.06, 0.0, 0.9)
	input_normal.border_color = Color(0.3, 0.8, 0.3, 0.5)
	input_normal.set_border_width_all(1)
	input_normal.content_margin_left = 10
	input_normal.content_margin_right = 10
	input_normal.content_margin_top = 4
	input_normal.content_margin_bottom = 4
	input_field.add_theme_stylebox_override("normal", input_normal)
	
	var input_focus := input_normal.duplicate()
	input_focus.border_color = Color(0.4, 1.0, 0.4, 0.8)
	input_field.add_theme_stylebox_override("focus", input_focus)
	
```

**注意：** `Label` 节点默认不支持 `normal` 这个 stylebox override。`Label` 的样式只能通过自定义字体颜色等设置。

所以对于 Label 类型的 `path_label` 和 `mail_icon`，我们需要换一种方式。**请在 Godot 编辑器中做如下操作：**

#### 场景树调整（必需）

1. 选中 `StatusBar` 节点（HBoxContainer）
2. 在属性面板 → Theme Overrides → Styles 中无法直接设置（因为HBoxContainer不绘制背景）

**所以最干净的方案是：在 StatusBar 的父级套一个 PanelContainer。**

请在 Godot 编辑器中：

1. 在 `MainContent` 下，右键 `StatusBar` → 选择 **Wrap in PanelContainer**（如果没有这个选项，就手动创建）
   - 在 `StatusBar` **上方**新建 `PanelContainer`，命名为 `StatusFrame`
   - 把 `StatusBar` 拖进 `StatusFrame` 成为其子节点

2. 同样，在 `InputArea` 上方新建 `PanelContainer`，命名为 `InputFrame`
   - 把 `InputArea` 拖进 `InputFrame` 成为其子节点

场景树变为：
```
MainContent (VBoxContainer)
  ├── StatusFrame (PanelContainer)      ← 新增
  │   └── StatusBar (HBoxContainer)
  │       ├── PathLabel
  │       └── MailIcon
  ├── OutputArea (ScrollContainer)
  │   └── OutputText
  └── InputFrame (PanelContainer)       ← 新增
      └── InputArea (HBoxContainer)
          └── InputField
```

然后在代码中添加对这两个 PanelContainer 的样式设置。

### 代码修改

在 `@onready` 节点引用区域的末尾添加：

```gdscript
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
```

**同时修改原有路径**（因为节点层级变了）：

```gdscript
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
```

然后在 `_ready` 函数中，找到 `output_text.text = ""` 这行，在它**前面**插入：

```gdscript
	# === UI 边框样式 ===
	var frame_style := StyleBoxFlat.new()
	frame_style.bg_color = Color(0.0, 0.06, 0.0, 0.95)
	frame_style.border_color = Color(0.3, 0.8, 0.3, 0.5)
	frame_style.set_border_width_all(1)
	frame_style.content_margin_left = 6
	frame_style.content_margin_right = 6
	frame_style.content_margin_top = 4
	frame_style.content_margin_bottom = 4
	status_frame.add_theme_stylebox_override("panel", frame_style)
	
	var input_frame_style := frame_style.duplicate()
	input_frame_style.border_color = Color(0.3, 0.8, 0.3, 0.5)
	input_frame.add_theme_stylebox_override("panel", input_frame_style)
	
```

---

改完后保存运行测试。状态栏和输入区都会有绿色细边框包围，scan 的输出也会格式正确了。

### USER
还有，存档save文件在导出软件后需要放在外面（或者新创建一个），也需要修改一下。

### ASSISTANT
好的，目前存档路径使用的是 `user://saves/`，这在导出后会存到系统的 AppData 隐藏目录中，不方便用户管理。需要改为和 `vdisc/` 一样，存放在 exe 同级目录下。

你的代码中已经有 `_get_game_root_dir()` 函数来获取游戏根目录，但存档相关的两个函数还在用旧路径 [1]。

---

## 修改1：修复 `_get_save_path`

找到：

```gdscript
func _get_save_path() -> String:
	return _get_game_root_dir() + "saves/save_" + story_id + ".json"
```

如果你的代码中写的还是 `"user://saves/"` 的形式，确认**替换为：**

```gdscript
func _get_save_path() -> String:
	return _get_game_root_dir() + "saves/save_" + story_id + ".json"
```

## 修改2：修复 `_auto_save` 中的存档目录路径

找到 `_auto_save` 函数中的：

```gdscript
	var save_dir: String = _get_game_root_dir() + "saves/"
```

确认是这个路径。如果你的代码中还是写的 `"user://saves/"`，**替换为：**

```gdscript
	var save_dir: String = _get_game_root_dir() + "saves/"
```

## 修改3：确保 `_ready` 中也创建 saves 目录

找到 `_ready` 函数中的：

```gdscript
	_ensure_stories_dir()
```

在它**后面**添加：

```gdscript
	_ensure_saves_dir()
```

然后在 `_ensure_stories_dir` 函数**后面**添加新函数：

```gdscript
func _ensure_saves_dir() -> void:
	var saves_path: String = _get_game_root_dir() + "saves/"
	if not DirAccess.dir_exists_absolute(saves_path):
		var err := DirAccess.make_dir_absolute(saves_path)
		if err == OK:
			print("[Save] 已创建存档目录: " + saves_path)
		else:
			print("[Save] 创建存档目录失败: " + str(err))
	else:
		print("[Save] 存档目录已存在: " + saves_path)
```

## 修改4：移除 `_auto_save` 中的重复目录创建

找到 `_auto_save` 中的：

```gdscript
	# 确保存档目录存在
	var save_dir: String = _get_game_root_dir() + "saves/"
	if not DirAccess.dir_exists_absolute(save_dir):
		var err := DirAccess.make_dir_absolute(save_dir)
		if err == OK:
			print("[Save] 已创建存档目录: " + save_dir)
		else:
			print("[Save] 创建存档目录失败: " + str(err))
			return
```

**替换为：**（简化，因为启动时已经创建过了）

```gdscript
	var save_dir: String = _get_game_root_dir() + "saves/"
	if not DirAccess.dir_exists_absolute(save_dir):
		DirAccess.make_dir_absolute(save_dir)
```

---

改完后，导出的程序目录结构会是：

```
游戏目录/
├── game.exe
├── vdisc/
│   ├── story1.scp
│   └── story2.scp
└── saves/              ← 自动创建
    ├── save_story1.json
    └── save_story2.json
```

存档文件就在 exe 旁边的 `saves/` 文件夹里，方便用户备份和管理。

### USER
现在的UI比较丑，减少一下上下栏的发光；下面的输入栏只要最外层的一层框就行了，上面状态栏保持两层框，但左上侧显示路径的部分内框去掉；
然后增加一个背景，可以替换图片，背景使用shader为中间添加稍微发光然后两侧变暗亮度降低的效果。

### ASSISTANT
根据截图和你的需求，需要做以下调整：

---

## 修改1：调整上下栏样式（减少发光、调整边框层级）

找到 `_ready` 函数中设置 UI 边框样式的部分（`# === UI 边框样式 ===` 开头的那段），**整段替换为：**

```gdscript
	# === UI 边框样式 ===
	# 状态栏外框（StatusFrame）- 保留外层框，降低发光
	var status_frame_style := StyleBoxFlat.new()
	status_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
	status_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
	status_frame_style.set_border_width_all(1)
	status_frame_style.content_margin_left = 4
	status_frame_style.content_margin_right = 4
	status_frame_style.content_margin_top = 3
	status_frame_style.content_margin_bottom = 3
	status_frame.add_theme_stylebox_override("panel", status_frame_style)
	
	# PathLabel - 去掉内框（透明无边框）
	var path_label_style := StyleBoxFlat.new()
	path_label_style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
	path_label_style.border_color = Color(0.0, 0.0, 0.0, 0.0)
	path_label_style.set_border_width_all(0)
	path_label_style.content_margin_left = 6
	path_label_style.content_margin_right = 6
	path_label_style.content_margin_top = 2
	path_label_style.content_margin_bottom = 2
	path_label.add_theme_stylebox_override("normal", path_label_style)
	
	# MailIcon - 保留内框，降低发光
	var mail_style := StyleBoxFlat.new()
	mail_style.bg_color = Color(0.0, 0.03, 0.0, 0.6)
	mail_style.border_color = Color(0.2, 0.6, 0.2, 0.35)
	mail_style.set_border_width_all(1)
	mail_style.content_margin_left = 8
	mail_style.content_margin_right = 8
	mail_style.content_margin_top = 2
	mail_style.content_margin_bottom = 2
	mail_icon.add_theme_stylebox_override("normal", mail_style)
	
	# 输入区外框（InputFrame）- 只保留这一层框，降低发光
	var input_frame_style := StyleBoxFlat.new()
	input_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
	input_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
	input_frame_style.set_border_width_all(1)
	input_frame_style.content_margin_left = 4
	input_frame_style.content_margin_right = 4
	input_frame_style.content_margin_top = 3
	input_frame_style.content_margin_bottom = 3
	input_frame.add_theme_stylebox_override("panel", input_frame_style)
	
	# InputField - 去掉内框（透明无边框）
	var input_no_border := StyleBoxFlat.new()
	input_no_border.bg_color = Color(0.0, 0.0, 0.0, 0.0)
	input_no_border.border_color = Color(0.0, 0.0, 0.0, 0.0)
	input_no_border.set_border_width_all(0)
	input_no_border.content_margin_left = 6
	input_no_border.content_margin_right = 6
	input_no_border.content_margin_top = 2
	input_no_border.content_margin_bottom = 2
	input_field.add_theme_stylebox_override("normal", input_no_border)
	input_field.add_theme_stylebox_override("focus", input_no_border.duplicate())
	
```

---

## 修改2：添加可替换背景图 + Shader 暗角效果

### 2a：在场景中添加背景节点

在 Godot 编辑器中：

1. 在场景树**最顶层节点**（Control）的**最上方**（第一个子节点位置）添加 `TextureRect`，命名为 `Background`
2. 场景树顺序：

```
Control (根节点)
  ├── Background (TextureRect)    ← 新增，放在最前面确保在最底层
  └── MainContent (VBoxContainer)
      ├── StatusFrame
      ├── OutputArea
      └── InputFrame
```

3. 选中 `Background`，在属性面板设置：
   - **Layout** → Anchor Preset → Full Rect（铺满整个窗口）
   - **Stretch Mode** → `Keep Aspect Covered`
   - **Mouse Filter** → `Ignore`（不阻挡点击）

### 2b：创建 Shader 文件

在 `res://` 下新建文件 `background_vignette.gdshader`，内容：

```glsl
shader_type canvas_item;

// 暗角强度：值越大两侧越暗
uniform float vignette_strength : hint_range(0.0, 2.0) = 0.8;
// 暗角范围：值越小中间亮区越大
uniform float vignette_radius : hint_range(0.1, 2.0) = 0.9;
// 中心发光强度
uniform float glow_strength : hint_range(0.0, 0.5) = 0.08;
// 中心发光范围
uniform float glow_radius : hint_range(0.1, 1.0) = 0.4;
// 整体亮度调节
uniform float brightness : hint_range(0.0, 2.0) = 0.7;
// 绿色色调叠加（终端风格）
uniform vec4 tint_color : source_color = vec4(0.1, 0.3, 0.1, 0.15);

void fragment() {
    vec4 tex_color = texture(TEXTURE, UV);

    // 计算到中心的距离（椭圆形，水平方向更窄以适应宽屏）
    vec2 center = vec2(0.5, 0.5);
    vec2 dist_vec = (UV - center) * vec2(1.2, 1.0);
    float dist = length(dist_vec);

    // 暗角效果：两侧变暗
    float vignette = 1.0 - smoothstep(vignette_radius * 0.5, vignette_radius, dist);
    vignette = mix(1.0 - vignette_strength, 1.0, vignette);

    // 中心微发光
    float glow = exp(-dist * dist / (glow_radius * glow_radius)) * glow_strength;

    // 合成
    vec3 final_color = tex_color.rgb * brightness * vignette;
    final_color += vec3(glow * 0.3, glow, glow * 0.3); // 发光偏绿
    final_color = mix(final_color, tint_color.rgb, tint_color.a);

    COLOR = vec4(final_color, tex_color.a);
}
```

### 2c：添加代码引用和初始化

在 `@onready` 区域末尾添加：

```gdscript
@onready var background: TextureRect = $Background
```

在 `_ready` 函数中，`# === UI 边框样式 ===` 这行**前面**插入：

```gdscript
	# === 背景初始化 ===
	_setup_background()
	
```

然后在 `_ensure_saves_dir` 函数**后面**添加：

```gdscript
func _setup_background() -> void:
	# 尝试从外部加载背景图，没有就用纯色
	var bg_path: String = _get_game_root_dir() + "background.png"
	var tex: Texture2D = null
	
	if FileAccess.file_exists(bg_path):
		var image := Image.new()
		var err := image.load(bg_path)
		if err == OK:
			tex = ImageTexture.create_from_image(image)
			print("[UI] 已加载外部背景图: " + bg_path)
		else:
			print("[UI] 背景图加载失败: " + str(err))
	
	if tex == null:
		# 没有外部背景图，生成纯深色背景
		var image := Image.create(4, 4, false, Image.FORMAT_RGB8)
		image.fill(Color(0.02, 0.04, 0.02, 1.0))
		tex = ImageTexture.create_from_image(image)
		print("[UI] 使用默认深色背景")
	
	background.texture = tex
	background.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
	background.mouse_filter = Control.MOUSE_FILTER_IGNORE
	
	# 加载 Shader
	var shader_path: String = "res://background_vignette.gdshader"
	if ResourceLoader.exists(shader_path):
		var shader: Shader = load(shader_path)
		var mat := ShaderMaterial.new()
		mat.shader = shader
		mat.set_shader_parameter("vignette_strength", 0.8)
		mat.set_shader_parameter("vignette_radius", 0.9)
		mat.set_shader_parameter("glow_strength", 0.08)
		mat.set_shader_parameter("glow_radius", 0.4)
		mat.set_shader_parameter("brightness", 0.7)
		mat.set_shader_parameter("tint_color", Color(0.1, 0.3, 0.1, 0.15))
		background.material = mat
		print("[UI] 背景Shader已应用")
	else:
		print("[UI] 未找到背景Shader文件: " + shader_path)
```

---

## 总结

| 修改 | 效果 |
|------|------|
| 状态栏外框 | 保留，降低发光（透明度0.4） |
| PathLabel | 去掉内框 |
| MailIcon | 保留内框，降低发光 |
| 输入区外框 | 保留，降低发光 |
| InputField | 去掉内框，只有外层一个框 |
| Background | 支持外部 `background.png` 替换 |
| Shader | 中间微亮绿色发光，两侧暗角渐变 |

用户只需要把 `background.png` 放在 exe 同级目录就能替换背景图，不放则使用默认深色。

### USER
修改1：调整上下栏样式中的_ready函数如下，你给我一个修改好的版本。
func _ready() -> void:
_ensure_stories_dir()
_ensure_saves_dir()
# 启动时只扫描，不自动加载
var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# === UI 边框样式 ===
var frame_style := StyleBoxFlat.new()
frame_style.bg_color = Color(0.0, 0.06, 0.0, 0.95)
frame_style.border_color = Color(0.3, 0.8, 0.3, 0.5)
frame_style.set_border_width_all(1)
frame_style.content_margin_left = 6
frame_style.content_margin_right = 6
frame_style.content_margin_top = 4
frame_style.content_margin_bottom = 4
status_frame.add_theme_stylebox_override("panel", frame_style)
var input_frame_style := frame_style.duplicate()
input_frame_style.border_color = Color(0.3, 0.8, 0.3, 0.5)
input_frame.add_theme_stylebox_override("panel", input_frame_style)
output_text.text = ""
output_text.bbcode_enabled = true
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
# 状态栏 PathLabel 样式
var label_style := StyleBoxFlat.new()
label_style.bg_color = Color(0.0, 0.06, 0.0, 0.9)
label_style.border_color = Color(0.3, 0.8, 0.3, 0.5)
label_style.set_border_width_all(1)
label_style.content_margin_left = 10
label_style.content_margin_right = 10
label_style.content_margin_top = 3
label_style.content_margin_bottom = 3
path_label.add_theme_stylebox_override("normal", label_style)
# 状态栏 MailIcon 样式
var mail_style := label_style.duplicate()
mail_icon.add_theme_stylebox_override("normal", mail_style)
# 输入框样式
var input_normal := StyleBoxFlat.new()
input_normal.bg_color = Color(0.0, 0.06, 0.0, 0.9)
input_normal.border_color = Color(0.3, 0.8, 0.3, 0.5)
input_normal.set_border_width_all(1)
input_normal.content_margin_left = 10
input_normal.content_margin_right = 10
input_normal.content_margin_top = 4
input_normal.content_margin_bottom = 4
input_field.add_theme_stylebox_override("normal", input_normal)
var input_focus := input_normal.duplicate()
input_focus.border_color = Color(0.4, 1.0, 0.4, 0.8)
input_field.add_theme_stylebox_override("focus", input_focus)
input_field.focus_mode = Control.FOCUS_ALL
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
input_field.grab_focus()
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()

### ASSISTANT
根据你的需求（减少发光、输入栏只留外层框、状态栏保留两层但PathLabel去掉内框、加入背景初始化），以下是修改好的 `_ready` 函数完整版本：

```gdscript
func _ready() -> void:
	_ensure_stories_dir()
	_ensure_saves_dir()

	# 启动时只扫描，不自动加载
	var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	# === 背景初始化 ===
	_setup_background()

	# === UI 边框样式 ===

	# 状态栏外框（StatusFrame）- 保留外层框，降低发光
	var status_frame_style := StyleBoxFlat.new()
	status_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
	status_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
	status_frame_style.set_border_width_all(1)
	status_frame_style.content_margin_left = 4
	status_frame_style.content_margin_right = 4
	status_frame_style.content_margin_top = 3
	status_frame_style.content_margin_bottom = 3
	status_frame.add_theme_stylebox_override("panel", status_frame_style)

	# PathLabel - 去掉内框（透明无边框）
	var path_label_style := StyleBoxFlat.new()
	path_label_style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
	path_label_style.border_color = Color(0.0, 0.0, 0.0, 0.0)
	path_label_style.set_border_width_all(0)
	path_label_style.content_margin_left = 6
	path_label_style.content_margin_right = 6
	path_label_style.content_margin_top = 2
	path_label_style.content_margin_bottom = 2
	path_label.add_theme_stylebox_override("normal", path_label_style)

	# MailIcon - 保留内框，降低发光
	var mail_style := StyleBoxFlat.new()
	mail_style.bg_color = Color(0.0, 0.03, 0.0, 0.6)
	mail_style.border_color = Color(0.2, 0.6, 0.2, 0.35)
	mail_style.set_border_width_all(1)
	mail_style.content_margin_left = 8
	mail_style.content_margin_right = 8
	mail_style.content_margin_top = 2
	mail_style.content_margin_bottom = 2
	mail_icon.add_theme_stylebox_override("normal", mail_style)

	# 输入区外框（InputFrame）- 只保留这一层框，降低发光
	var input_frame_style := StyleBoxFlat.new()
	input_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
	input_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
	input_frame_style.set_border_width_all(1)
	input_frame_style.content_margin_left = 4
	input_frame_style.content_margin_right = 4
	input_frame_style.content_margin_top = 3
	input_frame_style.content_margin_bottom = 3
	input_frame.add_theme_stylebox_override("panel", input_frame_style)

	# InputField - 去掉内框（透明无边框），只靠外层 InputFrame 提供边框
	var input_no_border := StyleBoxFlat.new()
	input_no_border.bg_color = Color(0.0, 0.0, 0.0, 0.0)
	input_no_border.border_color = Color(0.0, 0.0, 0.0, 0.0)
	input_no_border.set_border_width_all(0)
	input_no_border.content_margin_left = 6
	input_no_border.content_margin_right = 6
	input_no_border.content_margin_top = 2
	input_no_border.content_margin_bottom = 2
	input_field.add_theme_stylebox_override("normal", input_no_border)
	input_field.add_theme_stylebox_override("focus", input_no_border.duplicate())

	output_text.text = ""
	output_text.bbcode_enabled = true
	output_text.selection_enabled = true
	output_text.meta_underlined = true
	output_text.meta_clicked.connect(_on_meta_clicked)

	input_field.focus_mode = Control.FOCUS_ALL
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
	input_field.grab_focus()

	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()
```

### 变更说明

| 部分 | 原来 | 修改后 |
|------|------|--------|
| 状态栏外框 | 发光 `0.5` | 降低到 `0.4`，背景更暗 |
| PathLabel | 有边框有背景 | **完全透明无边框** |
| MailIcon | 和PathLabel一样 | **单独保留内框**，发光 `0.35` |
| 输入区外框 | 发光 `0.5` | 降低到 `0.4` |
| InputField | 有自己的边框 | **完全透明无边框**，只靠外层框 |
| 背景 | 无 | 新增 `_setup_background()` 调用 [1] |

这样状态栏是"外框 + MailIcon内框"的两层结构，PathLabel无框直接显示文字；输入区只有外层一个框，InputField内部无边框。整体发光度都降低了。

### USER
报错了：
E 0:00:00:627   main.gd:14 @ @implicit_ready(): Node not found: "Background" (relative to "/root/Main").
  <C++ 错误>      Method/function failed. Returning: nullptr
  <C++ 源文件>     scene/main/node.cpp:1963 @ get_node()
  <栈追踪>         main.gd:14 @ @implicit_ready()
  
E 0:00:00:631   _setup_background: Invalid assignment of property or key 'texture' with value of type 'ImageTexture' on a base object of type 'null instance'.
  <GDScript 源文件>main.gd:1884 @ _setup_background()
  <栈追踪>         main.gd:1884 @ _setup_background()
                main.gd:82 @ _ready()
  
下面是所有的main.gd，你修改好错误原因，并进行仔细检查，并返回给我需要修改的部分，同时对结构优化一下方便之后的脚本拆分。注意不要全部发我，防止会话中断。
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
@onready var background: TextureRect = $Background
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false
# 桌面/终端模式
var _desktop_mode: bool = true             # true=桌面模式，false=终端模式（已加载磁盘）
# 打字机效果
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []  # [{path, title, id}]
var current_story_index: int = -1              # 当前加载的剧本索引
# 权限系统
var player_clearance: int = 0              # 当前权限等级
var story_permissions: Dictionary = {}      # 路径 -> 所需权限等级
var story_id: String = ""                   # 当前剧本唯一ID
var read_files: Array[String] = []          # 已读文件列表
var unlocked_passwords: Array[String] = []  # 已解锁的密码
# 密码输入弹窗状态
var _password_mode: bool = false            # 是否处于密码输入模式（unlock用）
var _password_target_path: String = ""      # 密码输入针对的路径（空表示通用unlock）
# 文件密码系统
var _file_password_mode: bool = false       # 是否处于文件密码输入模式
var _file_password_target: String = ""      # 当前等待密码的文件路径
var _file_password_filename: String = ""    # 当前等待密码的文件名（用于显示）
var story_file_passwords: Dictionary = {}   # 路径 -> {password, hint}
var unlocked_file_passwords: Array[String] = []  # 已解锁的文件路径列表
# ============================================================
# 初始化
# ============================================================
# 尝试加载剧本，如果失败则用测试数据
func _ready() -> void:
_ensure_stories_dir()
_ensure_saves_dir()
# 启动时只扫描，不自动加载
var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# === 背景初始化 ===
_setup_background()
# === UI 边框样式 ===
# 状态栏外框（StatusFrame）- 保留外层框，降低发光
var status_frame_style := StyleBoxFlat.new()
status_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
status_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
status_frame_style.set_border_width_all(1)
status_frame_style.content_margin_left = 4
status_frame_style.content_margin_right = 4
status_frame_style.content_margin_top = 3
status_frame_style.content_margin_bottom = 3
status_frame.add_theme_stylebox_override("panel", status_frame_style)
# PathLabel - 去掉内框（透明无边框）
var path_label_style := StyleBoxFlat.new()
path_label_style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
path_label_style.border_color = Color(0.0, 0.0, 0.0, 0.0)
path_label_style.set_border_width_all(0)
path_label_style.content_margin_left = 6
path_label_style.content_margin_right = 6
path_label_style.content_margin_top = 2
path_label_style.content_margin_bottom = 2
path_label.add_theme_stylebox_override("normal", path_label_style)
# MailIcon - 保留内框，降低发光
var mail_style := StyleBoxFlat.new()
mail_style.bg_color = Color(0.0, 0.03, 0.0, 0.6)
mail_style.border_color = Color(0.2, 0.6, 0.2, 0.35)
mail_style.set_border_width_all(1)
mail_style.content_margin_left = 8
mail_style.content_margin_right = 8
mail_style.content_margin_top = 2
mail_style.content_margin_bottom = 2
mail_icon.add_theme_stylebox_override("normal", mail_style)
# 输入区外框（InputFrame）- 只保留这一层框，降低发光
var input_frame_style := StyleBoxFlat.new()
input_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
input_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
input_frame_style.set_border_width_all(1)
input_frame_style.content_margin_left = 4
input_frame_style.content_margin_right = 4
input_frame_style.content_margin_top = 3
input_frame_style.content_margin_bottom = 3
input_frame.add_theme_stylebox_override("panel", input_frame_style)
# InputField - 去掉内框（透明无边框），只靠外层 InputFrame 提供边框
var input_no_border := StyleBoxFlat.new()
input_no_border.bg_color = Color(0.0, 0.0, 0.0, 0.0)
input_no_border.border_color = Color(0.0, 0.0, 0.0, 0.0)
input_no_border.set_border_width_all(0)
input_no_border.content_margin_left = 6
input_no_border.content_margin_right = 6
input_no_border.content_margin_top = 2
input_no_border.content_margin_bottom = 2
input_field.add_theme_stylebox_override("normal", input_no_border)
input_field.add_theme_stylebox_override("focus", input_no_border.duplicate())
output_text.text = ""
output_text.bbcode_enabled = true
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
input_field.focus_mode = Control.FOCUS_ALL
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
input_field.grab_focus()
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 鼠标滚轮滚动
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 点击任意位置聚焦输入框
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
# 点击任何键都确保输入框有焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果正在打字或加载，按空格或ESC跳过动画
if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
_typewriter_instant = true
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
# 如果正在打字，忽略回车（防止干扰）
if _is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
# 如果处于文件密码输入模式
if _file_password_mode:
_file_password_mode = false
input_field.placeholder_text = "> 输入命令..."
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 密码回显用星号
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消文件密码输入。[/color]\n", false)
_file_password_target = ""
_file_password_filename = ""
return
await _verify_file_password(raw_input)
return
# 如果处于密码输入模式
if _password_mode:
_password_mode = false
input_field.placeholder_text = "> 输入命令..."
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 密码回显用星号
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消密码输入。[/color]\n", false)
return
_verify_password(raw_input)
return
command_history.append(raw_input)
history_index = -1
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 命令回显用即时显示（不走打字机）
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
# 执行命令（命令输出走打字机效果）
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
_typewriter_instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
# 桌面模式：只允许少数命令
if _desktop_mode:
match command:
"load":
await _cmd_desktop_load(args)
"scan":
await _cmd_scan()
"clear", "cls":
_cmd_clear()
"exit", "quit":
await _cmd_exit()
"help", "?":
_cmd_desktop_help()
"vdisc", "disc", "disk":
_cmd_story_info()
"reboot", "restart":
await _cmd_reboot()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n[color=#AAAAAA]输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n", false)
return
# 终端模式：所有命令可用
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
if args.size() >= 1 and args[0].to_lower() == "load":
await _cmd_vdisc_load(args.slice(1))
else:
_cmd_story_info()
"unlock":
_cmd_unlock(args)
"scan":
await _cmd_scan()
"reboot", "restart":
await _cmd_reboot()
"eject":
await _cmd_eject()
"load":
append_output("[color=#AAAAAA]磁盘已加载。使用 [/color][color=#66FF66]eject[/color][color=#AAAAAA] 返回桌面后再切换磁盘，或使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 直接切换。[/color]\n", false)
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_desktop_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 桌面命令 ═══════════════[/color]")
lines.append("  [color=#66FF66]load <编号>[/color]   加载指定虚拟磁盘")
lines.append("  [color=#66FF66]scan[/color]   重新扫描vdisc目录")
lines.append("  [color=#66FF66]vdisc[/color] 查看磁盘列表详情")
lines.append("  [color=#66FF66]clear[/color] 清空屏幕")
lines.append("  [color=#66FF66]reboot[/color] 重启终端")
lines.append("  [color=#66FF66]exit[/color]   退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]vdisc[/color]         查看虚拟磁盘列表和信息")
lines.append("  [color=#66FF66]vdisc load <编号>[/color] 切换加载指定磁盘")
lines.append("  [color=#66FF66]scan[/color]          重新扫描虚拟磁盘")
lines.append("  [color=#66FF66]unlock[/color]        进入密码认证（或 unlock <密码>）")
lines.append("  [color=#66FF66]eject[/color]         卸载磁盘，返回桌面")
lines.append("  [color=#66FF66]reboot[/color]        重启终端")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
var item_required: int = _get_required_clearance(item_path)
var is_locked: bool = not _has_clearance(item_path)
if node.type == "folder":
if is_locked:
lines.append("  [color=#FF6666][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
else:
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
if is_locked:
lines.append("  [color=#FF6666][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
else:
# 检查是否需要文件密码
var fp_key: String = _get_file_password_key(item_path)
if not fp_key.is_empty() and not unlocked_file_passwords.has(item_path):
lines.append("  [color=#FFB000][FILE] " + item + "  [PASSWORD][/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
# 调试输出
print("[DEBUG] cd 目标: " + new_path + " 需要权限: " + str(_get_required_clearance(new_path)) + " 当前权限: " + str(player_clearance))
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(new_path)
if not _has_clearance(new_path):
var box: String = _build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
# 调试输出
print("[DEBUG] open 目标: " + file_path + " 需要权限: " + str(_get_required_clearance(file_path)) + " 当前权限: " + str(player_clearance))
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(file_path)
if not _has_clearance(file_path):
var box: String = _build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
# 文件密码检查（独立于权限等级）
var fp_key: String = _get_file_password_key(file_path)
if not fp_key.is_empty() and not unlocked_file_passwords.has(file_path):
# 需要文件密码且尚未解锁
var fp_info: Dictionary = story_file_passwords[fp_key]
var hint_text: String = fp_info.get("hint", "")
var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
if not hint_text.is_empty():
box_lines.append(["提示: " + hint_text])
box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
var box: String = _build_box_sectioned(box_lines, "#FFB000")
append_output(box + "\n", false)
# 进入文件密码输入模式
_file_password_mode = true
_file_password_target = file_path
_file_password_filename = filename
input_field.placeholder_text = "输入文件密码..."
return
# 先等待打字队列全部完成
while _is_typing:
await get_tree().process_frame
# 显示进度条（直接操作output_text，不走打字队列）
var content_size: int = node.content.length()
await _show_progress_bar(content_size)
# 进度条完成后等待一小会
await get_tree().create_timer(0.5).timeout
# 清屏进入阅读模式
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
# 显示文件头
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
# 记录已读
if not read_files.has(file_path):
read_files.append(file_path)
_auto_save()
# 显示文件内容（走打字机，不加额外空行）
# 清理内容：去除首尾空白，统一换行符为\n
var clean_content: String = node.content.strip_edges()
clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
append_output(clean_content, false)
# 文件尾放入队列，等内容打完后显示
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名: [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]" + str(player_clearance) + "[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
lines.append("  已解锁文件: [color=#66FF66]" + str(unlocked_file_passwords.size()) + "[/color]")
if not story_id.is_empty():
lines.append("  盘ID: [color=#AAAAAA]" + story_id + "[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty() and available_stories.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")
if available_stories.size() > 0:
lines.append("")
lines.append("  已发现 [color=#66FF66]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
var marker: String = ""
if i == current_story_index:
marker = " [color=#33FF33]<< 当前[/color]"
lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]" + marker)
lines.append(" 作者: [color=#AAAAAA]" + info.get("author", "未知") + "[/color]")
lines.append("")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 切换磁盘[/color]")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]scan[/color][color=#AAAAAA] 重新扫描目录[/color]")
# 当前加载的磁盘详细信息
if story_manifest.has("story"):
lines.append("")
lines.append("[color=#66FF66]─────────── 当前磁盘详情 ───────────[/color]")
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签: [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者:   [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本: [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述: [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数: [color=#66FF66]" + str(file_system.size()) + "[/color]")
lines.append("  磁盘来源: [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态: [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_vdisc_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: vdisc load <编号>[/color]\n[color=#AAAAAA]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1  # 用户输入从1开始
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
if index == current_story_index:
append_output("[color=#AAAAAA]该磁盘已经是当前加载的磁盘。[/color]\n", false)
return
# 保存当前剧本存档
_auto_save()
append_output("[color=#AAAAAA]正在卸载当前磁盘...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.3).timeout
# 重置状态
file_system.clear()
story_manifest.clear()
story_permissions.clear()
story_file_passwords.clear()
current_story_path = ""
story_id = ""
current_path = "/"
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
# 显示加载进度条
await _show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
# 加载新剧本
if _load_story_by_index(index):
var title: String = available_stories[index].get("title", "未知")
var box: String = _build_box_sectioned([
["DISC LOADED", "磁盘加载完成"],
[title]
], "#33FF33")
append_output(box + "\n", false)
_update_status_bar()
append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "  权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
append_output("[color=#AAAAAA]当前路径: " + current_path + "  权限等级: " + str(player_clearance) + "[/color]\n", false)
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
_init_test_file_system()
_update_status_bar()
func _cmd_unlock(args: Array) -> void:
# 如果带了参数，直接验证（兼容旧用法）
if not args.is_empty():
_verify_password(args[0])
return
# 无参数，进入密码输入模式
_enter_password_mode()
func _enter_password_mode(target_path: String = "") -> void:
_password_mode = true
_password_target_path = target_path
var box: String = _build_box_sectioned([
["SECURITY AUTHENTICATION", "安全认证系统"],
["请输入访问密码:", "(输入 cancel 取消)"]
], "#FFB000")
append_output(box + "\n", false)
# 修改输入框提示
input_field.placeholder_text = "输入密码..."
func _verify_password(password: String) -> void:
# 从manifest中查找密码
if not story_manifest.has("passwords"):
append_output("[color=#FF6666][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
return
var passwords: Dictionary = story_manifest["passwords"]
if passwords.has(password):
var pwd_info: Dictionary = passwords[password]
var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
if unlocked_passwords.has(password):
append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(player_clearance) + "[/color]\n", false)
return
if grant_level <= player_clearance:
append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。当前: " + str(player_clearance) + "[/color]\n", false)
return
# 解锁成功
unlocked_passwords.append(password)
var old_level: int = player_clearance
player_clearance = grant_level
_auto_save()
# 成功动画
var box: String = _build_box_sectioned([
["ACCESS GRANTED", "权限认证通过"],
["权限等级: " + str(old_level) + " -> " + str(player_clearance)]
], "#33FF33")
append_output(box + "\n", false)
# 显示提示信息（如果有）
if pwd_info.has("message"):
append_output("[color=#AAAAAA]" + str(pwd_info["message"]) + "[/color]\n", false)
else:
var box: String = _build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _cmd_scan() -> void:
append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
# 显示扫描进度条
await _show_progress_bar(500)
await get_tree().create_timer(0.3).timeout
# 保存旧状态用于对比
var old_story_path: String = current_story_path
var old_manifest: Dictionary = story_manifest.duplicate()
# 重置文件系统和权限
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
story_file_passwords.clear()
available_stories.clear()
current_story_index = -1
# 重新扫描
var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
if _desktop_mode:
# 桌面模式：只扫描，不自动加载
if available_stories.is_empty():
append_output("[color=#FFB000][WARN] 未找到虚拟磁盘文件。[/color]", false)
append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
else:
var scan_lines: Array[String] = []
scan_lines.append("[color=#33FF33][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
scan_lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
scan_lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]")
scan_lines.append("")
scan_lines.append("[color=#AAAAAA]输入 [/color][color=#66FF66]load <编号>[/color][color=#AAAAAA] 加载磁盘。[/color]")
append_output("\n".join(scan_lines) + "\n", false)
_update_status_bar()
else:
# 终端模式：重新加载当前磁盘
if available_stories.is_empty():
_desktop_mode = true
_init_test_file_system()
current_path = "/"
_update_status_bar()
append_output("[color=#FFB000][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
elif _load_story_by_index(0):
var title: String = "未知"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]", false)
append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "  权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
else:
current_path = "/"
_update_status_bar()
else:
append_output("[color=#FF6666][ERROR] 重新加载失败。[/color]\n", false)
func _cmd_reboot() -> void:
append_output("[color=#AAAAAA]正在重启终端...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 清空所有状态
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
command_history.clear()
history_index = -1
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
current_path = "/"
has_new_mail = false
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
story_file_passwords.clear()
available_stories.clear()
current_story_index = -1
# 重新加载
_ensure_stories_dir()
var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# 模拟重启效果
output_text.append_text("[color=#AAAAAA]...[/color]\n")
await get_tree().create_timer(0.3).timeout
output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
await get_tree().create_timer(0.5).timeout
output_text.text = ""
# 回到桌面
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
input_field.grab_focus()
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
# 只输入了一个词：补全命令
if parts.size() == 1:
# 检查是否已经是完整命令，后面有空格表示要补全参数
if current_text.ends_with(" "):
# 命令已输入完，补全文件名（无前缀匹配，列出所有）
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只补全文件夹，open/cat只补全文件
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
_do_scroll()
else:
# 补全命令名
var partial_cmd: String = parts[0].to_lower()
var commands: Array
if _desktop_mode:
commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
else:
commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
"scan", "reboot", "restart", "unlock", "eject"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 两个词：命令 + 部分文件名
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只匹配文件夹，open/cat只匹配文件
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
# 找公共前缀，补全到最长公共部分
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 查找多个字符串的最长公共前缀
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
if not _is_typing:
_process_typewriter_queue()
func _process_typewriter_queue() -> void:
if _typewriter_queue.is_empty():
_is_typing = false
return
_is_typing = true
var entry = _typewriter_queue.pop_front()
var text: String = entry["text"]
var extra_newline: bool = entry["extra_newline"]
if _typewriter_instant:
output_text.append_text(text)
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
else:
_typewrite_text(text, extra_newline)
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
var i: int = 0
var length: int = text.length()
_current_char_speed = _typewriter_speed
while i < length:
# 如果中途切换为即时模式，把剩余文本一次性输出
if _typewriter_instant:
output_text.append_text(text.substr(i))
break
# 检查是否是BBCode标签
if text[i] == "[":
var close_bracket: int = text.find("]", i)
if close_bracket != -1:
var tag: String = text.substr(i, close_bracket - i + 1)
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 判断是否是合法的BBCode标签（以字母或/开头）
var tag_inner: String = tag.substr(1, tag.length() - 2)
if tag_inner.length() > 0 and (tag_inner[0] == "/" or tag_inner[0].unicode_at(0) >= 65 and tag_inner[0].unicode_at(0) <= 122):
# 看起来像BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 不是BBCode标签，转义方括号后逐字输出
output_text.append_text("[lb]")
i += 1
continue
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 普通BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 普通字符
var ch: String = text[i]
# 换行符不单独append，而是收集连续的换行一次性输出
if ch == "\n":
var newlines: String = "\n"
i += 1
while i < length and text[i] == "\n":
newlines += "\n"
i += 1
output_text.append_text(newlines)
# 换行后的停顿
if not _typewriter_instant:
await get_tree().create_timer(_typewriter_period_pause).timeout
_do_scroll()
continue
output_text.append_text(ch)
i += 1
# 根据字符类型决定延迟
var delay: float = _current_char_speed
# 标点符号额外停顿（制造顿挫感）
if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
delay += _typewriter_period_pause
elif ch in ["、", "—", "-", "…"]:
delay += _typewriter_comma_pause
else:
# 随机顿挫：有一定概率额外停顿
if randf() < _typewriter_pause_chance:
delay += _typewriter_pause_duration
await get_tree().create_timer(delay).timeout
# 每隔几个字符滚动一次
if i % 8 == 0:
_do_scroll()
# 当前文本打完
if extra_newline:
output_text.append_text("\n")
_do_scroll()
# 继续处理队列
_process_typewriter_queue()
func _do_scroll() -> void:
_needs_scroll = true
func _process(_delta: float) -> void:
if _needs_scroll:
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
scroll_container.scroll_vertical = int(v_scroll.max_value)
_needs_scroll = false
# 显示文件加载进度条
# file_size: 文件内容长度，影响进度条速度
# speed_override: 速度倍率覆盖，-1表示用默认
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
var bar_width: int = 30  # 进度条总长度（字符数）
var speed: float = _progress_bar_speed
if speed_override > 0.0:
speed = speed_override
# 文件越大，每格停顿越长（但有上下限）
var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
base_delay /= speed
# 起始行
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("[color=#66FF66]加载中 [[/color]")
for i in range(bar_width):
if _typewriter_instant:
# 跳过动画，直接填满
var remaining: int = bar_width - i
output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
break
output_text.append_text("[color=#33FF33]█[/color]")
_do_scroll()
# 随机波动让进度条不匀速，更真实
var jitter: float = randf_range(0.7, 1.5)
await get_tree().create_timer(base_delay * jitter).timeout
output_text.append_text("[color=#66FF66]] 完成[/color]\n")
_do_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
if _desktop_mode:
path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
mail_icon.text = "[Mail]"
return
var disc_name: String = ""
if current_story_index >= 0 and current_story_index < available_stories.size():
disc_name = available_stories[current_story_index].get("title", "")
if disc_name.is_empty():
path_label.text = "[" + current_path + "]  LV:" + str(player_clearance)
else:
path_label.text = "[" + current_path + "]  LV:" + str(player_clearance) + "  DISC:" + disc_name
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
# 处理RichTextLabel中的超链接点击
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
# 如果是命令链接，直接执行
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
# 如果是文件链接，打开文件
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
var box: String = _build_box([title, subtitle] as Array[String], "#66FF66")
output_text.append_text(box + "\n\n")
# 显示磁盘列表
if available_stories.is_empty():
output_text.append_text("[color=#FFB000]未检测到虚拟磁盘。[/color]\n")
output_text.append_text("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
else:
output_text.append_text("[color=#66FF66]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
output_text.append_text("  [color=#FFB000]" + str(i + 1) + ".[/color] [color=#66FF66]" + info.get("title", "未知") + "[/color]\n")
output_text.append_text(" [color=#AAAAAA]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
output_text.append_text("\n")
output_text.append_text("[color=#AAAAAA]可用命令:[/color]\n")
output_text.append_text("  [color=#66FF66]load <编号>[/color]   加载指定磁盘\n")
output_text.append_text("  [color=#66FF66]scan[/color]   重新扫描磁盘目录\n")
output_text.append_text("  [color=#66FF66]clear[/color] 清空屏幕\n")
output_text.append_text("  [color=#66FF66]exit[/color]   退出终端\n")
func _cmd_desktop_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: load <编号>[/color]", false)
if available_stories.size() > 0:
append_output("[color=#AAAAAA]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
append_output("[color=#AAAAAA]正在加载虚拟磁盘...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
# 显示加载进度条
await _show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
# 加载剧本
if _load_story_by_index(index):
_desktop_mode = false
var title: String = available_stories[index].get("title", "未知")
# 清屏并显示终端欢迎
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
_update_status_bar()
_show_welcome_message()
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
func _cmd_eject() -> void:
if _desktop_mode:
append_output("[color=#AAAAAA]当前已在桌面模式。[/color]\n", false)
return
# 保存当前剧本存档
_auto_save()
append_output("[color=#AAAAAA]正在卸载磁盘...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 重置终端状态
file_system.clear()
story_manifest.clear()
story_permissions.clear()
story_file_passwords.clear()
current_story_path = ""
story_id = ""
current_path = "/"
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
current_story_index = -1
# 切换到桌面模式
_desktop_mode = true
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
# 计算框的宽度：取较长的那行，两侧各留3个空格
var max_len: int = max(title.length(), subtitle.length())
# 中英文混排时，中文字符占2个宽度，英文占1个
var title_display_len: int = _display_width(title)
var subtitle_display_len: int = _display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
# 居中填充
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func _display_width(text: String) -> int:
var width: int = 0
for ch in text:
var code: int = ch.unicode_at(0)
if code >= 0x4E00 and code <= 0x9FFF:
width += 2  # CJK统一汉字
elif code >= 0x3000 and code <= 0x303F:
width += 2  # CJK标点
elif code >= 0xFF00 and code <= 0xFFEF:
width += 2  # 全角字符
else:
width += 1
return width
# 生成自适应宽度的文本框
# lines_data: 每行文本内容（纯文本，不含颜色标签）
# color: 框的颜色代码（如 #33FF33）
# 返回带BBCode的完整框字符串
func _build_box(lines_data: Array[String], color: String) -> String:
# 计算最宽行的显示宽度
var max_width: int = 0
for line in lines_data:
var w: int = _display_width(line)
if w > max_width:
max_width = w
# 内部宽度 = 最宽行 + 左右各2个空格padding
var inner_width: int = max_width + 4
var border_h: String = "═".repeat(inner_width)
var result: String = ""
result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
for i in range(lines_data.size()):
var line: String = lines_data[i]
var line_width: int = _display_width(line)
var pad_total: int = inner_width - line_width
var pad_left: int = pad_total / 2
var pad_right: int = pad_total - pad_left
result += "[color=" + color + "]║" + " ".repeat(pad_left) + line + " ".repeat(pad_right) + "║[/color]\n"
# 如果不是最后一行，且下一行是分隔线标记，插入中间分隔
# 用特殊标记 "---" 表示需要插入分隔线
result += "[color=" + color + "]╚" + border_h + "╝[/color]"
return result
# 生成带中间分隔线的自适应方框
# sections: 二维数组，每个元素是一组行文本，组之间用分隔线隔开
func _build_box_sectioned(sections: Array, color: String) -> String:
# 计算所有行中最宽的显示宽度
var max_width: int = 0
for section in sections:
for line in section:
var w: int = _display_width(str(line))
if w > max_width:
max_width = w
var inner_width: int = max_width + 4
var border_h: String = "═".repeat(inner_width)
var divider_h: String = "═".repeat(inner_width)
var result: String = ""
result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
for s_idx in range(sections.size()):
var section: Array = sections[s_idx]
for line in section:
var line_str: String = str(line)
var line_width: int = _display_width(line_str)
var pad_total: int = inner_width - line_width
var pad_left: int = pad_total / 2
var pad_right: int = pad_total - pad_left
result += "[color=" + color + "]║" + " ".repeat(pad_left) + line_str + " ".repeat(pad_right) + "║[/color]\n"
# 在 section 之间插入分隔线（最后一组不加）
if s_idx < sections.size() - 1:
result += "[color=" + color + "]╠" + divider_h + "╣[/color]\n"
result += "[color=" + color + "]╚" + border_h + "╝[/color]"
return result
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
# 检查路径是否需要权限，返回所需等级（0表示无需权限）
func _get_required_clearance(path: String) -> int:
path = _normalize_path(path)
var highest: int = 0
for perm_path in story_permissions.keys():
var perm_value: int = int(float(story_permissions[perm_path]))
var normalized_perm: String = _normalize_path(perm_path)
# 精确匹配
if path == normalized_perm:
highest = max(highest, perm_value)
continue
# 目录前缀匹配：检查path是否在该目录下
var dir_prefix: String = normalized_perm + "/"
if path.begins_with(dir_prefix):
highest = max(highest, perm_value)
return highest
# 检查玩家是否有权限访问该路径
func _has_clearance(path: String) -> bool:
return player_clearance >= _get_required_clearance(path)
# 检查文件是否需要密码，返回对应的密码表key（空字符串表示不需要）
func _get_file_password_key(file_path: String) -> String:
file_path = _normalize_path(file_path)
# 精确匹配
for fp_path in story_file_passwords.keys():
var normalized_fp: String = _normalize_path(fp_path)
if file_path == normalized_fp:
return fp_path
return ""
# 验证文件密码
func _verify_file_password(input_password: String) -> void:
var fp_key: String = _get_file_password_key(_file_password_target)
if fp_key.is_empty():
append_output("[color=#FF6666][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
return
var fp_info: Dictionary = story_file_passwords[fp_key]
var correct_password: String = str(fp_info.get("password", ""))
if input_password == correct_password:
# 密码正确
unlocked_file_passwords.append(_file_password_target)
_auto_save()
var box: String = _build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], "#33FF33")
append_output(box + "\n", false)
# 等打字完成后自动打开文件
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 重新执行打开文件
await _cmd_open([_file_password_filename])
else:
var box: String = _build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
var content: String = entry.get("content", "")
# 统一换行符，防止\r\n导致双倍行距
content = content.replace("\r\n", "\n").replace("\r", "\n")
return FSNode.new(entry.get("type", "file"), content)
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 存档读档功能
# ============================================================
func _get_save_path() -> String:
return _get_game_root_dir() + "saves/save_" + story_id + ".json"
func _auto_save() -> void:
if story_id.is_empty():
return
var save_dir: String = _get_game_root_dir() + "saves/"
if not DirAccess.dir_exists_absolute(save_dir):
DirAccess.make_dir_absolute(save_dir)
var save_data: Dictionary = {
"story_id": story_id,
"player_clearance": player_clearance,
"read_files": read_files,
"unlocked_passwords": unlocked_passwords,
"unlocked_file_passwords": unlocked_file_passwords,
"current_path": current_path
}
var save_path: String = _get_save_path()
print("[Save] 存档路径: " + save_path)
var file := FileAccess.open(save_path, FileAccess.WRITE)
if file:
file.store_string(JSON.stringify(save_data, "\t"))
file.close()
print("[Save] 已保存: " + _get_save_path())
func _load_save() -> bool:
var path: String = _get_save_path()
print("[Save] 尝试加载存档: " + path)
if not FileAccess.file_exists(path):
print("[Save] 存档不存在，使用默认设置")
return false
var file := FileAccess.open(path, FileAccess.READ)
if file == null:
return false
var json_text: String = file.get_as_text()
file.close()
var json := JSON.new()
if json.parse(json_text) != OK:
return false
var data: Dictionary = json.data
if data.get("story_id", "") != story_id:
return false
player_clearance = int(data.get("player_clearance", 0))
read_files.clear()
if data.has("read_files"):
for f in data["read_files"]:
read_files.append(str(f))
unlocked_passwords.clear()
if data.has("unlocked_passwords"):
for p in data["unlocked_passwords"]:
unlocked_passwords.append(str(p))
unlocked_file_passwords.clear()
if data.has("unlocked_file_passwords"):
for p in data["unlocked_file_passwords"]:
unlocked_file_passwords.append(str(p))
if data.has("current_path"):
var saved_path: String = data["current_path"]
# 验证存档路径是否有权限访问，没有则重置到起始路径
if _has_clearance(saved_path):
current_path = saved_path
else:
current_path = "/"
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
print("[Save] 已加载存档: " + path)
print("[Save] 权限等级: " + str(player_clearance))
return true
# 获取游戏根目录（编辑器中为项目目录，导出后为exe所在目录）
func _get_game_root_dir() -> String:
if OS.has_feature("editor"):
return ProjectSettings.globalize_path("res://")
else:
return OS.get_executable_path().get_base_dir() + "/"
func _ensure_stories_dir() -> void:
var vdisc_path: String = _get_game_root_dir() + "vdisc/"
if not DirAccess.dir_exists_absolute(vdisc_path):
var err := DirAccess.make_dir_absolute(vdisc_path)
if err == OK:
print("[StoryLoader] 已创建vdisc目录: " + vdisc_path)
else:
print("[StoryLoader] 创建vdisc目录失败: " + str(err))
else:
print("[StoryLoader] vdisc目录已存在: " + vdisc_path)
func _ensure_saves_dir() -> void:
var saves_path: String = _get_game_root_dir() + "saves/"
if not DirAccess.dir_exists_absolute(saves_path):
var err := DirAccess.make_dir_absolute(saves_path)
if err == OK:
print("[Save] 已创建存档目录: " + saves_path)
else:
print("[Save] 创建存档目录失败: " + str(err))
else:
print("[Save] 存档目录已存在: " + saves_path)
func _setup_background() -> void:
# 尝试从外部加载背景图，没有就用纯色
var bg_path: String = _get_game_root_dir() + "background.png"
var tex: Texture2D = null
if FileAccess.file_exists(bg_path):
var image := Image.new()
var err := image.load(bg_path)
if err == OK:
tex = ImageTexture.create_from_image(image)
print("[UI] 已加载外部背景图: " + bg_path)
else:
print("[UI] 背景图加载失败: " + str(err))
if tex == null:
# 没有外部背景图，生成纯深色背景
var image := Image.create(4, 4, false, Image.FORMAT_RGB8)
image.fill(Color(0.02, 0.04, 0.02, 1.0))
tex = ImageTexture.create_from_image(image)
print("[UI] 使用默认深色背景")
background.texture = tex
background.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
background.mouse_filter = Control.MOUSE_FILTER_IGNORE
# 加载 Shader
var shader_path: String = "res://background_vignette.gdshader"
if ResourceLoader.exists(shader_path):
var shader: Shader = load(shader_path)
var mat := ShaderMaterial.new()
mat.shader = shader
mat.set_shader_parameter("vignette_strength", 0.8)
mat.set_shader_parameter("vignette_radius", 0.9)
mat.set_shader_parameter("glow_strength", 0.08)
mat.set_shader_parameter("glow_radius", 0.4)
mat.set_shader_parameter("brightness", 0.7)
mat.set_shader_parameter("tint_color", Color(0.1, 0.3, 0.1, 0.15))
background.material = mat
print("[UI] 背景Shader已应用")
else:
print("[UI] 未找到背景Shader文件: " + shader_path)
# 尝试从 vdisc 目录加载第一个 .scp 文件
func _try_load_story() -> bool:
var vdisc_dir: String = _get_game_root_dir() + "vdisc/"
print("[StoryLoader] 搜索目录: " + vdisc_dir)
_scan_available_stories(vdisc_dir)
# 不再自动加载，由桌面模式的 load 命令触发
return not available_stories.is_empty()
# 扫描 vdisc 目录下所有可用的 .scp/.zip 文件
func _scan_available_stories(vdisc_dir: String) -> void:
available_stories.clear()
if not DirAccess.dir_exists_absolute(vdisc_dir):
return
var dir := DirAccess.open(vdisc_dir)
if dir == null:
return
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = vdisc_dir + file_name
# 快速预读 manifest 获取标题和ID
var info: Dictionary = _peek_story_info(full_path)
info["path"] = full_path
info["filename"] = file_name
available_stories.append(info)
print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
file_name = dir.get_next()
print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")
# 快速预读 .scp 文件的 manifest，只提取标题和ID
func _peek_story_info(path: String) -> Dictionary:
var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}
var reader := ZIPReader.new()
if reader.open(path) != OK:
return info
var files := reader.get_files()
for file_path in files:
var filename: String = file_path.get_file()
if filename == "manifest.json":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
var json := JSON.new()
if json.parse(content) == OK and json.data is Dictionary:
var data: Dictionary = json.data
if data.has("story"):
var story_info: Dictionary = data["story"]
info["title"] = story_info.get("title", "未知剧本")
info["id"] = story_info.get("id", "")
info["author"] = story_info.get("author", "未知")
break
elif filename == "manifest.cfg":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
# 简单解析 cfg 获取标题
for line in content.split("\n"):
line = line.strip_edges()
if line.begins_with("title="):
info["title"] = line.substr(6).strip_edges()
elif line.begins_with("id="):
info["id"] = line.substr(3).strip_edges()
elif line.begins_with("author="):
info["author"] = line.substr(7).strip_edges()
break
reader.close()
return info
# 按索引加载指定剧本
func _load_story_by_index(index: int) -> bool:
if index < 0 or index >= available_stories.size():
return false
var story_info: Dictionary = available_stories[index]
var path: String = story_info["path"]
if _load_story_file(path):
current_story_index = index
return true
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据
file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 读取盘ID
if story_manifest.has("story") and story_manifest["story"].has("id"):
story_id = story_manifest["story"]["id"]
else:
# 没有id就用文件名的哈希作为id
story_id = str(path.get_file().hash())
# 读取权限表
story_permissions.clear()
if story_manifest.has("permissions"):
var perms: Dictionary = story_manifest["permissions"]
for perm_path in perms.keys():
story_permissions[perm_path] = int(perms[perm_path])
print("[StoryLoader] 权限表已加载，共 " + str(story_permissions.size()) + " 条规则")
else:
print("[StoryLoader] 警告: manifest中未找到permissions字段")
if story_manifest.has("passwords"):
print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
else:
print("[StoryLoader] 警告: manifest中未找到passwords字段")
# 读取文件密码表
story_file_passwords.clear()
if story_manifest.has("file_passwords"):
var fps: Dictionary = story_manifest["file_passwords"]
for fp_path in fps.keys():
story_file_passwords[fp_path] = fps[fp_path]
print("[StoryLoader] 文件密码表已加载，共 " + str(story_file_passwords.size()) + " 条")
else:
print("[StoryLoader] 未配置文件密码表（file_passwords）")
# 应用 manifest 中的设置
var start_clearance: int = 0
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
_typewriter_speed = settings["typing_speed"].to_float()
if settings.has("start_clearance"):
start_clearance = int(settings["start_clearance"])
# 尝试加载该剧本的存档
if not _load_save():
# 没有存档，用初始权限
player_clearance = start_clearance
read_files.clear()
unlocked_passwords.clear()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 盘ID: " + story_id)
print("[StoryLoader] 文件数量: " + str(file_system.size()))
print("[StoryLoader] 权限等级: " + str(player_clearance))
print("[StoryLoader] story_permissions 内容: " + str(story_permissions))
print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
return true
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
## 错误分析

报错原因是 `$Background` 节点在场景树中不存在。你之前可能没有在 Godot 编辑器中添加这个 `TextureRect` 节点。

解决方案有两种：
- **方案A**：在编辑器中手动添加节点（推荐）
- **方案B**：用代码动态创建（不需要改场景）

我用**方案B**，这样你不需要改场景文件。

---

## 修改1：删除 `@onready` 中的 background 引用

找到：

```gdscript
@onready var background: TextureRect = $Background
```

**替换为：**

```gdscript
var background: TextureRect = null  # 由代码动态创建
```

---

## 修改2：修改 `_setup_background` 函数，动态创建节点

找到整个 `_setup_background` 函数，**替换为：**

```gdscript
func _setup_background() -> void:
	# 动态创建 Background 节点（不依赖场景树中预设的节点）
	background = TextureRect.new()
	background.name = "Background"
	add_child(background)
	# 移到最底层，确保不遮挡其他UI
	move_child(background, 0)
	
	# 铺满整个窗口
	background.set_anchors_preset(Control.PRESET_FULL_RECT)
	background.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
	background.mouse_filter = Control.MOUSE_FILTER_IGNORE
	
	# 尝试从外部加载背景图，没有就用纯色
	var bg_path: String = _get_game_root_dir() + "background.png"
	var tex: Texture2D = null
	
	if FileAccess.file_exists(bg_path):
		var image := Image.new()
		var err := image.load(bg_path)
		if err == OK:
			tex = ImageTexture.create_from_image(image)
			print("[UI] 已加载外部背景图: " + bg_path)
		else:
			print("[UI] 背景图加载失败: " + str(err))
	
	if tex == null:
		# 没有外部背景图，生成纯深色背景
		var image := Image.create(4, 4, false, Image.FORMAT_RGB8)
		image.fill(Color(0.02, 0.04, 0.02, 1.0))
		tex = ImageTexture.create_from_image(image)
		print("[UI] 使用默认深色背景")
	
	background.texture = tex
	
	# 加载 Shader
	var shader_path: String = "res://background_vignette.gdshader"
	if ResourceLoader.exists(shader_path):
		var shader: Shader = load(shader_path)
		var mat := ShaderMaterial.new()
		mat.shader = shader
		mat.set_shader_parameter("vignette_strength", 0.8)
		mat.set_shader_parameter("vignette_radius", 0.9)
		mat.set_shader_parameter("glow_strength", 0.08)
		mat.set_shader_parameter("glow_radius", 0.4)
		mat.set_shader_parameter("brightness", 0.7)
		mat.set_shader_parameter("tint_color", Color(0.1, 0.3, 0.1, 0.15))
		background.material = mat
		print("[UI] 背景Shader已应用")
	else:
		print("[UI] 未找到背景Shader文件: " + shader_path)
```

---

## 修改3：确保 MainContent 也在背景之上

在 `_ready` 函数中，找到 `_setup_background()` 这行的**后面**，添加一行：

```gdscript
	# === 背景初始化 ===
	_setup_background()
	# 确保主内容在背景之上
	var main_content := $MainContent
	if main_content:
		move_child(main_content, get_child_count() - 1)
```

同时还需要让 MainContent 的背景透明，否则会遮挡背景图。在这行后面继续添加：

```gdscript
	# 让主内容区背景透明以显示底层背景图
	if main_content is Control:
		var transparent_style := StyleBoxFlat.new()
		transparent_style.bg_color = Color(0, 0, 0, 0)
		transparent_style.set_border_width_all(0)
		main_content.add_theme_stylebox_override("panel", transparent_style)
```

---

## 总结

只需改3处：

| 修改 | 内容 |
|------|------|
| `@onready var background` | 改为普通 `var`，不绑定场景节点 |
| `_setup_background()` | 动态创建 `TextureRect` 并插入场景最底层 |
| `_ready` 中 | 创建背景后确保 MainContent 在其上方，且背景透明 |

这样完全不需要手动改场景文件，代码会自动创建背景节点。

### USER
下面准备脚本功能拆分，文件结构如图所示，你规划一下然后我们开始。

### ASSISTANT
# 脚本拆分规划

根据你的文件结构截图，当前 `main.gd` 承载了所有功能，需要按职责拆分。以下是我的规划：

---

## 当前文件结构

```
res://
├── fonts/
├── saves/
├── scenes/
│   └── main.tscn
├── scripts/
│   ├── crt_shader.gd
│   ├── main.gd          ← 目前所有逻辑都在这里
│   ├── story_loader.gd   ← 已独立
│   └── test.gd
├── shaders/
│   ├── background_vignette.gdsh...
│   └── crt_effect.gdshader
└── vdisc/
```

## 拆分目标

将 `main.gd` 按功能拆分为 **6个脚本**：

```
scripts/
├── main.gd                 ← 主控：节点引用、_ready、模式切换、输入分发
├── terminal_commands.gd    ← 所有命令实现（help/ls/cd/open/status/mail等）
├── desktop_manager.gd      ← 桌面模式（欢迎页、load、eject、桌面命令）
├── typewriter.gd           ← 打字机效果（队列、逐字输出、进度条）
├── file_system.gd          ← 虚拟文件系统（路径工具、节点查询、权限检查）
├── save_manager.gd         ← 存档/读档/目录管理
├── ui_manager.gd           ← UI样式初始化、背景、状态栏更新
├── story_loader.gd         ← 已独立，不动
├── crt_shader.gd           ← 已独立，不动
└── test.gd
```

## 各脚本职责明细

| 脚本 | 职责 | 包含的函数 |
|------|------|-----------|
| **main.gd** | 主控入口，持有所有节点引用和状态变量，分发输入 | `_ready`, `_input`, `_process`, `_on_command_submitted`, `_execute_command`, `_on_meta_clicked` |
| **terminal_commands.gd** | 终端模式下所有命令 | `_cmd_help`, `_cmd_ls`, `_cmd_cd`, `_cmd_open`, `_cmd_back`, `_cmd_clear`, `_cmd_status`, `_cmd_mail`, `_cmd_exit`, `_cmd_whoami`, `_cmd_story_info`, `_cmd_vdisc_load`, `_cmd_unlock`, `_cmd_scan`, `_cmd_reboot`, `_enter_password_mode`, `_verify_password`, `_verify_file_password` |
| **desktop_manager.gd** | 桌面模式 | `_show_desktop_welcome`, `_cmd_desktop_load`, `_cmd_desktop_help`, `_cmd_eject` |
| **typewriter.gd** | 打字机引擎 | `append_output`, `_process_typewriter_queue`, `_typewrite_text`, `_show_progress_bar`, `_do_scroll` |
| **file_system.gd** | 虚拟文件系统工具 | `FSNode类`, `_join_path`, `_get_parent_path`, `_normalize_path`, `_get_node_at_path`, `_get_children_at_path`, `_get_required_clearance`, `_has_clearance`, `_get_file_password_key`, `_init_test_file_system`, `_build_box`, `_build_box_sectioned`, `_display_width` |
| **save_manager.gd** | 存档系统 | `_get_save_path`, `_auto_save`, `_load_save`, `_ensure_saves_dir`, `_ensure_stories_dir`, `_get_game_root_dir` |
| **ui_manager.gd** | UI初始化与更新 | `_setup_background`, `_update_status_bar`, UI样式代码, `_show_welcome_message`, `_auto_complete`, `_history_previous`, `_history_next`, `_find_common_prefix` |

## 技术方案

采用**组合模式**：各模块作为普通 `.gd` 类实例化，由 `main.gd` 持有引用并传入所需的节点和数据 [1]：

```gdscript
# main.gd 中
var cmd_handler: TerminalCommands
var desktop_mgr: DesktopManager
var typewriter: Typewriter
# 等等...
```

## 拆分顺序（由简到复杂）

1. **save_manager.gd** — 最独立，无 UI 依赖
2. **file_system.gd** — 纯数据操作，无 UI 依赖
3. **typewriter.gd** — 只依赖 output_text 和 scroll_container
4. **ui_manager.gd** — 依赖节点引用
5. **desktop_manager.gd** — 依赖 typewriter 和 file_system
6. **terminal_commands.gd** — 依赖最多，最后拆

---

确认这个方案后我们就从第1个 `save_manager.gd` 开始拆。你觉得这个规划可以吗？有需要调整的地方吗？

### USER
没问题，我已经把项目备份好了，开始拆分吧

### ASSISTANT
好的，备份做好了就开始！按照规划从最独立的模块开始。

---

# 第1步：拆分 save_manager.gd

## 1a：创建新文件 `res://scripts/save_manager.gd`

```gdscript
class_name SaveManager
extends RefCounted

# ============================================================
# 存档管理器 - 负责存档/读档/目录管理/路径工具
# ============================================================

# 获取游戏根目录（编辑器中为项目目录，导出后为exe所在目录）
func get_game_root_dir() -> String:
	if OS.has_feature("editor"):
		return ProjectSettings.globalize_path("res://")
	else:
		return OS.get_executable_path().get_base_dir() + "/"

# 确保 vdisc 目录存在
func ensure_stories_dir() -> void:
	var vdisc_path: String = get_game_root_dir() + "vdisc/"
	if not DirAccess.dir_exists_absolute(vdisc_path):
		var err := DirAccess.make_dir_absolute(vdisc_path)
		if err == OK:
			print("[SaveManager] 已创建vdisc目录: " + vdisc_path)
		else:
			print("[SaveManager] 创建vdisc目录失败: " + str(err))
	else:
		print("[SaveManager] vdisc目录已存在: " + vdisc_path)

# 确保 saves 目录存在
func ensure_saves_dir() -> void:
	var saves_path: String = get_game_root_dir() + "saves/"
	if not DirAccess.dir_exists_absolute(saves_path):
		var err := DirAccess.make_dir_absolute(saves_path)
		if err == OK:
			print("[SaveManager] 已创建存档目录: " + saves_path)
		else:
			print("[SaveManager] 创建存档目录失败: " + str(err))
	else:
		print("[SaveManager] 存档目录已存在: " + saves_path)

# 获取存档文件路径
func get_save_path(story_id: String) -> String:
	return get_game_root_dir() + "saves/save_" + story_id + ".json"

# 自动保存
func auto_save(story_id: String, player_clearance: int, read_files: Array[String],
		unlocked_passwords: Array[String], unlocked_file_passwords: Array[String],
		current_path: String) -> void:
	if story_id.is_empty():
		return

	var save_dir: String = get_game_root_dir() + "saves/"
	if not DirAccess.dir_exists_absolute(save_dir):
		DirAccess.make_dir_absolute(save_dir)

	var save_data: Dictionary = {
		"story_id": story_id,
		"player_clearance": player_clearance,
		"read_files": read_files,
		"unlocked_passwords": unlocked_passwords,
		"unlocked_file_passwords": unlocked_file_passwords,
		"current_path": current_path
	}

	var save_path: String = get_save_path(story_id)
	print("[SaveManager] 存档路径: " + save_path)

	var file := FileAccess.open(save_path, FileAccess.WRITE)
	if file:
		file.store_string(JSON.stringify(save_data, "\t"))
		file.close()
		print("[SaveManager] 已保存: " + save_path)

# 加载存档，返回 Dictionary 或 null
func load_save(story_id: String) -> Variant:
	var path: String = get_save_path(story_id)
	print("[SaveManager] 尝试加载存档: " + path)

	if not FileAccess.file_exists(path):
		print("[SaveManager] 存档不存在，使用默认设置")
		return null

	var file := FileAccess.open(path, FileAccess.READ)
	if file == null:
		return null

	var json_text: String = file.get_as_text()
	file.close()

	var json := JSON.new()
	if json.parse(json_text) != OK:
		return null

	var data: Dictionary = json.data
	if data.get("story_id", "") != story_id:
		return null

	print("[SaveManager] 已加载存档: " + path)
	return data
```

---

## 1b：修改 main.gd

### 添加 SaveManager 实例

找到状态变量区域开头的：

```gdscript
var current_path: String = "/"
```

在它**前面**添加：

```gdscript
# 模块实例
var save_mgr: SaveManager = SaveManager.new()
```

### 替换 _ready 中的调用

找到 `_ready` 函数中的：

```gdscript
	_ensure_stories_dir()
	_ensure_saves_dir()
```

**替换为：**

```gdscript
	save_mgr.ensure_stories_dir()
	save_mgr.ensure_saves_dir()
```

### 替换所有 `_get_game_root_dir()` 调用

在整个 main.gd 中，用**查找替换**把所有：

```
_get_game_root_dir()
```

替换为：

```
save_mgr.get_game_root_dir()
```

### 替换所有 `_auto_save()` 调用

在整个 main.gd 中搜索每一处 `_auto_save()`（大约有4-5处），将每处：

```gdscript
_auto_save()
```

**替换为：**

```gdscript
save_mgr.auto_save(story_id, player_clearance, read_files, unlocked_passwords, unlocked_file_passwords, current_path)
```

### 替换 `_load_save()` 调用

找到 `_load_story_file` 函数中的：

```gdscript
	# 尝试加载该剧本的存档
	if not _load_save():
		# 没有存档，用初始权限
		player_clearance = start_clearance
		read_files.clear()
		unlocked_passwords.clear()
```

**替换为：**

```gdscript
	# 尝试加载该剧本的存档
	var save_data = save_mgr.load_save(story_id)
	if save_data != null:
		player_clearance = int(save_data.get("player_clearance", 0))
		read_files.clear()
		if save_data.has("read_files"):
			for f in save_data["read_files"]:
				read_files.append(str(f))
		unlocked_passwords.clear()
		if save_data.has("unlocked_passwords"):
			for p in save_data["unlocked_passwords"]:
				unlocked_passwords.append(str(p))
		unlocked_file_passwords.clear()
		if save_data.has("unlocked_file_passwords"):
			for p in save_data["unlocked_file_passwords"]:
				unlocked_file_passwords.append(str(p))
		if save_data.has("current_path"):
			var saved_path: String = save_data["current_path"]
			if _has_clearance(saved_path):
				current_path = saved_path
			else:
				current_path = "/"
				if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
					current_path = story_manifest["settings"]["start_path"]
		print("[Save] 权限等级: " + str(player_clearance))
	else:
		# 没有存档，用初始权限
		player_clearance = start_clearance
		read_files.clear()
		unlocked_passwords.clear()
```

### 删除 main.gd 中的旧函数

删除以下函数（整个删掉）：

1. `func _get_game_root_dir()` [1]
2. `func _ensure_stories_dir()` [1]
3. `func _ensure_saves_dir()` [1]
4. `func _get_save_path()` [1]
5. `func _auto_save()` [1]
6. `func _load_save()` [1]

---

改完后运行测试，确认存档读档正常、vdisc 目录扫描正常后，告诉我结果，然后我们拆第2个 `file_system.gd`。

### USER
目前有如下报错，帮我仔细检查main.gd，然后修正反馈回我。注意不要全部发回，否则会导致会话中断。
第 1755 行：Expected opening "(" after function name.
第 1755 行：Expected parameter name.
第 1755 行：Expected closing ")" after function parameters.
第 1755 行：Expected end of statement after bodyless function declaration, found "." instead.
第 1755 行：Function "save_mgr" has the same name as a previously declared variable.
第 1756 行：Unexpected "Indent" in class body.
第 1757 行：Unexpected "Indent" in class body.
第 1757 行：Unexpected "return" in class body.
第 1757 行：Expected end of file.
下面是目前的main.gd
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
var background: TextureRect = null  # 由代码动态创建背景
# 模块实例
var save_mgr: SaveManager = SaveManager.new()
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false
# 桌面/终端模式
var _desktop_mode: bool = true             # true=桌面模式，false=终端模式（已加载磁盘）
# 打字机效果
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []  # [{path, title, id}]
var current_story_index: int = -1              # 当前加载的剧本索引
# 权限系统
var player_clearance: int = 0              # 当前权限等级
var story_permissions: Dictionary = {}      # 路径 -> 所需权限等级
var story_id: String = ""                   # 当前剧本唯一ID
var read_files: Array[String] = []          # 已读文件列表
var unlocked_passwords: Array[String] = []  # 已解锁的密码
# 密码输入弹窗状态
var _password_mode: bool = false            # 是否处于密码输入模式（unlock用）
var _password_target_path: String = ""      # 密码输入针对的路径（空表示通用unlock）
# 文件密码系统
var _file_password_mode: bool = false       # 是否处于文件密码输入模式
var _file_password_target: String = ""      # 当前等待密码的文件路径
var _file_password_filename: String = ""    # 当前等待密码的文件名（用于显示）
var story_file_passwords: Dictionary = {}   # 路径 -> {password, hint}
var unlocked_file_passwords: Array[String] = []  # 已解锁的文件路径列表
# ============================================================
# 初始化
# ============================================================
# 尝试加载剧本，如果失败则用测试数据
func _ready() -> void:
save_mgr.ensure_stories_dir()
save_mgr.ensure_saves_dir()
# 启动时只扫描，不自动加载
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# === 背景初始化 ===
_setup_background()
# 确保主内容在背景之上
var main_content := $MainContent
if main_content:
move_child(main_content, get_child_count() - 1)
# 让主内容区背景透明以显示底层背景图
if main_content is Control:
var transparent_style := StyleBoxFlat.new()
transparent_style.bg_color = Color(0, 0, 0, 0)
transparent_style.set_border_width_all(0)
main_content.add_theme_stylebox_override("panel", transparent_style)
# === UI 边框样式 ===
# 状态栏外框（StatusFrame）- 保留外层框，降低发光
var status_frame_style := StyleBoxFlat.new()
status_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
status_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
status_frame_style.set_border_width_all(1)
status_frame_style.content_margin_left = 4
status_frame_style.content_margin_right = 4
status_frame_style.content_margin_top = 3
status_frame_style.content_margin_bottom = 3
status_frame.add_theme_stylebox_override("panel", status_frame_style)
# PathLabel - 去掉内框（透明无边框）
var path_label_style := StyleBoxFlat.new()
path_label_style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
path_label_style.border_color = Color(0.0, 0.0, 0.0, 0.0)
path_label_style.set_border_width_all(0)
path_label_style.content_margin_left = 6
path_label_style.content_margin_right = 6
path_label_style.content_margin_top = 2
path_label_style.content_margin_bottom = 2
path_label.add_theme_stylebox_override("normal", path_label_style)
# MailIcon - 保留内框，降低发光
var mail_style := StyleBoxFlat.new()
mail_style.bg_color = Color(0.0, 0.03, 0.0, 0.6)
mail_style.border_color = Color(0.2, 0.6, 0.2, 0.35)
mail_style.set_border_width_all(1)
mail_style.content_margin_left = 8
mail_style.content_margin_right = 8
mail_style.content_margin_top = 2
mail_style.content_margin_bottom = 2
mail_icon.add_theme_stylebox_override("normal", mail_style)
# 输入区外框（InputFrame）- 只保留这一层框，降低发光
var input_frame_style := StyleBoxFlat.new()
input_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
input_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
input_frame_style.set_border_width_all(1)
input_frame_style.content_margin_left = 4
input_frame_style.content_margin_right = 4
input_frame_style.content_margin_top = 3
input_frame_style.content_margin_bottom = 3
input_frame.add_theme_stylebox_override("panel", input_frame_style)
# InputField - 去掉内框（透明无边框），只靠外层 InputFrame 提供边框
var input_no_border := StyleBoxFlat.new()
input_no_border.bg_color = Color(0.0, 0.0, 0.0, 0.0)
input_no_border.border_color = Color(0.0, 0.0, 0.0, 0.0)
input_no_border.set_border_width_all(0)
input_no_border.content_margin_left = 6
input_no_border.content_margin_right = 6
input_no_border.content_margin_top = 2
input_no_border.content_margin_bottom = 2
input_field.add_theme_stylebox_override("normal", input_no_border)
input_field.add_theme_stylebox_override("focus", input_no_border.duplicate())
output_text.text = ""
output_text.bbcode_enabled = true
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
input_field.focus_mode = Control.FOCUS_ALL
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
input_field.grab_focus()
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 鼠标滚轮滚动
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 点击任意位置聚焦输入框
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
# 点击任何键都确保输入框有焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果正在打字或加载，按空格或ESC跳过动画
if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
_typewriter_instant = true
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
# 如果正在打字，忽略回车（防止干扰）
if _is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
# 如果处于文件密码输入模式
if _file_password_mode:
_file_password_mode = false
input_field.placeholder_text = "> 输入命令..."
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 密码回显用星号
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消文件密码输入。[/color]\n", false)
_file_password_target = ""
_file_password_filename = ""
return
await _verify_file_password(raw_input)
return
# 如果处于密码输入模式
if _password_mode:
_password_mode = false
input_field.placeholder_text = "> 输入命令..."
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 密码回显用星号
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消密码输入。[/color]\n", false)
return
_verify_password(raw_input)
return
command_history.append(raw_input)
history_index = -1
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 命令回显用即时显示（不走打字机）
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
# 执行命令（命令输出走打字机效果）
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
_typewriter_instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
# 桌面模式：只允许少数命令
if _desktop_mode:
match command:
"load":
await _cmd_desktop_load(args)
"scan":
await _cmd_scan()
"clear", "cls":
_cmd_clear()
"exit", "quit":
await _cmd_exit()
"help", "?":
_cmd_desktop_help()
"vdisc", "disc", "disk":
_cmd_story_info()
"reboot", "restart":
await _cmd_reboot()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n[color=#AAAAAA]输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n", false)
return
# 终端模式：所有命令可用
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
if args.size() >= 1 and args[0].to_lower() == "load":
await _cmd_vdisc_load(args.slice(1))
else:
_cmd_story_info()
"unlock":
_cmd_unlock(args)
"scan":
await _cmd_scan()
"reboot", "restart":
await _cmd_reboot()
"eject":
await _cmd_eject()
"load":
append_output("[color=#AAAAAA]磁盘已加载。使用 [/color][color=#66FF66]eject[/color][color=#AAAAAA] 返回桌面后再切换磁盘，或使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 直接切换。[/color]\n", false)
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_desktop_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 桌面命令 ═══════════════[/color]")
lines.append("  [color=#66FF66]load <编号>[/color]   加载指定虚拟磁盘")
lines.append("  [color=#66FF66]scan[/color]   重新扫描vdisc目录")
lines.append("  [color=#66FF66]vdisc[/color] 查看磁盘列表详情")
lines.append("  [color=#66FF66]clear[/color] 清空屏幕")
lines.append("  [color=#66FF66]reboot[/color] 重启终端")
lines.append("  [color=#66FF66]exit[/color]   退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]vdisc[/color]         查看虚拟磁盘列表和信息")
lines.append("  [color=#66FF66]vdisc load <编号>[/color] 切换加载指定磁盘")
lines.append("  [color=#66FF66]scan[/color]          重新扫描虚拟磁盘")
lines.append("  [color=#66FF66]unlock[/color]        进入密码认证（或 unlock <密码>）")
lines.append("  [color=#66FF66]eject[/color]         卸载磁盘，返回桌面")
lines.append("  [color=#66FF66]reboot[/color]        重启终端")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
var item_required: int = _get_required_clearance(item_path)
var is_locked: bool = not _has_clearance(item_path)
if node.type == "folder":
if is_locked:
lines.append("  [color=#FF6666][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
else:
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
if is_locked:
lines.append("  [color=#FF6666][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
else:
# 检查是否需要文件密码
var fp_key: String = _get_file_password_key(item_path)
if not fp_key.is_empty() and not unlocked_file_passwords.has(item_path):
lines.append("  [color=#FFB000][FILE] " + item + "  [PASSWORD][/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
# 调试输出
print("[DEBUG] cd 目标: " + new_path + " 需要权限: " + str(_get_required_clearance(new_path)) + " 当前权限: " + str(player_clearance))
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(new_path)
if not _has_clearance(new_path):
var box: String = _build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
# 调试输出
print("[DEBUG] open 目标: " + file_path + " 需要权限: " + str(_get_required_clearance(file_path)) + " 当前权限: " + str(player_clearance))
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(file_path)
if not _has_clearance(file_path):
var box: String = _build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
# 文件密码检查（独立于权限等级）
var fp_key: String = _get_file_password_key(file_path)
if not fp_key.is_empty() and not unlocked_file_passwords.has(file_path):
# 需要文件密码且尚未解锁
var fp_info: Dictionary = story_file_passwords[fp_key]
var hint_text: String = fp_info.get("hint", "")
var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
if not hint_text.is_empty():
box_lines.append(["提示: " + hint_text])
box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
var box: String = _build_box_sectioned(box_lines, "#FFB000")
append_output(box + "\n", false)
# 进入文件密码输入模式
_file_password_mode = true
_file_password_target = file_path
_file_password_filename = filename
input_field.placeholder_text = "输入文件密码..."
return
# 先等待打字队列全部完成
while _is_typing:
await get_tree().process_frame
# 显示进度条（直接操作output_text，不走打字队列）
var content_size: int = node.content.length()
await _show_progress_bar(content_size)
# 进度条完成后等待一小会
await get_tree().create_timer(0.5).timeout
# 清屏进入阅读模式
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
# 显示文件头
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
# 记录已读
if not read_files.has(file_path):
read_files.append(file_path)
save_mgr.auto_save(story_id, player_clearance, read_files, unlocked_passwords, unlocked_file_passwords, current_path)
# 显示文件内容（走打字机，不加额外空行）
# 清理内容：去除首尾空白，统一换行符为\n
var clean_content: String = node.content.strip_edges()
clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
append_output(clean_content, false)
# 文件尾放入队列，等内容打完后显示
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名: [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]" + str(player_clearance) + "[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
lines.append("  已解锁文件: [color=#66FF66]" + str(unlocked_file_passwords.size()) + "[/color]")
if not story_id.is_empty():
lines.append("  盘ID: [color=#AAAAAA]" + story_id + "[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty() and available_stories.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")
if available_stories.size() > 0:
lines.append("")
lines.append("  已发现 [color=#66FF66]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
var marker: String = ""
if i == current_story_index:
marker = " [color=#33FF33]<< 当前[/color]"
lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]" + marker)
lines.append(" 作者: [color=#AAAAAA]" + info.get("author", "未知") + "[/color]")
lines.append("")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 切换磁盘[/color]")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]scan[/color][color=#AAAAAA] 重新扫描目录[/color]")
# 当前加载的磁盘详细信息
if story_manifest.has("story"):
lines.append("")
lines.append("[color=#66FF66]─────────── 当前磁盘详情 ───────────[/color]")
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签: [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者:   [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本: [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述: [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数: [color=#66FF66]" + str(file_system.size()) + "[/color]")
lines.append("  磁盘来源: [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态: [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_vdisc_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: vdisc load <编号>[/color]\n[color=#AAAAAA]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1  # 用户输入从1开始
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
if index == current_story_index:
append_output("[color=#AAAAAA]该磁盘已经是当前加载的磁盘。[/color]\n", false)
return
# 保存当前剧本存档
save_mgr.auto_save(story_id, player_clearance, read_files, unlocked_passwords, unlocked_file_passwords, current_path)
append_output("[color=#AAAAAA]正在卸载当前磁盘...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.3).timeout
# 重置状态
file_system.clear()
story_manifest.clear()
story_permissions.clear()
story_file_passwords.clear()
current_story_path = ""
story_id = ""
current_path = "/"
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
# 显示加载进度条
await _show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
# 加载新剧本
if _load_story_by_index(index):
var title: String = available_stories[index].get("title", "未知")
var box: String = _build_box_sectioned([
["DISC LOADED", "磁盘加载完成"],
[title]
], "#33FF33")
append_output(box + "\n", false)
_update_status_bar()
append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "  权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
append_output("[color=#AAAAAA]当前路径: " + current_path + "  权限等级: " + str(player_clearance) + "[/color]\n", false)
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
_init_test_file_system()
_update_status_bar()
func _cmd_unlock(args: Array) -> void:
# 如果带了参数，直接验证（兼容旧用法）
if not args.is_empty():
_verify_password(args[0])
return
# 无参数，进入密码输入模式
_enter_password_mode()
func _enter_password_mode(target_path: String = "") -> void:
_password_mode = true
_password_target_path = target_path
var box: String = _build_box_sectioned([
["SECURITY AUTHENTICATION", "安全认证系统"],
["请输入访问密码:", "(输入 cancel 取消)"]
], "#FFB000")
append_output(box + "\n", false)
# 修改输入框提示
input_field.placeholder_text = "输入密码..."
func _verify_password(password: String) -> void:
# 从manifest中查找密码
if not story_manifest.has("passwords"):
append_output("[color=#FF6666][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
return
var passwords: Dictionary = story_manifest["passwords"]
if passwords.has(password):
var pwd_info: Dictionary = passwords[password]
var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
if unlocked_passwords.has(password):
append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(player_clearance) + "[/color]\n", false)
return
if grant_level <= player_clearance:
append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。当前: " + str(player_clearance) + "[/color]\n", false)
return
# 解锁成功
unlocked_passwords.append(password)
var old_level: int = player_clearance
player_clearance = grant_level
save_mgr.auto_save(story_id, player_clearance, read_files, unlocked_passwords, unlocked_file_passwords, current_path)
# 成功动画
var box: String = _build_box_sectioned([
["ACCESS GRANTED", "权限认证通过"],
["权限等级: " + str(old_level) + " -> " + str(player_clearance)]
], "#33FF33")
append_output(box + "\n", false)
# 显示提示信息（如果有）
if pwd_info.has("message"):
append_output("[color=#AAAAAA]" + str(pwd_info["message"]) + "[/color]\n", false)
else:
var box: String = _build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _cmd_scan() -> void:
append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
# 显示扫描进度条
await _show_progress_bar(500)
await get_tree().create_timer(0.3).timeout
# 保存旧状态用于对比
var old_story_path: String = current_story_path
var old_manifest: Dictionary = story_manifest.duplicate()
# 重置文件系统和权限
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
story_file_passwords.clear()
available_stories.clear()
current_story_index = -1
# 重新扫描
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
if _desktop_mode:
# 桌面模式：只扫描，不自动加载
if available_stories.is_empty():
append_output("[color=#FFB000][WARN] 未找到虚拟磁盘文件。[/color]", false)
append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
else:
var scan_lines: Array[String] = []
scan_lines.append("[color=#33FF33][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
scan_lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
scan_lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]")
scan_lines.append("")
scan_lines.append("[color=#AAAAAA]输入 [/color][color=#66FF66]load <编号>[/color][color=#AAAAAA] 加载磁盘。[/color]")
append_output("\n".join(scan_lines) + "\n", false)
_update_status_bar()
else:
# 终端模式：重新加载当前磁盘
if available_stories.is_empty():
_desktop_mode = true
_init_test_file_system()
current_path = "/"
_update_status_bar()
append_output("[color=#FFB000][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
elif _load_story_by_index(0):
var title: String = "未知"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]", false)
append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "  权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
else:
current_path = "/"
_update_status_bar()
else:
append_output("[color=#FF6666][ERROR] 重新加载失败。[/color]\n", false)
func _cmd_reboot() -> void:
append_output("[color=#AAAAAA]正在重启终端...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 清空所有状态
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
command_history.clear()
history_index = -1
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
current_path = "/"
has_new_mail = false
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
story_file_passwords.clear()
available_stories.clear()
current_story_index = -1
# 重新加载
_ensure_stories_dir()
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# 模拟重启效果
output_text.append_text("[color=#AAAAAA]...[/color]\n")
await get_tree().create_timer(0.3).timeout
output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
await get_tree().create_timer(0.5).timeout
output_text.text = ""
# 回到桌面
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
input_field.grab_focus()
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
# 只输入了一个词：补全命令
if parts.size() == 1:
# 检查是否已经是完整命令，后面有空格表示要补全参数
if current_text.ends_with(" "):
# 命令已输入完，补全文件名（无前缀匹配，列出所有）
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只补全文件夹，open/cat只补全文件
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
_do_scroll()
else:
# 补全命令名
var partial_cmd: String = parts[0].to_lower()
var commands: Array
if _desktop_mode:
commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
else:
commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
"scan", "reboot", "restart", "unlock", "eject"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 两个词：命令 + 部分文件名
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只匹配文件夹，open/cat只匹配文件
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
# 找公共前缀，补全到最长公共部分
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 查找多个字符串的最长公共前缀
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
if not _is_typing:
_process_typewriter_queue()
func _process_typewriter_queue() -> void:
if _typewriter_queue.is_empty():
_is_typing = false
return
_is_typing = true
var entry = _typewriter_queue.pop_front()
var text: String = entry["text"]
var extra_newline: bool = entry["extra_newline"]
if _typewriter_instant:
output_text.append_text(text)
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
else:
_typewrite_text(text, extra_newline)
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
var i: int = 0
var length: int = text.length()
_current_char_speed = _typewriter_speed
while i < length:
# 如果中途切换为即时模式，把剩余文本一次性输出
if _typewriter_instant:
output_text.append_text(text.substr(i))
break
# 检查是否是BBCode标签
if text[i] == "[":
var close_bracket: int = text.find("]", i)
if close_bracket != -1:
var tag: String = text.substr(i, close_bracket - i + 1)
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 判断是否是合法的BBCode标签（以字母或/开头）
var tag_inner: String = tag.substr(1, tag.length() - 2)
if tag_inner.length() > 0 and (tag_inner[0] == "/" or tag_inner[0].unicode_at(0) >= 65 and tag_inner[0].unicode_at(0) <= 122):
# 看起来像BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 不是BBCode标签，转义方括号后逐字输出
output_text.append_text("[lb]")
i += 1
continue
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 普通BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 普通字符
var ch: String = text[i]
# 换行符不单独append，而是收集连续的换行一次性输出
if ch == "\n":
var newlines: String = "\n"
i += 1
while i < length and text[i] == "\n":
newlines += "\n"
i += 1
output_text.append_text(newlines)
# 换行后的停顿
if not _typewriter_instant:
await get_tree().create_timer(_typewriter_period_pause).timeout
_do_scroll()
continue
output_text.append_text(ch)
i += 1
# 根据字符类型决定延迟
var delay: float = _current_char_speed
# 标点符号额外停顿（制造顿挫感）
if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
delay += _typewriter_period_pause
elif ch in ["、", "—", "-", "…"]:
delay += _typewriter_comma_pause
else:
# 随机顿挫：有一定概率额外停顿
if randf() < _typewriter_pause_chance:
delay += _typewriter_pause_duration
await get_tree().create_timer(delay).timeout
# 每隔几个字符滚动一次
if i % 8 == 0:
_do_scroll()
# 当前文本打完
if extra_newline:
output_text.append_text("\n")
_do_scroll()
# 继续处理队列
_process_typewriter_queue()
func _do_scroll() -> void:
_needs_scroll = true
func _process(_delta: float) -> void:
if _needs_scroll:
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
scroll_container.scroll_vertical = int(v_scroll.max_value)
_needs_scroll = false
# 显示文件加载进度条
# file_size: 文件内容长度，影响进度条速度
# speed_override: 速度倍率覆盖，-1表示用默认
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
var bar_width: int = 30  # 进度条总长度（字符数）
var speed: float = _progress_bar_speed
if speed_override > 0.0:
speed = speed_override
# 文件越大，每格停顿越长（但有上下限）
var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
base_delay /= speed
# 起始行
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("[color=#66FF66]加载中 [[/color]")
for i in range(bar_width):
if _typewriter_instant:
# 跳过动画，直接填满
var remaining: int = bar_width - i
output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
break
output_text.append_text("[color=#33FF33]█[/color]")
_do_scroll()
# 随机波动让进度条不匀速，更真实
var jitter: float = randf_range(0.7, 1.5)
await get_tree().create_timer(base_delay * jitter).timeout
output_text.append_text("[color=#66FF66]] 完成[/color]\n")
_do_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
if _desktop_mode:
path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
mail_icon.text = "[Mail]"
return
var disc_name: String = ""
if current_story_index >= 0 and current_story_index < available_stories.size():
disc_name = available_stories[current_story_index].get("title", "")
if disc_name.is_empty():
path_label.text = "[" + current_path + "]  LV:" + str(player_clearance)
else:
path_label.text = "[" + current_path + "]  LV:" + str(player_clearance) + "  DISC:" + disc_name
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
# 处理RichTextLabel中的超链接点击
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
# 如果是命令链接，直接执行
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
# 如果是文件链接，打开文件
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
var box: String = _build_box([title, subtitle] as Array[String], "#66FF66")
output_text.append_text(box + "\n\n")
# 显示磁盘列表
if available_stories.is_empty():
output_text.append_text("[color=#FFB000]未检测到虚拟磁盘。[/color]\n")
output_text.append_text("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
else:
output_text.append_text("[color=#66FF66]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
output_text.append_text("  [color=#FFB000]" + str(i + 1) + ".[/color] [color=#66FF66]" + info.get("title", "未知") + "[/color]\n")
output_text.append_text(" [color=#AAAAAA]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
output_text.append_text("\n")
output_text.append_text("[color=#AAAAAA]可用命令:[/color]\n")
output_text.append_text("  [color=#66FF66]load <编号>[/color]   加载指定磁盘\n")
output_text.append_text("  [color=#66FF66]scan[/color]   重新扫描磁盘目录\n")
output_text.append_text("  [color=#66FF66]clear[/color] 清空屏幕\n")
output_text.append_text("  [color=#66FF66]exit[/color]   退出终端\n")
func _cmd_desktop_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: load <编号>[/color]", false)
if available_stories.size() > 0:
append_output("[color=#AAAAAA]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
append_output("[color=#AAAAAA]正在加载虚拟磁盘...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
# 显示加载进度条
await _show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
# 加载剧本
if _load_story_by_index(index):
_desktop_mode = false
var title: String = available_stories[index].get("title", "未知")
# 清屏并显示终端欢迎
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
_update_status_bar()
_show_welcome_message()
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
func _cmd_eject() -> void:
if _desktop_mode:
append_output("[color=#AAAAAA]当前已在桌面模式。[/color]\n", false)
return
# 保存当前剧本存档
save_mgr.auto_save(story_id, player_clearance, read_files, unlocked_passwords, unlocked_file_passwords, current_path)
append_output("[color=#AAAAAA]正在卸载磁盘...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 重置终端状态
file_system.clear()
story_manifest.clear()
story_permissions.clear()
story_file_passwords.clear()
current_story_path = ""
story_id = ""
current_path = "/"
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
current_story_index = -1
# 切换到桌面模式
_desktop_mode = true
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
# 计算框的宽度：取较长的那行，两侧各留3个空格
var max_len: int = max(title.length(), subtitle.length())
# 中英文混排时，中文字符占2个宽度，英文占1个
var title_display_len: int = _display_width(title)
var subtitle_display_len: int = _display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
# 居中填充
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func _display_width(text: String) -> int:
var width: int = 0
for ch in text:
var code: int = ch.unicode_at(0)
if code >= 0x4E00 and code <= 0x9FFF:
width += 2  # CJK统一汉字
elif code >= 0x3000 and code <= 0x303F:
width += 2  # CJK标点
elif code >= 0xFF00 and code <= 0xFFEF:
width += 2  # 全角字符
else:
width += 1
return width
# 生成自适应宽度的文本框
# lines_data: 每行文本内容（纯文本，不含颜色标签）
# color: 框的颜色代码（如 #33FF33）
# 返回带BBCode的完整框字符串
func _build_box(lines_data: Array[String], color: String) -> String:
# 计算最宽行的显示宽度
var max_width: int = 0
for line in lines_data:
var w: int = _display_width(line)
if w > max_width:
max_width = w
# 内部宽度 = 最宽行 + 左右各2个空格padding
var inner_width: int = max_width + 4
var border_h: String = "═".repeat(inner_width)
var result: String = ""
result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
for i in range(lines_data.size()):
var line: String = lines_data[i]
var line_width: int = _display_width(line)
var pad_total: int = inner_width - line_width
var pad_left: int = pad_total / 2
var pad_right: int = pad_total - pad_left
result += "[color=" + color + "]║" + " ".repeat(pad_left) + line + " ".repeat(pad_right) + "║[/color]\n"
# 如果不是最后一行，且下一行是分隔线标记，插入中间分隔
# 用特殊标记 "---" 表示需要插入分隔线
result += "[color=" + color + "]╚" + border_h + "╝[/color]"
return result
# 生成带中间分隔线的自适应方框
# sections: 二维数组，每个元素是一组行文本，组之间用分隔线隔开
func _build_box_sectioned(sections: Array, color: String) -> String:
# 计算所有行中最宽的显示宽度
var max_width: int = 0
for section in sections:
for line in section:
var w: int = _display_width(str(line))
if w > max_width:
max_width = w
var inner_width: int = max_width + 4
var border_h: String = "═".repeat(inner_width)
var divider_h: String = "═".repeat(inner_width)
var result: String = ""
result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
for s_idx in range(sections.size()):
var section: Array = sections[s_idx]
for line in section:
var line_str: String = str(line)
var line_width: int = _display_width(line_str)
var pad_total: int = inner_width - line_width
var pad_left: int = pad_total / 2
var pad_right: int = pad_total - pad_left
result += "[color=" + color + "]║" + " ".repeat(pad_left) + line_str + " ".repeat(pad_right) + "║[/color]\n"
# 在 section 之间插入分隔线（最后一组不加）
if s_idx < sections.size() - 1:
result += "[color=" + color + "]╠" + divider_h + "╣[/color]\n"
result += "[color=" + color + "]╚" + border_h + "╝[/color]"
return result
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
# 检查路径是否需要权限，返回所需等级（0表示无需权限）
func _get_required_clearance(path: String) -> int:
path = _normalize_path(path)
var highest: int = 0
for perm_path in story_permissions.keys():
var perm_value: int = int(float(story_permissions[perm_path]))
var normalized_perm: String = _normalize_path(perm_path)
# 精确匹配
if path == normalized_perm:
highest = max(highest, perm_value)
continue
# 目录前缀匹配：检查path是否在该目录下
var dir_prefix: String = normalized_perm + "/"
if path.begins_with(dir_prefix):
highest = max(highest, perm_value)
return highest
# 检查玩家是否有权限访问该路径
func _has_clearance(path: String) -> bool:
return player_clearance >= _get_required_clearance(path)
# 检查文件是否需要密码，返回对应的密码表key（空字符串表示不需要）
func _get_file_password_key(file_path: String) -> String:
file_path = _normalize_path(file_path)
# 精确匹配
for fp_path in story_file_passwords.keys():
var normalized_fp: String = _normalize_path(fp_path)
if file_path == normalized_fp:
return fp_path
return ""
# 验证文件密码
func _verify_file_password(input_password: String) -> void:
var fp_key: String = _get_file_password_key(_file_password_target)
if fp_key.is_empty():
append_output("[color=#FF6666][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
return
var fp_info: Dictionary = story_file_passwords[fp_key]
var correct_password: String = str(fp_info.get("password", ""))
if input_password == correct_password:
# 密码正确
unlocked_file_passwords.append(_file_password_target)
save_mgr.auto_save(story_id, player_clearance, read_files, unlocked_passwords, unlocked_file_passwords, current_path)
var box: String = _build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], "#33FF33")
append_output(box + "\n", false)
# 等打字完成后自动打开文件
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 重新执行打开文件
await _cmd_open([_file_password_filename])
else:
var box: String = _build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
var content: String = entry.get("content", "")
# 统一换行符，防止\r\n导致双倍行距
content = content.replace("\r\n", "\n").replace("\r", "\n")
return FSNode.new(entry.get("type", "file"), content)
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
# ============================================================
# 存档读档功能
# ============================================================
# 获取游戏根目录（编辑器中为项目目录，导出后为exe所在目录）
func save_mgr.get_game_root_dir() -> String:
if OS.has_feature("editor"):
return ProjectSettings.globalize_path("res://")
else:
return OS.get_executable_path().get_base_dir() + "/"
func _setup_background() -> void:
# 动态创建 Background 节点（不依赖场景树中预设的节点）
background = TextureRect.new()
background.name = "Background"
add_child(background)
# 移到最底层，确保不遮挡其他UI
move_child(background, 0)
# 铺满整个窗口
background.set_anchors_preset(Control.PRESET_FULL_RECT)
background.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
background.mouse_filter = Control.MOUSE_FILTER_IGNORE
# 尝试从外部加载背景图，没有就用纯色
var bg_path: String = save_mgr.get_game_root_dir() + "background.png"
var tex: Texture2D = null
if FileAccess.file_exists(bg_path):
var image := Image.new()
var err := image.load(bg_path)
if err == OK:
tex = ImageTexture.create_from_image(image)
print("[UI] 已加载外部背景图: " + bg_path)
else:
print("[UI] 背景图加载失败: " + str(err))
if tex == null:
# 没有外部背景图，生成纯深色背景
var image := Image.create(4, 4, false, Image.FORMAT_RGB8)
image.fill(Color(0.02, 0.04, 0.02, 1.0))
tex = ImageTexture.create_from_image(image)
print("[UI] 使用默认深色背景")
background.texture = tex
# 加载 Shader
var shader_path: String = "res://background_vignette.gdshader"
if ResourceLoader.exists(shader_path):
var shader: Shader = load(shader_path)
var mat := ShaderMaterial.new()
mat.shader = shader
mat.set_shader_parameter("vignette_strength", 0.8)
mat.set_shader_parameter("vignette_radius", 0.9)
mat.set_shader_parameter("glow_strength", 0.08)
mat.set_shader_parameter("glow_radius", 0.4)
mat.set_shader_parameter("brightness", 0.7)
mat.set_shader_parameter("tint_color", Color(0.1, 0.3, 0.1, 0.15))
background.material = mat
print("[UI] 背景Shader已应用")
else:
print("[UI] 未找到背景Shader文件: " + shader_path)
# 尝试从 vdisc 目录加载第一个 .scp 文件
func _try_load_story() -> bool:
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
print("[StoryLoader] 搜索目录: " + vdisc_dir)
_scan_available_stories(vdisc_dir)
# 不再自动加载，由桌面模式的 load 命令触发
return not available_stories.is_empty()
# 扫描 vdisc 目录下所有可用的 .scp/.zip 文件
func _scan_available_stories(vdisc_dir: String) -> void:
available_stories.clear()
if not DirAccess.dir_exists_absolute(vdisc_dir):
return
var dir := DirAccess.open(vdisc_dir)
if dir == null:
return
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = vdisc_dir + file_name
# 快速预读 manifest 获取标题和ID
var info: Dictionary = _peek_story_info(full_path)
info["path"] = full_path
info["filename"] = file_name
available_stories.append(info)
print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
file_name = dir.get_next()
print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")
# 快速预读 .scp 文件的 manifest，只提取标题和ID
func _peek_story_info(path: String) -> Dictionary:
var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}
var reader := ZIPReader.new()
if reader.open(path) != OK:
return info
var files := reader.get_files()
for file_path in files:
var filename: String = file_path.get_file()
if filename == "manifest.json":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
var json := JSON.new()
if json.parse(content) == OK and json.data is Dictionary:
var data: Dictionary = json.data
if data.has("story"):
var story_info: Dictionary = data["story"]
info["title"] = story_info.get("title", "未知剧本")
info["id"] = story_info.get("id", "")
info["author"] = story_info.get("author", "未知")
break
elif filename == "manifest.cfg":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
# 简单解析 cfg 获取标题
for line in content.split("\n"):
line = line.strip_edges()
if line.begins_with("title="):
info["title"] = line.substr(6).strip_edges()
elif line.begins_with("id="):
info["id"] = line.substr(3).strip_edges()
elif line.begins_with("author="):
info["author"] = line.substr(7).strip_edges()
break
reader.close()
return info
# 按索引加载指定剧本
func _load_story_by_index(index: int) -> bool:
if index < 0 or index >= available_stories.size():
return false
var story_info: Dictionary = available_stories[index]
var path: String = story_info["path"]
if _load_story_file(path):
current_story_index = index
return true
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据
file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 读取盘ID
if story_manifest.has("story") and story_manifest["story"].has("id"):
story_id = story_manifest["story"]["id"]
else:
# 没有id就用文件名的哈希作为id
story_id = str(path.get_file().hash())
# 读取权限表
story_permissions.clear()
if story_manifest.has("permissions"):
var perms: Dictionary = story_manifest["permissions"]
for perm_path in perms.keys():
story_permissions[perm_path] = int(perms[perm_path])
print("[StoryLoader] 权限表已加载，共 " + str(story_permissions.size()) + " 条规则")
else:
print("[StoryLoader] 警告: manifest中未找到permissions字段")
if story_manifest.has("passwords"):
print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
else:
print("[StoryLoader] 警告: manifest中未找到passwords字段")
# 读取文件密码表
story_file_passwords.clear()
if story_manifest.has("file_passwords"):
var fps: Dictionary = story_manifest["file_passwords"]
for fp_path in fps.keys():
story_file_passwords[fp_path] = fps[fp_path]
print("[StoryLoader] 文件密码表已加载，共 " + str(story_file_passwords.size()) + " 条")
else:
print("[StoryLoader] 未配置文件密码表（file_passwords）")
# 应用 manifest 中的设置
var start_clearance: int = 0
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
_typewriter_speed = settings["typing_speed"].to_float()
if settings.has("start_clearance"):
start_clearance = int(settings["start_clearance"])
# 尝试加载该剧本的存档
var save_data = save_mgr.load_save(story_id)
if save_data != null:
player_clearance = int(save_data.get("player_clearance", 0))
read_files.clear()
if save_data.has("read_files"):
for f in save_data["read_files"]:
read_files.append(str(f))
unlocked_passwords.clear()
if save_data.has("unlocked_passwords"):
for p in save_data["unlocked_passwords"]:
unlocked_passwords.append(str(p))
unlocked_file_passwords.clear()
if save_data.has("unlocked_file_passwords"):
for p in save_data["unlocked_file_passwords"]:
unlocked_file_passwords.append(str(p))
if save_data.has("current_path"):
var saved_path: String = save_data["current_path"]
if _has_clearance(saved_path):
current_path = saved_path
else:
current_path = "/"
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
print("[Save] 权限等级: " + str(player_clearance))
else:
# 没有存档，用初始权限
player_clearance = start_clearance
read_files.clear()
unlocked_passwords.clear()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 盘ID: " + story_id)
print("[StoryLoader] 文件数量: " + str(file_system.size()))
print("[StoryLoader] 权限等级: " + str(player_clearance))
print("[StoryLoader] story_permissions 内容: " + str(story_permissions))
print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
return true
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
找到问题了。在你的 main.gd 中有一个**没删干净的残留函数**，导致了所有报错。

## 错误原因

在"存档读档功能"注释区域下，有一个不应该存在的函数定义：

```gdscript
# ============================================================
# 存档读档功能
# ============================================================
# 获取游戏根目录（编辑器中为项目目录，导出后为exe所在目录）
func save_mgr.get_game_root_dir() -> String:
	if OS.has_feature("editor"):
		return ProjectSettings.globalize_path("res://")
	else:
		return OS.get_executable_path().get_base_dir() + "/"
```

`func save_mgr.get_game_root_dir()` 这种写法在 GDScript 中是非法的——不能用 `对象.方法名` 来定义函数。而且这个函数已经移到 `save_manager.gd` 里了，这里是**忘记删除的残留**。

## 修复方法

找到以下这段（从注释到函数体共6行），**整段删除**：

```gdscript
# ============================================================
# 存档读档功能
# ============================================================
# 获取游戏根目录（编辑器中为项目目录，导出后为exe所在目录）
func save_mgr.get_game_root_dir() -> String:
	if OS.has_feature("editor"):
		return ProjectSettings.globalize_path("res://")
	else:
		return OS.get_executable_path().get_base_dir() + "/"
```

---

另外还有一处遗漏：在 `_cmd_reboot` 函数中还残留了一个旧调用。找到：

```gdscript
_ensure_stories_dir()
```

**替换为：**

```gdscript
save_mgr.ensure_stories_dir()
```

---

总共只需改两处：
1. **删除** `func save_mgr.get_game_root_dir()` 整段（含注释共约9行）
2. **替换** `_cmd_reboot` 中的 `_ensure_stories_dir()` → `save_mgr.ensure_stories_dir()`

### USER
好，你把这一阶段接下来要进行的工作列一个详细一点的工作流程给我，我明天再接着推进进度。
之前的开发阶段规划如下，你参考一下：
**阶段一：基础框架（MVP）**
*   Godot项目基础搭建、场景树结构
    
*   基础CRT Shader实现与渲染管线
    
*   命令行输入框与基础命令解析（ls、cd、open、back、clear、help、exit）
    
*   ZIP文件读取与虚拟文件系统
    
*   基础TXT文件显示（纯文本，暂无CRT-ML解析）
    
*   打字机效果
    
*   状态栏
    
**阶段二：核心功能**
*   CRT-ML解析器（基本格式：标题、粗体、分割线、分页）
    
*   用户注册/登录系统
    
*   存档与数据持久化
    
*   头文件解析（权限、密码）
    
*   清单文件解析
    
*   文件滚动与翻页
    
*   命令自动补全与历史记录
    
*   模拟加载动画
    
**阶段三：多媒体与模板**
*   图片查看器（CRT效果覆盖、缩放、逐行扫描加载动画）
    
*   音频播放器（播放控制、简介显示、进度条）
    
*   视频播放器（基础播放控制、CRT效果覆盖）
    
*   环境音系统（循环播放、跨目录持续、自动降低音量）
    
*   CRT-ML多媒体标记解析（![image]、![audio]、![video]）
    
*   CRT-ML超链接解析（内部跳转与外部链接）
    
*   document 模板完善
    
*   email 模板实现
    
*   chat 聊天记录模板实现（逐条消息动画、打字指示器、多说话人颜色区分）
    
*   report SCP报告模板实现
    
*   聊天记录回放模式（实时回放与手动推进两种模式）
    
**阶段四：触发器与邮件系统**
*   触发器系统核心实现（条件检测、动作执行、触发链）
    
*   基础触发条件实现（on_enter、on_first_enter、on_open_file）
    
*   基础触发动作实现（new_mail、level_up、sound、text、redirect）
    
*   高级触发条件实现（on_level_reach、on_read_complete、on_idle、on_command）
    
*   高级触发动作实现（glitch、screen_off、reboot、color_scheme、lock_folder、unlock_folder）
    
*   复合触发器（分号分隔多动作顺序执行）
    
*   一次性触发器与可重复触发器逻辑
    
*   触发链深度限制与循环检测
    
*   邮件系统实现（邮件触发、延迟投递、收件箱列表、邮件阅读）
    
*   邮件图标提示与系统通知
    
*   邮件中动态变量替换（{username} 等）
    
**阶段五：特殊效果与沉浸感**
*   Jumpscare效果系统（图片闪现、屏幕震动、音效配合）
    
*   Glitch故障效果系统（屏幕撕裂、色偏、噪点、文字乱码）
    
*   CRT-ML内联效果标记实现（{glitch}、{shake}、{delay}、{sound}、{clear}）
    
*   SCP风格特殊标记实现（[REDACTED]、[DATA EXPUNGED]、||遮蔽文本||）
    
*   CRT开机动画（磷光渐亮、中心线扩展）
    
*   CRT关机动画（画面收缩为白线消失）
    
*   操作音效体系（键盘敲击、硬盘读取、电流底噪、命令反馈音）
    
*   自定义载入画面系统（loading.cfg 解析与渲染）
    
*   效果强度分级设置（完整/温和/关闭）
    
*   光敏性癫痫安全选项（关闭闪烁效果）
    
**阶段六：CRT效果优化与设置系统**
*   CRT Shader全面优化（参考cool-retro-term）
    
    *   扫描线精细调节
        
    *   RGB子像素模拟
        
    *   屏幕曲面扭曲
        
    *   边缘渐暗
        
    *   色彩渗透
        
    *   磷光余辉/拖影
        
    *   屏幕闪烁频率模拟
        
    *   亮度抖动
        
*   设置系统完整实现（显示、音频、文本、效果与安全四大分类）
    
*   配色方案切换（绿色磷光、琥珀色、白色、冰蓝、红色警戒）
    
*   设置即时预览与即时保存
    
*   设置持久化存储
    
**阶段七：调试工具与错误处理**
*   开发者模式实现（debug on/off）
    
*   开发者命令集实现（debug show_hidden、debug set_level、debug trigger 等）
    
*   实时日志面板（分级着色输出）
    
*   全面错误处理覆盖
    
    *   文件系统错误（损坏、缺失、格式不支持）
        
    *   用户操作错误（命令错误、权限不足、密码错误）
        
    *   CRT-ML解析错误（语法错误、引用缺失、编码异常）
        
    *   触发器错误（引用缺失、循环检测、深度限制）
        
    *   音视频播放错误（格式不支持、文件损坏）
        
    *   用户数据错误（存档损坏、磁盘空间不足）
        
*   错误密码惩罚机制（连续错误触发锁定或特殊事件）
    
*   超大文档分段加载渲染
    
**阶段八：扩展与打磨**
*   条件触发器实现（if_level>=、if_read: 等高级判断逻辑）
    
*   自定义模板机制（内容包内 templates/ 目录支持）
    
*   内容包文件关联（双击 .scp 文件直接用阅读器打开）
    
*   鼠标交互完善（复制粘贴、超链接点击、图片点击放大）
    
*   命令行彩蛋指令（ping、sudo、whoami 等趣味/恐怖回应）
    
*   性能优化与内存管理
    
*   全面测试与Bug修复
    
*   用户体验打磨（动画节奏、音效时机、错误提示措辞）
    
**阶段九：远期规划（视项目发展情况）**
*   主题包系统（独立于内容包的视觉主题安装机制）
    
*   插件/Mod系统预留接口
    
*   多语言支持（阅读器界面i18n）
    
*   CRT-ML语法高亮编辑器插件（VSCode等主流编辑器）
    
*   内容包结构验证与打包辅助工具
    
*   macOS平台适配
    
*   Web导出版本
    
*   社区内容包分享平台对接（远景）

### ASSISTANT
# 当前阶段工作流程：脚本拆分 + 阶段二收尾

根据你的开发规划，目前处于**阶段一→阶段二过渡期**。阶段一的核心功能已基本完成，当前正在进行代码架构重构（脚本拆分），为阶段二的复杂功能做准备。以下是明天继续推进的详细工作流程：

---

## 一、脚本拆分（继续进行，共6步）

### ✅ 已完成
- **Step 1：save_manager.gd** — 存档/读档/目录管理（已拆出并修复）

### 📋 待完成

#### Step 2：file_system.gd（预计 20-30 分钟）
拆出虚拟文件系统相关的纯数据逻辑：
- `FSNode` 内部类
- `_join_path()`、`_get_parent_path()`、`_normalize_path()`
- `_get_node_at_path()`、`_get_children_at_path()`
- `_get_required_clearance()`、`_has_clearance()`
- `_get_file_password_key()`
- `_init_test_file_system()`
- `_display_width()`、`_build_box()`、`_build_box_sectioned()`

> 这个模块是纯数据操作，不依赖任何 UI 节点，拆分最干净。需要把 `file_system`、`story_permissions`、`story_file_passwords`、`player_clearance` 等数据通过参数或引用传入。

**验证点**：拆完后运行，测试 `ls`、`cd`、`open`、`status` 命令是否正常。

---

#### Step 3：typewriter.gd（预计 30-40 分钟）
拆出打字机效果引擎：
- `append_output()`
- `_process_typewriter_queue()`
- `_typewrite_text()`
- `_show_progress_bar()`
- `_do_scroll()`
- 所有打字机相关变量（`_typewriter_queue`、`_is_typing`、`_typewriter_speed` 等）

> 这个模块依赖 `output_text`（RichTextLabel）和 `scroll_container`（ScrollContainer），需要在初始化时传入节点引用。

**验证点**：拆完后测试打字机效果、进度条动画、空格跳过功能。

---

#### Step 4：ui_manager.gd（预计 20-30 分钟）
拆出 UI 初始化和更新逻辑：
- `_setup_background()`
- `_update_status_bar()`
- `_ready()` 中所有 StyleBox 样式初始化代码
- `_show_welcome_message()`
- `_history_previous()`、`_history_next()`
- `_auto_complete()`、`_find_common_prefix()`

**验证点**：拆完后测试背景显示、状态栏更新、历史命令导航、Tab 补全。

---

#### Step 5：desktop_manager.gd（预计 15-20 分钟）
拆出桌面模式相关逻辑：
- `_show_desktop_welcome()`
- `_cmd_desktop_load()`
- `_cmd_desktop_help()`
- `_cmd_eject()`

**验证点**：拆完后测试桌面模式欢迎界面、`load` 加载磁盘、`eject` 卸载磁盘。

---

#### Step 6：terminal_commands.gd（预计 40-50 分钟）
拆出所有终端命令实现（这是最大的一块）：
- `_cmd_help()`、`_cmd_ls()`、`_cmd_cd()`、`_cmd_open()`
- `_cmd_back()`、`_cmd_clear()`、`_cmd_status()`
- `_cmd_mail()`、`_cmd_exit()`、`_cmd_whoami()`
- `_cmd_story_info()`、`_cmd_vdisc_load()`
- `_cmd_unlock()`、`_enter_password_mode()`、`_verify_password()`、`_verify_file_password()`
- `_cmd_scan()`、`_cmd_reboot()`

**验证点**：逐个测试所有命令，重点测试 `open`（含文件密码）、`unlock`（含权限提升）、`scan`、`reboot`。

---

#### 拆分完成后：清理 main.gd
拆分全部完成后，`main.gd` 应该只剩下：
- `@onready` 节点引用
- 模块实例变量
- `_ready()` — 调用各模块初始化
- `_input()` — 输入事件分发
- `_process()` — 帧更新（滚动等）
- `_on_command_submitted()` — 命令提交分发
- `_execute_command()` — 命令路由（调用各模块）
- `_on_meta_clicked()` — 超链接分发
- 剧本加载相关（`_scan_available_stories`、`_peek_story_info`、`_load_story_by_index`、`_load_story_file`）

预计 main.gd 从当前 ~1900 行缩减到 **~400-500 行**。

---

## 二、拆分完成后进入阶段二剩余任务

对照阶段二规划，标注当前完成状态：

| 任务 | 状态 |
|------|------|
| 存档与数据持久化 | ✅ 已完成 |
| 头文件解析（权限、密码） | ✅ 已完成 |
| 清单文件解析（manifest） | ✅ 已完成 |
| 命令自动补全与历史记录 | ✅ 已完成 |
| 模拟加载动画（进度条） | ✅ 已完成 |
| 文件滚动与翻页 | ✅ 基本完成（滚轮+PageUp/Down） |
| **CRT-ML 解析器** | ❌ 未开始 |
| **用户注册/登录系统** | ❌ 未开始 |

### 阶段二剩余工作优先级建议

**优先做 CRT-ML 解析器**（这是阶段三所有模板的基础）：

1. **定义 CRT-ML 基础语法规范**（30 分钟）
   - 标题标记：`# 一级标题`、`## 二级标题`
   - 粗体：`**粗体文本**`
   - 分割线：`---` 或 `===`
   - 分页标记：`---PAGE---` 或 `[page_break]`
   - 颜色标记：`{color:#FF0000}红色文本{/color}`

2. **实现 CRT-ML → BBCode 转换器**（1-2 小时）
   - 新建 `scripts/crtml_parser.gd`
   - 逐行解析，转换为 Godot RichTextLabel 支持的 BBCode
   - 在 `_cmd_open` 中集成：打开文件时先过一遍解析器

3. **实现分页功能**（30-40 分钟）
   - 检测到分页标记时暂停输出
   - 显示"按任意键继续"提示
   - 用户按键后显示下一页

4. **用户系统可以暂缓**（建议推迟到阶段四之前）
   - 当前 `whoami` 命令返回"未登录"已够用
   - 用户系统与邮件系统、触发器系统关联紧密，放在一起做更合理

---

## 三、推荐的明日工作顺序

```
上午：
  1. Step 2 - 拆分 file_system.gd → 测试验证
  2. Step 3 - 拆分 typewriter.gd → 测试验证

下午：
  3. Step 4 - 拆分 ui_manager.gd → 测试验证
  4. Step 5 - 拆分 desktop_manager.gd → 测试验证
  5. Step 6 - 拆分 terminal_commands.gd → 全面测试

收尾：
  6. 清理 main.gd，确认架构清晰
  7. 如果还有时间，开始 CRT-ML 语法规范定义
```

每拆完一个模块就**立即运行测试**，确保没有引入回归问题后再进行下一步。这样即使某一步卡住了，也不会影响之前已经验证通过的部分。

### USER
你帮忙构思一下，之后是会有书页模板的文档，即在屏幕上左右分别显示一页，这样的情况下排版工作应该如何确定？CRT-ML语法规定的文字大小（比如不占满整行的）又该如何处理？插入图片又该怎样方便的确定位置和大小？考虑一下，是将屏幕划分为一个字为大小的单元格还是怎么说？

### ASSISTANT
# CRT-ML 书页模板排版系统构思

这是一个很好的问题，因为书页模板（双页并排显示）和现有的终端滚动模式完全不同，需要从底层重新思考排版逻辑。我来系统性地构思一下。

---

## 一、核心问题分析

你的终端目前基于 `RichTextLabel` 的流式文本布局 [1]，本质上是"一行接一行往下走"。但书页模板需要的是：

- **固定页面尺寸**（不能无限滚动）
- **左右双栏**（两页并排）
- **精确定位**（图片、标题、页码在页面上的具体位置）
- **混合内容**（文字、图片、分割线共存于一个固定区域内）

这和终端的流式输出是两种完全不同的渲染模式。

---

## 二、排版坐标系统：字符网格 vs 相对坐标

### 方案A：字符网格（Character Grid）

将每一页划分为固定大小的字符网格，比如 `40列 × 30行`：

```
┌────────────────────────────────────────┐
│         第1页 (40×30 字符格)            │
│                                        │
│  (0,0) ─────────────────── (39,0)      │
│  │                              │      │
│  │     文字、图片都按格子放     │       │
│  │                              │      │
│  (0,29) ────────────────── (39,29)     │
└────────────────────────────────────────┘
```

**优点：**
- 完美契合CRT终端的像素感美学
- 中文刚好占2格，英文占1格，和你现有的 `_display_width()` 逻辑一致 [1]
- 图片大小可以用"几格×几格"来指定，非常直观
- 内容创作者不需要关心屏幕分辨率

**缺点：**
- 粒度较粗，图片定位不够精细
- 不同字体大小时格子尺寸会变化

### 方案B：百分比/相对坐标

用百分比表示位置，比如 `(50%, 30%)` 表示页面中央偏上。

**缺点：** 内容创作者不直观，难以在纯文本中编写。

### 方案C：混合方案（推荐）

**文字排版用字符网格，图片/特殊元素用格子坐标 + 格子尺寸**。

```
一页 = 行列网格
├── 每格 = 1个等宽英文字符的宽度 × 1行的高度
├── 中文字 = 占2列1行
├── 图片 = 占 W列 × H行（可跨格）
└── 实际像素 = 格子数 × 单格像素尺寸（由字体大小决定）
```

---

## 三、建议的页面模型

### 3.1 页面尺寸定义

```ini
# manifest.json 或文档头部定义
[page_layout]
mode = "book"           # book=双页, single=单页, scroll=滚动(终端默认)
columns = 38            # 每页列数（英文字符数）
rows = 28               # 每页行数
margin_top = 2          # 上边距（行数）
margin_bottom = 2       # 下边距（行数）  
margin_left = 3         # 左边距（列数）
margin_right = 3        # 右边距（列数）
page_gap = 4            # 双页之间的间距（列数）
```

有效内容区域 = `(columns - margin_left - margin_right)` × `(rows - margin_top - margin_bottom)`

例：`38 - 3 - 3 = 32列内容宽度`，`28 - 2 - 2 = 24行内容高度`

### 3.2 双页布局结构

```
┌─────── 屏幕 ────────────────────────────────────┐
│                                                  │
│  ┌──── 左页 ────┐  间距  ┌──── 右页 ────┐       │
│  │ 页眉          │       │ 页眉          │       │
│  │───────────────│       │───────────────│       │
│  │               │       │               │       │
│  │   内容区域     │       │   内容区域     │       │
│  │  32列×24行    │       │  32列×24行    │       │
│  │               │       │               │       │
│  │───────────────│       │───────────────│       │
│  │ 页脚  [p.12]  │       │ 页脚  [p.13]  │       │
│  └───────────────┘       └───────────────┘       │
│                                                  │
└──────────────────────────────────────────────────┘
```

---

## 四、CRT-ML 书页排版语法设计

### 4.1 文字大小与对齐

```markdown
# 一级标题（居中，大号，占2行高度）
## 二级标题（左对齐，中号，占1.5行高度）
### 三级标题（左对齐，正常大小，加粗）

正文文字默认占满内容区域宽度，自动换行。

{center}这行文字居中显示{/center}
{right}这行文字右对齐{/right}

{size=small}小号文字，每行可容纳更多字符{/size}
{size=large}大号文字，占更多格子{/size}
```

**文字大小的网格映射：**

| 尺寸标记 | 单字符占格 | 行高占格 | 说明 |
|---------|-----------|---------|------|
| `{size=small}` | 1列 × 1行 | 1行 | 注释、脚注用 |
| 默认正文 | 1列 × 1行 | 1行 | 标准大小 |
| `{size=large}` | 2列 × 2行 | 2行 | 标题、强调用 |
| `{size=huge}` | 3列 × 3行 | 3行 | 封面标题用 |

大号文字本质上是在渲染时用更大的字体绘制，但**占用的格子数按倍数计算**，这样排版引擎仍然基于统一的网格系统。

### 4.2 不占满整行的文字处理

```markdown
{indent=4}这段文字左缩进4格{/indent}

{columns=2}
这段文字分为两栏显示，
左栏的内容在这里。
|||
右栏的内容在这里，
自动填充。
{/columns}

{float=right,w=12}
这是一段浮动文本块，
宽度为12列，靠右对齐，
正文会绕排在左侧。
{/float}
```

### 4.3 图片插入与定位

这是最关键的部分。建议提供三种模式：

#### 模式1：行内流式插入（最简单）

```markdown
正文内容在这里...

![image](photo.png)

后续正文继续...
```

图片默认行为：
- **宽度**：占满内容区域宽度（32列）
- **高度**：按比例自动计算占几行
- **位置**：跟随文字流，就像一个"很宽的字符"

#### 模式2：指定尺寸的行内插入

```markdown
![image](photo.png, w=16, h=12)
```

- `w=16` 表示宽度占16列
- `h=12` 表示高度占12行
- 默认左对齐，文字不绕排

```markdown
![image](photo.png, w=16, h=12, align=center)
![image](photo.png, w=16, h=12, align=right)
```

#### 模式3：绝对定位（最精确）

```markdown
![image](photo.png, pos=10:5, w=20, h=15)
```

- `pos=10:5` 表示从第10列第5行开始放置
- 图片占 20列 × 15行
- 文字会自动避开图片区域

```
页面网格示意（38列×28行）:
     0    5    10   15   20   25   30   35
  0  ──────────────────────────────────────
  1  正文正文正文正文正文正文正文正文正文
  2  正文正文正文正文正文正文正文正文正文
  3  正文正文正█████████████████正文正文
  4  正文正文正█               █正文正文
  5  正文正文正█   图片区域     █正文正文
  6  正文正文正█   20列×15行   █正文正文
  7  正文正文正█               █正文正文
  8  正文正文正█████████████████正文正文
  9  正文正文正文正文正文正文正文正文正文
```

#### 模式4：浮动图片（文字绕排）

```markdown
![image](photo.png, float=right, w=14, h=10)
这段文字会自动绕排在图片左侧，
图片靠右显示，占14列×10行。
当文字超过图片高度后，
会恢复为全宽排列。
```

```
     0    5    10   15   20   25   30   35
  0  ──────────────────────────────────────
  1  这段文字会自动绕排 █████████████████
  2  在图片左侧,图片靠 █               █
  3  右显示,占14列×10  █   图片区域     █
  4  行。              █   float=right  █
  5  当文字超过图片高度 █               █
  6  后,               █████████████████
  7  会恢复为全宽排列。整行都可以用了。
```

---

## 五、Godot 实现方案

### 5.1 渲染层选择

**不用 RichTextLabel**，改用 **自定义 Control 节点 + `_draw()`**：

```
BookView (Control)
├── LeftPage (Control)     # 左页，自定义绘制
│   └── _draw() 中逐格渲染
├── RightPage (Control)    # 右页，自定义绘制
│   └── _draw() 中逐格渲染
├── PageControls           # 翻页按钮/提示
└── CRTShader              # CRT效果叠加在最上层
```

### 5.2 页面内容数据结构

```gdscript
# 一页的内容模型
class PageContent:
    var grid: Array  # 二维数组 [row][col]，每格存一个 Cell
    var images: Array[ImageBlock]  # 页面上的图片块
    var page_number: int
    
class Cell:
    var character: String = ""      # 字符内容（空=透明）
    var fg_color: Color = Color.GREEN
    var bg_color: Color = Color.TRANSPARENT
    var font_size: int = 0          # 0=默认, 1=small, 2=large
    var bold: bool = false
    var is_image_cell: bool = false  # 被图片占据的格子

class ImageBlock:
    var texture: Texture2D
    var grid_x: int          # 网格起始列
    var grid_y: int          # 网格起始行
    var grid_w: int          # 占据列数
    var grid_h: int          # 占据行数
```

### 5.3 排版引擎流程

```
CRT-ML 源文本
    ↓
[CRT-ML Parser] 解析为 Token 流
    ↓
[Layout Engine] 排版引擎
    ├── 计算每页可用区域 (columns × rows - margins)
    ├── 逐 Token 填充网格
    │   ├── 文字 Token → 逐字填入格子，自动换行
    │   ├── 图片 Token → 预留矩形区域，标记被占格子
    │   ├── 分页 Token → 当前页结束，开新页
    │   └── 格式 Token → 修改后续 Cell 的颜色/大小属性
    ├── 溢出检测：内容超出当前页 → 自动分页
    └── 输出: Array[PageContent]
    ↓
[Page Renderer] 页面渲染器
    ├── 遍历 grid，逐格绘制字符
    ├── 遍历 images，绘制图片（覆盖在对应格子区域上）
    └── 绘制页眉、页脚、页码、装饰边框
```

---

## 六、格子大小的具体计算

假设使用等宽字体，基准参数：

```gdscript
# 运行时根据窗口大小和字体计算
var font_size: int = 16                    # 基础字号（像素）
var cell_width: float = font_size * 0.6    # 等宽字体宽度 ≈ 字号×0.6
var cell_height: float = font_size * 1.4   # 行高 ≈ 字号×1.4

# 双页布局
var screen_width: float = get_viewport_rect().size.x
var screen_height: float = get_viewport_rect().size.y
var page_gap_px: float = cell_width * 4    # 两页间距

var page_width_px: float = (screen_width - page_gap_px) / 2.0
var page_height_px: float = screen_height

# 反算每页能容纳的格子数
var columns_per_page: int = int(page_width_px / cell_width)
var rows_per_page: int = int(page_height_px / cell_height)
```

或者反过来，**固定格子数，自适应字体大小**（推荐）：

```gdscript
# 固定每页 38列 × 28行
var target_cols: int = 38
var target_rows: int = 28

# 根据屏幕大小反算格子尺寸
var page_width_px: float = (screen_width - page_gap_px) / 2.0
var cell_width: float = page_width_px / target_cols
var cell_height: float = screen_height / target_rows
var font_size: int = int(cell_width / 0.6)  # 反推字号
```

---

## 七、总结与建议

| 决策项 | 建议 |
|--------|------|
| 坐标系统 | **字符网格**，最契合终端美学，创作者最直观 |
| 页面尺寸 | 固定格子数（如38×28），字体大小自适应屏幕 |
| 文字大小 | 用倍数占格（small=1x，normal=1x，large=2x，huge=3x） |
| 图片定位 | 提供4种模式（流式/指定尺寸/绝对定位/浮动绕排） |
| 渲染方式 | 自定义 `_draw()` 逐格绘制，不用 RichTextLabel |
| 与终端模式关系 | 书页模板是**独立的渲染模式**，和终端共存但互不干扰 |

**开发优先级建议**：
1. 先做阶段二/三的终端模式功能
2. 书页模板放到**阶段三后期或阶段四**，因为它需要独立的渲染管线
3. 先实现单页模式，再扩展为双页
4. 图片先只支持流式插入，后续再加绝对定位和浮动

### USER
之后有没有可能添加一些彩蛋/模组形式的小游戏？比如将俄罗斯方块文件塞进一个.scp包里，然后通过软件读取加载小
游戏？

### ASSISTANT
# 在 SCP 终端中嵌入小游戏：完全可行

这个想法非常棒，而且和现有架构的兼容性比你想象的要好。下面分析几种实现路径：

---

## 方案一：纯字符终端游戏（最容易实现）

利用现有的终端输出 + 命令输入机制，直接在终端里跑文字版小游戏。

**原理**：游戏逻辑脚本打包在 `.scp` 文件中，终端识别到特殊文件类型后加载执行。

```
vdisc/
└── tetris.scp
    ├── manifest.json        # 声明这是一个"game"类型的包
    ├── game/
    │   └── tetris.gd        # 游戏逻辑脚本（GDScript）
    └── assets/
        └── highscore.json
```

manifest 中声明：

```json
{
  "story": {
    "title": "TETRIS v1.0",
    "type": "game"
  },
  "entry": "game/tetris.gd"
}
```

终端中的体验：

```
> open tetris.exe

[加载中 [████████████████████████████████] 完成]

╔══════════════════════╗
║   ██                 ║
║   ██  ████           ║
║ ████  ██████  ████   ║
║ ██████████████████   ║
╠══════════════════════╣
║ SCORE: 1200  LV: 3  ║
╚══════════════════════╝

操作: A=左 D=右 W=旋转 S=加速 Q=退出
```

**这种方案用纯 ASCII/Unicode 字符绘制游戏画面**，完全复用现有的 `output_text` 和输入系统，不需要新的渲染管线。

像这些游戏都可以做成纯字符版：
- 俄罗斯方块
- 贪吃蛇
- 扫雷
- 猜数字
- 文字冒险（游戏中的游戏）
- 21点/扑克

---

## 方案二：自定义渲染区域的游戏（中等难度）

在终端窗口中划出一块区域，用自定义 `_draw()` 渲染游戏画面，但仍然套在 CRT Shader 下。

```
┌─ 终端 ──────────────────────────────┐
│ [/games]  LV:0  DISC:TETRIS         │
│─────────────────────────────────────│
│                                      │
│    ┌──── 游戏渲染区 ────┐            │
│    │                     │            │
│    │   （真正的2D渲染）   │            │
│    │                     │            │
│    └─────────────────────┘            │
│                                      │
│ SCORE: 1200    NEXT: ██              │
│─────────────────────────────────────│
│ > _                                  │
└──────────────────────────────────────┘
```

这需要之前讨论的书页模板类似的技术——在固定区域内做自定义绘制，但游戏逻辑可以从 `.scp` 包中加载。

---

## 方案三：GDScript 沙箱执行（最灵活但最复杂）

让 `.scp` 包中的 `.gd` 脚本能被动态加载执行。这本质上就是一个**Mod/插件系统**。

```gdscript
# 从 .scp 包中读取脚本并执行
var script_bytes = zip_reader.read_file("game/tetris.gd")
var script_text = script_bytes.get_string_from_utf8()

var script = GDScript.new()
script.source_code = script_text
script.reload()

var game_instance = script.new()
game_instance.init(output_text, input_field)  # 传入终端接口
game_instance.start()
```

**安全风险**：动态执行任意 GDScript 等于给了 Mod 完全的系统权限。需要考虑：
- 沙箱限制（禁止文件系统访问、禁止网络等）
- 或者只允许**预注册的游戏类型**，不允许任意脚本

---

## 最务实的实现路径

结合你的开发阶段规划，建议：

| 阶段 | 做什么 |
|------|--------|
| **阶段五**（特殊效果） | 实现纯字符游戏框架：定义游戏接口、帧循环、输入映射 |
| **阶段八**（扩展打磨） | 内置2-3个彩蛋小游戏（俄罗斯方块、贪吃蛇、扫雷） |
| **阶段九**（远期） | 开放 Mod 接口，允许社区在 `.scp` 包中分发自制游戏 |

从剧情角度，这些小游戏可以作为**SCP 收容物**出现：

```
> cd /recovered_items/
> ls
  [FILE] scp_2460_tetris.exe   [PASSWORD]
  [FILE] scp_XXXX_snake.exe

> open scp_2460_tetris.exe

[WARNING] 此程序来源于 SCP-2460 回收物品
任何异常体验请立即报告
按 Y 继续运行...
```

这样就让小游戏完美融入了 SCP 世界观 [1]，既是彩蛋也是叙事的一部分。

---

**总结**：完全可行，最简单的纯字符方案甚至可以很快原型验证。核心架构已经支持从 `.scp` 包加载自定义内容 [2]，只需要扩展一个"游戏类型"的识别和运行框架就行。

### USER
再详细总结一下这个阶段和下个阶段的工作流程，方便我们之后继续方向和进行回顾

### ASSISTANT
# 项目阶段总结与下阶段工作流程

---

## 当前阶段：代码架构重构（脚本拆分）

### 背景

当前 `main.gd` 承载了约 1900 行代码，包含了全部功能逻辑。随着功能增长，维护和扩展越来越困难。在进入阶段二的新功能开发之前，需要先把代码按职责拆分为独立模块。

### 已完成的工作

| 事项 | 状态 | 说明 |
|------|------|------|
| 拆分规划制定 | ✅ 完成 | 确定拆为 6 个独立模块 |
| `save_manager.gd` 拆分 | ✅ 完成 | 存档/读档/目录管理已独立 |
| 残留代码清理 | ✅ 完成 | 删除了 `func save_mgr.get_game_root_dir()` 残留和 `_ensure_stories_dir()` 旧调用 |

### 当前文件状态

```
scripts/
├── main.gd              ← ~1800行，还需继续拆分
├── save_manager.gd      ← ✅ 已拆出（存档管理）
├── story_loader.gd      ← 早期已独立（剧本加载）
├── crt_shader.gd        ← 早期已独立（CRT效果）
└── test.gd
```

### 待完成的拆分步骤（共5步）

#### Step 2：file_system.gd — 虚拟文件系统（预计 20-30 分钟）

**拆出内容：**
- `FSNode` 内部类（文件节点数据结构）
- 路径工具：`_join_path()`、`_get_parent_path()`、`_normalize_path()`
- 节点查询：`_get_node_at_path()`、`_get_children_at_path()`
- 权限检查：`_get_required_clearance()`、`_has_clearance()`
- 文件密码：`_get_file_password_key()`
- 测试数据：`_init_test_file_system()`
- 文本工具：`_display_width()`、`_build_box()`、`_build_box_sectioned()`

**技术要点：**
- 这个模块是纯数据操作，不依赖任何 UI 节点
- `file_system`、`story_permissions`、`story_file_passwords`、`player_clearance` 等数据需要通过引用传入或由 main.gd 持有后传给模块
- 建议用 `class_name FileSystem extends RefCounted`

**验证方法：**
- 运行后测试 `ls`（列目录）、`cd`（切换目录）、`open`（打开文件）、`status`（查看状态）
- 确认权限锁定的文件夹/文件显示正确的 LOCKED 标记

---

#### Step 3：typewriter.gd — 打字机效果引擎（预计 30-40 分钟）

**拆出内容：**
- `append_output()` — 文本入队
- `_process_typewriter_queue()` — 队列处理
- `_typewrite_text()` — 逐字输出核心逻辑（含 BBCode 标签跳过、`[speed=]`/`[pause=]` 自定义标签）
- `_show_progress_bar()` — 进度条动画
- `_do_scroll()` — 滚动控制
- 所有打字机相关变量：`_typewriter_queue`、`_is_typing`、`_typewriter_speed`、`_typewriter_instant`、`_typewriter_pause_chance` 等

**技术要点：**
- 依赖 `output_text`（RichTextLabel）和 `scroll_container`（ScrollContainer）两个 UI 节点
- 初始化时由 main.gd 传入这两个节点引用
- 包含 `await` 异步操作，需要继承 `Node` 或在初始化时传入 `SceneTree` 引用
- `_do_scroll()` 需要配合 main.gd 的 `_process()` 帧更新

**验证方法：**
- 打开任意文件，确认打字机逐字输出正常
- 按空格/ESC 测试跳过动画
- 确认进度条动画正常显示
- 测试长文件的自动滚动

---

#### Step 4：ui_manager.gd — UI 初始化与更新（预计 20-30 分钟）

**拆出内容：**
- `_setup_background()` — 背景创建与 Shader 加载
- `_update_status_bar()` — 状态栏路径/权限/邮件显示更新
- `_ready()` 中所有 StyleBoxFlat 样式初始化代码（约 60 行样式设置）
- `_show_welcome_message()` — 终端模式欢迎信息框 [1]
- `_history_previous()`、`_history_next()` — 命令历史导航
- `_auto_complete()`、`_find_common_prefix()` — Tab 自动补全

**技术要点：**
- 依赖多个 UI 节点（path_label、mail_icon、input_field、status_frame、input_frame 等）
- `_auto_complete()` 还依赖 file_system 模块的 `_get_children_at_path()` 来获取可补全项
- 可以考虑把样式初始化做成一个 `setup_styles(nodes_dict)` 方法

**验证方法：**
- 启动后确认背景、CRT 效果、边框样式正确
- 切换目录后确认状态栏更新
- 测试 ↑↓ 键历史命令导航
- 测试 Tab 补全命令名和文件名

---

#### Step 5：desktop_manager.gd — 桌面模式（预计 15-20 分钟）

**拆出内容：**
- `_show_desktop_welcome()` — 桌面欢迎界面（磁盘列表展示）
- `_cmd_desktop_load()` — load 命令（加载指定磁盘）
- `_cmd_desktop_help()` — 桌面模式 help 命令
- `_cmd_eject()` — 卸载磁盘返回桌面

**技术要点：**
- 依赖 typewriter 模块（输出文本）、save_manager（保存存档）、file_system（重置文件系统）
- `_cmd_desktop_load()` 需要调用 main.gd 的 `_load_story_by_index()` 来加载剧本
- 涉及模式切换 `_desktop_mode = true/false`，这个状态变量留在 main.gd

**验证方法：**
- 启动后确认桌面欢迎界面正常显示磁盘列表
- 测试 `load 1` 加载磁盘
- 测试 `eject` 卸载磁盘回到桌面
- 测试 `load` 后再 `eject` 再 `load` 的完整循环

---

#### Step 6：terminal_commands.gd — 终端命令集（预计 40-50 分钟）

**拆出内容：**
- 基础命令：`_cmd_help()`、`_cmd_ls()`、`_cmd_cd()`、`_cmd_open()`、`_cmd_back()`、`_cmd_clear()`
- 信息命令：`_cmd_status()`、`_cmd_mail()`、`_cmd_whoami()`
- 剧本管理：`_cmd_story_info()`、`_cmd_vdisc_load()`、`_cmd_scan()`
- 密码系统：`_cmd_unlock()`、`_enter_password_mode()`、`_verify_password()`、`_verify_file_password()`
- 系统命令：`_cmd_exit()`、`_cmd_reboot()`

**技术要点：**
- 这是依赖最多的模块，需要访问几乎所有其他模块
- 建议初始化时传入一个"上下文"对象或直接传入 main.gd 引用
- `_cmd_open()` 包含复杂的异步流程（进度条 → 清屏 → 打字机输出）
- `_cmd_reboot()` 需要重置所有模块状态
- 密码验证涉及状态变量 `_password_mode`、`_file_password_mode`

**验证方法：**
- 逐个测试所有命令
- 重点测试：
  - `open` 打开权限锁定的文件 → 应显示 ACCESS DENIED
  - `open` 打开需要文件密码的文件 → 应进入密码输入模式
  - `unlock` → 输入正确密码 → 权限提升 → 之前锁定的文件可访问
  - `scan` → 重新扫描磁盘
  - `reboot` → 完全重启回到桌面

---

### 拆分完成后的 main.gd 目标结构

```gdscript
extends Control

# ============ 节点引用 ============
@onready var path_label: Label = ...
@onready var output_text: RichTextLabel = ...
# ... 其他节点

# ============ 模块实例 ============
var save_mgr: SaveManager
var file_sys: FileSystem
var typewriter: Typewriter
var ui_mgr: UIManager
var desktop_mgr: DesktopManager
var cmd_handler: TerminalCommands

# ============ 核心状态 ============
var _desktop_mode: bool = true
var current_story_index: int = -1
# ... 其他共享状态

# ============ 生命周期 ============
func _ready():        # 初始化所有模块
func _input(event):   # 输入分发
func _process(delta): # 帧更新

# ============ 命令分发 ============
func _on_command_submitted(text):  # 命令提交
func _execute_command(raw_input):  # 路由到对应模块

# ============ 剧本加载 ============
func _scan_available_stories()

### USER
继续完成你的总结

### ASSISTANT
---

## 下一阶段：阶段二收尾 + 阶段三启动

### 阶段二完成状态回顾

| 任务 | 状态 | 说明 |
|------|------|------|
| 存档与数据持久化 | ✅ 已完成 | `save_manager.gd` 已独立 |
| 头文件解析（权限、密码） | ✅ 已完成 | manifest 中 permissions/passwords/file_passwords 均已支持 |
| 清单文件解析（manifest） | ✅ 已完成 | `story_loader.gd` 支持 JSON 和 CFG 两种格式 [2] |
| 命令自动补全与历史记录 | ✅ 已完成 | Tab 补全 + ↑↓ 历史导航 |
| 模拟加载动画（进度条） | ✅ 已完成 | 带随机抖动的进度条，支持跳过 |
| 文件滚动与翻页 | ✅ 基本完成 | 滚轮 + PageUp/Down |
| **CRT-ML 解析器** | ❌ 未开始 | 阶段二剩余核心任务 |
| **用户注册/登录系统** | ⏸ 建议推迟 | 与邮件/触发器关联紧密，放到阶段四一起做 |

### 阶段二剩余工作：CRT-ML 解析器

这是进入阶段三所有模板功能的前置基础，必须在阶段二完成。

#### 工作 1：CRT-ML 基础语法规范定义（30 分钟）

确定 CRT-ML 标记语法的最终形式：

```markdown
# CRT-ML 基础语法（第一版）

## 标题
# 一级标题（居中，大号）
## 二级标题（左对齐，中号）
### 三级标题（左对齐，加粗）

## 文本格式
**粗体文本**
*斜体文本*
~~删除线文本~~
__下划线文本__

## 颜色
{color:#FF0000}红色文本{/color}
{color:#FFB000}警告色文本{/color}

## 分割线
---          （普通分割线）
===          （粗分割线）

## 分页
---PAGE---   （强制分页标记）

## SCP 专用标记
[REDACTED]           → 显示为黑色遮挡块
[DATA EXPUNGED]      → 显示为红色遮挡块  
||被遮蔽的文本||     → 点击/悬停可揭示

## 速度控制（已在打字机中实现）
[speed=0.05]慢速文本[/speed]
[pause=1.0]          → 暂停1秒

## 超链接
[链接文字](cmd://命令)     → 点击执行命令
[链接文字](file:///路径)    → 点击打开文件
```

输出物：一份 `docs/crtml_spec_v1.md` 规范文档

#### 工作 2：创建 crtml_parser.gd（1-1.5 小时）

```
scripts/
└── crtml_parser.gd    ← 新建
```

核心功能：接收 CRT-ML 源文本，输出 Godot RichTextLabel 兼容的 BBCode。

```gdscript
class_name CRTMLParser
extends RefCounted

# 将 CRT-ML 文本转换为 BBCode
func parse(source: String) -> String

# 将 CRT-ML 文本按分页标记拆分为多页
func parse_pages(source: String) -> Array[String]
```

转换规则示例：

| CRT-ML 输入 | BBCode 输出 |
|-------------|-------------|
| `# 标题` | `[center][font_size=28][b]标题[/b][/font_size][/center]` |
| `**粗体**` | `[b]粗体[/b]` |
| `---` | `[color=#66FF66]════════════════════[/color]` |
| `[REDACTED]` | `[bgcolor=#111111][color=#111111]████████[/color][/bgcolor]` |
| `{color:#FF0000}红{/color}` | `[color=#FF0000]红[/color]` |

#### 工作 3：集成到文件打开流程（30 分钟）

在 `_cmd_open()` 中，打开文件时先过一遍 CRT-ML 解析器 [1]：

```gdscript
# 修改 _cmd_open 中的内容输出部分
var clean_content: String = node.content.strip_edges()
# 新增：CRT-ML 解析
var parsed_content: String = crtml_parser.parse(clean_content)
append_output(parsed_content, false)
```

**验证方法：**
- 创建一个测试 `.scp` 包，其中文件使用各种 CRT-ML 标记
- 确认标题、粗体、分割线、颜色、遮挡块都正确渲染
- 确认不含 CRT-ML 标记的纯文本文件不受影响

#### 工作 4：分页功能实现（30-40 分钟）

当文件包含 `---PAGE---` 标记时：
- 显示到分页标记处暂停
- 底部显示 `[按任意键翻到下一页]` 提示
- 用户按键后清屏显示下一页
- 最后一页显示 `[文件结束]`

---

### 阶段三预览：多媒体与模板

脚本拆分和 CRT-ML 解析器完成后，就进入阶段三。以下是阶段三的详细工作分解：

#### 3.1 CRT-ML 多媒体扩展（1-2天）

```markdown
## 图片
![image](photo.png)
![image](photo.png, w=300, h=200)

## 音频
![audio](recording.ogg)
![audio](recording.ogg, autoplay, loop)

## 视频
![video](footage.ogv)
```

**实现顺序：** 图片 → 音频 → 视频

**图片实现要点：**
- 从 `.scp` ZIP 包中读取图片二进制数据
- 创建 `ImageTexture` 并嵌入 RichTextLabel（`add_image()`）
- CRT Shader 自动覆盖，无需额外处理
- 支持逐行扫描加载动画（从上到下逐行显示）

**音频实现要点：**
- 从 ZIP 中提取音频到临时目录
- 使用 `AudioStreamPlayer` 播放
- 在终端中显示简易播放控制界面

#### 3.2 文档模板系统（2-3天）

创建模板渲染引擎，根据文件头部声明的模板类型选择不同的渲染方式：

```json
{
  "template": "document",
  "title": "SCP-173",
  "classification": "Euclid"
}
---
文件正文内容...
```

**四种基础模板：**

| 模板 | 说明 | 优先级 |
|------|------|--------|
| `document` | 通用文档（默认） | ⭐ 最先做 |
| `email` | 邮件格式（发件人/收件人/时间/正文） | ⭐⭐ 第二 |
| `report` | SCP 报告格式（编号/等级/收容措施/描述） | ⭐⭐ 第三 |
| `chat` | 聊天记录（逐条消息、多说话人颜色） | ⭐⭐⭐ 最复杂 |

#### 3.3 聊天记录模板（1-2天）

这是阶段三最复杂的模板，需要单独的渲染逻辑：

```json
{
  "template": "chat",
  "participants": {
    "Dr.Wang": "#66FF66",
    "Agent_K": "#6699FF",
    "SYSTEM": "#FF6666"
  },
  "mode": "realtime"
}
---
[10:31] Dr.Wang: 你在吗？
[10:31] Agent_K: 在，什么情况？
[10:32] Dr.Wang: B区的监控又断了
[10:32] SYSTEM: [WARNING] B区安保系统离线
[10:33] Agent_K: ......我去看看
[10:45] Dr.Wang: K？你还在吗？
[10:45] Dr.Wang: K？？
```

**渲染效果：**
- 逐条消息以打字机效果显示 [1]
- 每个说话人有独立颜色
- 消息间有模拟延迟（根据时间戳差值）
- 可选"打字中..."指示器动画

#### 3.4 环境音系统（0.5-1天）

```json
// manifest.json 中配置
"ambience": {
  "/": "sounds/hum.ogg",
  "/reports": "sounds/typing.ogg",
  "/comms": "sounds/static.ogg"
}
```

- 进入目录时自动播放对应环境音
- 跨目录时淡入淡出切换
- 打开文件时降低环境音量

---

### 完整时间线估算

```
┌─ 当前：脚本拆分 ──────────────────────────────────┐
│  Step 2: file_system.gd          ~30分钟           │
│  Step 3: typewriter.gd           ~40分钟           │
│  Step 4: ui_manager.gd           ~30分钟           │
│  Step 5: desktop_manager.gd      ~20分钟           │
│  Step 6: terminal_commands.gd    ~50分钟           │
│  清理 main.gd + 全面测试         ~30分钟           │
│                          小计：约 3-4 小时          │
├─ 阶段二收尾：CRT-ML ──────────────────────────────┤
│  语法规范定义                    ~30分钟           │
│  crtml_parser.gd 实现            ~1.5小时          │
│  集成到文件打开流程              ~30分钟           │
│  分页功能                        ~40分钟           │
│                          小计：约 3 小时            │
├─ 阶段三：多媒体与模板 ────────────────────────────┤
│  图片查看器                      ~1天              │
│  音频播放器                      ~0.5天            │
│  document 模板                   ~0.5天            │
│  email 模板                      ~0.5天            │
│  report 模板                     ~0.5天            │
│  chat 模板 + 回放                ~1-2天            │
│  环境音系统                      ~0.5天            │
│  超链接解析                      ~0.5天            │
│  视频播放器                      ~1天              │
│                          小计：约 5-7 天            │
└───────────────────────────────────────────────────┘
```

---

### 关键原则提醒

1. **每拆一个模块就立即测试**，不要堆积到最后一起测
2. **CRT-ML 解析器要保持向后兼容**——不含标记的纯文本必须原样通过
3. **模板系统设计要预留扩展性**——未来社区可以在 `.scp` 包中自定义模板
4. **阶段三的模板按优先级逐个实现**——不要同时开工多个模板

### USER
目前的main.gd代码如下（同文件内容），请继续下一步拆分。
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
var background: TextureRect = null  # 由代码动态创建背景
# 模块实例
var save_mgr: SaveManager = SaveManager.new()
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false
# 桌面/终端模式
var _desktop_mode: bool = true             # true=桌面模式，false=终端模式（已加载磁盘）
# 打字机效果
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
# ============================================================
# 虚拟文件系统
# ============================================================
var file_system: Dictionary = {}
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []  # [{path, title, id}]
var current_story_index: int = -1              # 当前加载的剧本索引
# 权限系统
var player_clearance: int = 0              # 当前权限等级
var story_permissions: Dictionary = {}      # 路径 -> 所需权限等级
var story_id: String = ""                   # 当前剧本唯一ID
var read_files: Array[String] = []          # 已读文件列表
var unlocked_passwords: Array[String] = []  # 已解锁的密码
# 密码输入弹窗状态
var _password_mode: bool = false            # 是否处于密码输入模式（unlock用）
var _password_target_path: String = ""      # 密码输入针对的路径（空表示通用unlock）
# 文件密码系统
var _file_password_mode: bool = false       # 是否处于文件密码输入模式
var _file_password_target: String = ""      # 当前等待密码的文件路径
var _file_password_filename: String = ""    # 当前等待密码的文件名（用于显示）
var story_file_passwords: Dictionary = {}   # 路径 -> {password, hint}
var unlocked_file_passwords: Array[String] = []  # 已解锁的文件路径列表
# ============================================================
# 初始化
# ============================================================
# 尝试加载剧本，如果失败则用测试数据
func _ready() -> void:
save_mgr.ensure_stories_dir()
save_mgr.ensure_saves_dir()
# 启动时只扫描，不自动加载
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# === 背景初始化 ===
_setup_background()
# 确保主内容在背景之上
var main_content := $MainContent
if main_content:
move_child(main_content, get_child_count() - 1)
# 让主内容区背景透明以显示底层背景图
if main_content is Control:
var transparent_style := StyleBoxFlat.new()
transparent_style.bg_color = Color(0, 0, 0, 0)
transparent_style.set_border_width_all(0)
main_content.add_theme_stylebox_override("panel", transparent_style)
# === UI 边框样式 ===
# 状态栏外框（StatusFrame）- 保留外层框，降低发光
var status_frame_style := StyleBoxFlat.new()
status_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
status_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
status_frame_style.set_border_width_all(1)
status_frame_style.content_margin_left = 4
status_frame_style.content_margin_right = 4
status_frame_style.content_margin_top = 3
status_frame_style.content_margin_bottom = 3
status_frame.add_theme_stylebox_override("panel", status_frame_style)
# PathLabel - 去掉内框（透明无边框）
var path_label_style := StyleBoxFlat.new()
path_label_style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
path_label_style.border_color = Color(0.0, 0.0, 0.0, 0.0)
path_label_style.set_border_width_all(0)
path_label_style.content_margin_left = 6
path_label_style.content_margin_right = 6
path_label_style.content_margin_top = 2
path_label_style.content_margin_bottom = 2
path_label.add_theme_stylebox_override("normal", path_label_style)
# MailIcon - 保留内框，降低发光
var mail_style := StyleBoxFlat.new()
mail_style.bg_color = Color(0.0, 0.03, 0.0, 0.6)
mail_style.border_color = Color(0.2, 0.6, 0.2, 0.35)
mail_style.set_border_width_all(1)
mail_style.content_margin_left = 8
mail_style.content_margin_right = 8
mail_style.content_margin_top = 2
mail_style.content_margin_bottom = 2
mail_icon.add_theme_stylebox_override("normal", mail_style)
# 输入区外框（InputFrame）- 只保留这一层框，降低发光
var input_frame_style := StyleBoxFlat.new()
input_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
input_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
input_frame_style.set_border_width_all(1)
input_frame_style.content_margin_left = 4
input_frame_style.content_margin_right = 4
input_frame_style.content_margin_top = 3
input_frame_style.content_margin_bottom = 3
input_frame.add_theme_stylebox_override("panel", input_frame_style)
# InputField - 去掉内框（透明无边框），只靠外层 InputFrame 提供边框
var input_no_border := StyleBoxFlat.new()
input_no_border.bg_color = Color(0.0, 0.0, 0.0, 0.0)
input_no_border.border_color = Color(0.0, 0.0, 0.0, 0.0)
input_no_border.set_border_width_all(0)
input_no_border.content_margin_left = 6
input_no_border.content_margin_right = 6
input_no_border.content_margin_top = 2
input_no_border.content_margin_bottom = 2
input_field.add_theme_stylebox_override("normal", input_no_border)
input_field.add_theme_stylebox_override("focus", input_no_border.duplicate())
output_text.text = ""
output_text.bbcode_enabled = true
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
input_field.focus_mode = Control.FOCUS_ALL
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
input_field.grab_focus()
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 鼠标滚轮滚动
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 点击任意位置聚焦输入框
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
# 点击任何键都确保输入框有焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果正在打字或加载，按空格或ESC跳过动画
if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
_typewriter_instant = true
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
# 如果正在打字，忽略回车（防止干扰）
if _is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
# 如果处于文件密码输入模式
if _file_password_mode:
_file_password_mode = false
input_field.placeholder_text = "> 输入命令..."
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 密码回显用星号
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消文件密码输入。[/color]\n", false)
_file_password_target = ""
_file_password_filename = ""
return
await _verify_file_password(raw_input)
return
# 如果处于密码输入模式
if _password_mode:
_password_mode = false
input_field.placeholder_text = "> 输入命令..."
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 密码回显用星号
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消密码输入。[/color]\n", false)
return
_verify_password(raw_input)
return
command_history.append(raw_input)
history_index = -1
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 命令回显用即时显示（不走打字机）
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
# 执行命令（命令输出走打字机效果）
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
_typewriter_instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
# 桌面模式：只允许少数命令
if _desktop_mode:
match command:
"load":
await _cmd_desktop_load(args)
"scan":
await _cmd_scan()
"clear", "cls":
_cmd_clear()
"exit", "quit":
await _cmd_exit()
"help", "?":
_cmd_desktop_help()
"vdisc", "disc", "disk":
_cmd_story_info()
"reboot", "restart":
await _cmd_reboot()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n[color=#AAAAAA]输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n", false)
return
# 终端模式：所有命令可用
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
if args.size() >= 1 and args[0].to_lower() == "load":
await _cmd_vdisc_load(args.slice(1))
else:
_cmd_story_info()
"unlock":
_cmd_unlock(args)
"scan":
await _cmd_scan()
"reboot", "restart":
await _cmd_reboot()
"eject":
await _cmd_eject()
"load":
append_output("[color=#AAAAAA]磁盘已加载。使用 [/color][color=#66FF66]eject[/color][color=#AAAAAA] 返回桌面后再切换磁盘，或使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 直接切换。[/color]\n", false)
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_desktop_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 桌面命令 ═══════════════[/color]")
lines.append("  [color=#66FF66]load <编号>[/color]   加载指定虚拟磁盘")
lines.append("  [color=#66FF66]scan[/color]   重新扫描vdisc目录")
lines.append("  [color=#66FF66]vdisc[/color] 查看磁盘列表详情")
lines.append("  [color=#66FF66]clear[/color] 清空屏幕")
lines.append("  [color=#66FF66]reboot[/color] 重启终端")
lines.append("  [color=#66FF66]exit[/color]   退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]vdisc[/color]         查看虚拟磁盘列表和信息")
lines.append("  [color=#66FF66]vdisc load <编号>[/color] 切换加载指定磁盘")
lines.append("  [color=#66FF66]scan[/color]          重新扫描虚拟磁盘")
lines.append("  [color=#66FF66]unlock[/color]        进入密码认证（或 unlock <密码>）")
lines.append("  [color=#66FF66]eject[/color]         卸载磁盘，返回桌面")
lines.append("  [color=#66FF66]reboot[/color]        重启终端")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := _get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
# 拼接所有行到一个字符串中，用换行符分隔
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := _join_path(current_path, item)
var node := _get_node_at_path(item_path)
if node == null:
continue
var item_required: int = _get_required_clearance(item_path)
var is_locked: bool = not _has_clearance(item_path)
if node.type == "folder":
if is_locked:
lines.append("  [color=#FF6666][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
else:
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
if is_locked:
lines.append("  [color=#FF6666][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
else:
# 检查是否需要文件密码
var fp_key: String = _get_file_password_key(item_path)
if not fp_key.is_empty() and not unlocked_file_passwords.has(item_path):
lines.append("  [color=#FFB000][FILE] " + item + "  [PASSWORD][/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
# 一次性输出，用换行符连接
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = _get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = _join_path(current_path, target)
new_path = _normalize_path(new_path)
var node := _get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
# 调试输出
print("[DEBUG] cd 目标: " + new_path + " 需要权限: " + str(_get_required_clearance(new_path)) + " 当前权限: " + str(player_clearance))
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(new_path)
if not _has_clearance(new_path):
var box: String = _build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = _join_path(current_path, filename)
file_path = _normalize_path(file_path)
var node := _get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
# 调试输出
print("[DEBUG] open 目标: " + file_path + " 需要权限: " + str(_get_required_clearance(file_path)) + " 当前权限: " + str(player_clearance))
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 权限检查
var required: int = _get_required_clearance(file_path)
if not _has_clearance(file_path):
var box: String = _build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
# 文件密码检查（独立于权限等级）
var fp_key: String = _get_file_password_key(file_path)
if not fp_key.is_empty() and not unlocked_file_passwords.has(file_path):
# 需要文件密码且尚未解锁
var fp_info: Dictionary = story_file_passwords[fp_key]
var hint_text: String = fp_info.get("hint", "")
var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
if not hint_text.is_empty():
box_lines.append(["提示: " + hint_text])
box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
var box: String = _build_box_sectioned(box_lines, "#FFB000")
append_output(box + "\n", false)
# 进入文件密码输入模式
_file_password_mode = true
_file_password_target = file_path
_file_password_filename = filename
input_field.placeholder_text = "输入文件密码..."
return
# 先等待打字队列全部完成
while _is_typing:
await get_tree().process_frame
# 显示进度条（直接操作output_text，不走打字队列）
var content_size: int = node.content.length()
await _show_progress_bar(content_size)
# 进度条完成后等待一小会
await get_tree().create_timer(0.5).timeout
# 清屏进入阅读模式
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
# 显示文件头
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
# 记录已读
if not read_files.has(file_path):
read_files.append(file_path)
save_mgr.auto_save(story_id, player_clearance, read_files, unlocked_passwords, unlocked_file_passwords, current_path)
# 显示文件内容（走打字机，不加额外空行）
# 清理内容：去除首尾空白，统一换行符为\n
var clean_content: String = node.content.strip_edges()
clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
append_output(clean_content, false)
# 文件尾放入队列，等内容打完后显示
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = _get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名: [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]" + str(player_clearance) + "[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
lines.append("  已解锁文件: [color=#66FF66]" + str(unlocked_file_passwords.size()) + "[/color]")
if not story_id.is_empty():
lines.append("  盘ID: [color=#AAAAAA]" + story_id + "[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty() and available_stories.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")
if available_stories.size() > 0:
lines.append("")
lines.append("  已发现 [color=#66FF66]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
var marker: String = ""
if i == current_story_index:
marker = " [color=#33FF33]<< 当前[/color]"
lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]" + marker)
lines.append(" 作者: [color=#AAAAAA]" + info.get("author", "未知") + "[/color]")
lines.append("")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 切换磁盘[/color]")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]scan[/color][color=#AAAAAA] 重新扫描目录[/color]")
# 当前加载的磁盘详细信息
if story_manifest.has("story"):
lines.append("")
lines.append("[color=#66FF66]─────────── 当前磁盘详情 ───────────[/color]")
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签: [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者:   [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本: [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述: [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数: [color=#66FF66]" + str(file_system.size()) + "[/color]")
lines.append("  磁盘来源: [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态: [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_vdisc_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: vdisc load <编号>[/color]\n[color=#AAAAAA]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1  # 用户输入从1开始
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
if index == current_story_index:
append_output("[color=#AAAAAA]该磁盘已经是当前加载的磁盘。[/color]\n", false)
return
# 保存当前剧本存档
save_mgr.auto_save(story_id, player_clearance, read_files, unlocked_passwords, unlocked_file_passwords, current_path)
append_output("[color=#AAAAAA]正在卸载当前磁盘...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.3).timeout
# 重置状态
file_system.clear()
story_manifest.clear()
story_permissions.clear()
story_file_passwords.clear()
current_story_path = ""
story_id = ""
current_path = "/"
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
# 显示加载进度条
await _show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
# 加载新剧本
if _load_story_by_index(index):
var title: String = available_stories[index].get("title", "未知")
var box: String = _build_box_sectioned([
["DISC LOADED", "磁盘加载完成"],
[title]
], "#33FF33")
append_output(box + "\n", false)
_update_status_bar()
append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "  权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
append_output("[color=#AAAAAA]当前路径: " + current_path + "  权限等级: " + str(player_clearance) + "[/color]\n", false)
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
_init_test_file_system()
_update_status_bar()
func _cmd_unlock(args: Array) -> void:
# 如果带了参数，直接验证（兼容旧用法）
if not args.is_empty():
_verify_password(args[0])
return
# 无参数，进入密码输入模式
_enter_password_mode()
func _enter_password_mode(target_path: String = "") -> void:
_password_mode = true
_password_target_path = target_path
var box: String = _build_box_sectioned([
["SECURITY AUTHENTICATION", "安全认证系统"],
["请输入访问密码:", "(输入 cancel 取消)"]
], "#FFB000")
append_output(box + "\n", false)
# 修改输入框提示
input_field.placeholder_text = "输入密码..."
func _verify_password(password: String) -> void:
# 从manifest中查找密码
if not story_manifest.has("passwords"):
append_output("[color=#FF6666][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
return
var passwords: Dictionary = story_manifest["passwords"]
if passwords.has(password):
var pwd_info: Dictionary = passwords[password]
var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
if unlocked_passwords.has(password):
append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(player_clearance) + "[/color]\n", false)
return
if grant_level <= player_clearance:
append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。当前: " + str(player_clearance) + "[/color]\n", false)
return
# 解锁成功
unlocked_passwords.append(password)
var old_level: int = player_clearance
player_clearance = grant_level
save_mgr.auto_save(story_id, player_clearance, read_files, unlocked_passwords, unlocked_file_passwords, current_path)
# 成功动画
var box: String = _build_box_sectioned([
["ACCESS GRANTED", "权限认证通过"],
["权限等级: " + str(old_level) + " -> " + str(player_clearance)]
], "#33FF33")
append_output(box + "\n", false)
# 显示提示信息（如果有）
if pwd_info.has("message"):
append_output("[color=#AAAAAA]" + str(pwd_info["message"]) + "[/color]\n", false)
else:
var box: String = _build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _cmd_scan() -> void:
append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
# 显示扫描进度条
await _show_progress_bar(500)
await get_tree().create_timer(0.3).timeout
# 保存旧状态用于对比
var old_story_path: String = current_story_path
var old_manifest: Dictionary = story_manifest.duplicate()
# 重置文件系统和权限
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
story_file_passwords.clear()
available_stories.clear()
current_story_index = -1
# 重新扫描
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
if _desktop_mode:
# 桌面模式：只扫描，不自动加载
if available_stories.is_empty():
append_output("[color=#FFB000][WARN] 未找到虚拟磁盘文件。[/color]", false)
append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
else:
var scan_lines: Array[String] = []
scan_lines.append("[color=#33FF33][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
scan_lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
scan_lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]")
scan_lines.append("")
scan_lines.append("[color=#AAAAAA]输入 [/color][color=#66FF66]load <编号>[/color][color=#AAAAAA] 加载磁盘。[/color]")
append_output("\n".join(scan_lines) + "\n", false)
_update_status_bar()
else:
# 终端模式：重新加载当前磁盘
if available_stories.is_empty():
_desktop_mode = true
_init_test_file_system()
current_path = "/"
_update_status_bar()
append_output("[color=#FFB000][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
elif _load_story_by_index(0):
var title: String = "未知"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]", false)
append_output("[color=#AAAAAA]文件数量: " + str(file_system.size()) + "  权限规则: " + str(story_permissions.size()) + " 条[/color]\n", false)
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
else:
current_path = "/"
_update_status_bar()
else:
append_output("[color=#FF6666][ERROR] 重新加载失败。[/color]\n", false)
func _cmd_reboot() -> void:
append_output("[color=#AAAAAA]正在重启终端...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 清空所有状态
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
command_history.clear()
history_index = -1
file_system.clear()
story_manifest.clear()
story_permissions.clear()
current_story_path = ""
story_id = ""
current_path = "/"
has_new_mail = false
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
story_file_passwords.clear()
available_stories.clear()
current_story_index = -1
# 重新加载
save_mgr.ensure_stories_dir()
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# 模拟重启效果
output_text.append_text("[color=#AAAAAA]...[/color]\n")
await get_tree().create_timer(0.3).timeout
output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
await get_tree().create_timer(0.5).timeout
output_text.text = ""
# 回到桌面
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
input_field.grab_focus()
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
# 只输入了一个词：补全命令
if parts.size() == 1:
# 检查是否已经是完整命令，后面有空格表示要补全参数
if current_text.ends_with(" "):
# 命令已输入完，补全文件名（无前缀匹配，列出所有）
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只补全文件夹，open/cat只补全文件
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
_do_scroll()
else:
# 补全命令名
var partial_cmd: String = parts[0].to_lower()
var commands: Array
if _desktop_mode:
commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
else:
commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
"scan", "reboot", "restart", "unlock", "eject"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 两个词：命令 + 部分文件名
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := _get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := _join_path(current_path, child)
var node := _get_node_at_path(child_path)
if node == null:
continue
# cd只匹配文件夹，open/cat只匹配文件
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
# 找公共前缀，补全到最长公共部分
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 查找多个字符串的最长公共前缀
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
if not _is_typing:
_process_typewriter_queue()
func _process_typewriter_queue() -> void:
if _typewriter_queue.is_empty():
_is_typing = false
return
_is_typing = true
var entry = _typewriter_queue.pop_front()
var text: String = entry["text"]
var extra_newline: bool = entry["extra_newline"]
if _typewriter_instant:
output_text.append_text(text)
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
else:
_typewrite_text(text, extra_newline)
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
var i: int = 0
var length: int = text.length()
_current_char_speed = _typewriter_speed
while i < length:
# 如果中途切换为即时模式，把剩余文本一次性输出
if _typewriter_instant:
output_text.append_text(text.substr(i))
break
# 检查是否是BBCode标签
if text[i] == "[":
var close_bracket: int = text.find("]", i)
if close_bracket != -1:
var tag: String = text.substr(i, close_bracket - i + 1)
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 判断是否是合法的BBCode标签（以字母或/开头）
var tag_inner: String = tag.substr(1, tag.length() - 2)
if tag_inner.length() > 0 and (tag_inner[0] == "/" or tag_inner[0].unicode_at(0) >= 65 and tag_inner[0].unicode_at(0) <= 122):
# 看起来像BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 不是BBCode标签，转义方括号后逐字输出
output_text.append_text("[lb]")
i += 1
continue
# 检查是否是自定义速度标签 [speed=0.05]
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
# 自定义暂停标签 [pause=0.5]
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
# 普通BBCode标签，整体添加
output_text.append_text(tag)
i = close_bracket + 1
continue
# 普通字符
var ch: String = text[i]
# 换行符不单独append，而是收集连续的换行一次性输出
if ch == "\n":
var newlines: String = "\n"
i += 1
while i < length and text[i] == "\n":
newlines += "\n"
i += 1
output_text.append_text(newlines)
# 换行后的停顿
if not _typewriter_instant:
await get_tree().create_timer(_typewriter_period_pause).timeout
_do_scroll()
continue
output_text.append_text(ch)
i += 1
# 根据字符类型决定延迟
var delay: float = _current_char_speed
# 标点符号额外停顿（制造顿挫感）
if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
delay += _typewriter_period_pause
elif ch in ["、", "—", "-", "…"]:
delay += _typewriter_comma_pause
else:
# 随机顿挫：有一定概率额外停顿
if randf() < _typewriter_pause_chance:
delay += _typewriter_pause_duration
await get_tree().create_timer(delay).timeout
# 每隔几个字符滚动一次
if i % 8 == 0:
_do_scroll()
# 当前文本打完
if extra_newline:
output_text.append_text("\n")
_do_scroll()
# 继续处理队列
_process_typewriter_queue()
func _do_scroll() -> void:
_needs_scroll = true
func _process(_delta: float) -> void:
if _needs_scroll:
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
scroll_container.scroll_vertical = int(v_scroll.max_value)
_needs_scroll = false
# 显示文件加载进度条
# file_size: 文件内容长度，影响进度条速度
# speed_override: 速度倍率覆盖，-1表示用默认
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
var bar_width: int = 30  # 进度条总长度（字符数）
var speed: float = _progress_bar_speed
if speed_override > 0.0:
speed = speed_override
# 文件越大，每格停顿越长（但有上下限）
var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
base_delay /= speed
# 起始行
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("[color=#66FF66]加载中 [[/color]")
for i in range(bar_width):
if _typewriter_instant:
# 跳过动画，直接填满
var remaining: int = bar_width - i
output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
break
output_text.append_text("[color=#33FF33]█[/color]")
_do_scroll()
# 随机波动让进度条不匀速，更真实
var jitter: float = randf_range(0.7, 1.5)
await get_tree().create_timer(base_delay * jitter).timeout
output_text.append_text("[color=#66FF66]] 完成[/color]\n")
_do_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
if _desktop_mode:
path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
mail_icon.text = "[Mail]"
return
var disc_name: String = ""
if current_story_index >= 0 and current_story_index < available_stories.size():
disc_name = available_stories[current_story_index].get("title", "")
if disc_name.is_empty():
path_label.text = "[" + current_path + "]  LV:" + str(player_clearance)
else:
path_label.text = "[" + current_path + "]  LV:" + str(player_clearance) + "  DISC:" + disc_name
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
# 处理RichTextLabel中的超链接点击
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
# 如果是命令链接，直接执行
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
# 如果是文件链接，打开文件
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
var box: String = _build_box([title, subtitle] as Array[String], "#66FF66")
output_text.append_text(box + "\n\n")
# 显示磁盘列表
if available_stories.is_empty():
output_text.append_text("[color=#FFB000]未检测到虚拟磁盘。[/color]\n")
output_text.append_text("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
else:
output_text.append_text("[color=#66FF66]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
output_text.append_text("  [color=#FFB000]" + str(i + 1) + ".[/color] [color=#66FF66]" + info.get("title", "未知") + "[/color]\n")
output_text.append_text(" [color=#AAAAAA]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
output_text.append_text("\n")
output_text.append_text("[color=#AAAAAA]可用命令:[/color]\n")
output_text.append_text("  [color=#66FF66]load <编号>[/color]   加载指定磁盘\n")
output_text.append_text("  [color=#66FF66]scan[/color]   重新扫描磁盘目录\n")
output_text.append_text("  [color=#66FF66]clear[/color] 清空屏幕\n")
output_text.append_text("  [color=#66FF66]exit[/color]   退出终端\n")
func _cmd_desktop_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: load <编号>[/color]", false)
if available_stories.size() > 0:
append_output("[color=#AAAAAA]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
append_output("[color=#AAAAAA]正在加载虚拟磁盘...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
# 显示加载进度条
await _show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
# 加载剧本
if _load_story_by_index(index):
_desktop_mode = false
var title: String = available_stories[index].get("title", "未知")
# 清屏并显示终端欢迎
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
_update_status_bar()
_show_welcome_message()
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
func _cmd_eject() -> void:
if _desktop_mode:
append_output("[color=#AAAAAA]当前已在桌面模式。[/color]\n", false)
return
# 保存当前剧本存档
save_mgr.auto_save(story_id, player_clearance, read_files, unlocked_passwords, unlocked_file_passwords, current_path)
append_output("[color=#AAAAAA]正在卸载磁盘...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 重置终端状态
file_system.clear()
story_manifest.clear()
story_permissions.clear()
story_file_passwords.clear()
current_story_path = ""
story_id = ""
current_path = "/"
player_clearance = 0
read_files.clear()
unlocked_passwords.clear()
unlocked_file_passwords.clear()
current_story_index = -1
# 切换到桌面模式
_desktop_mode = true
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
# 计算框的宽度：取较长的那行，两侧各留3个空格
var max_len: int = max(title.length(), subtitle.length())
# 中英文混排时，中文字符占2个宽度，英文占1个
var title_display_len: int = _display_width(title)
var subtitle_display_len: int = _display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
# 居中填充
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func _display_width(text: String) -> int:
var width: int = 0
for ch in text:
var code: int = ch.unicode_at(0)
if code >= 0x4E00 and code <= 0x9FFF:
width += 2  # CJK统一汉字
elif code >= 0x3000 and code <= 0x303F:
width += 2  # CJK标点
elif code >= 0xFF00 and code <= 0xFFEF:
width += 2  # 全角字符
else:
width += 1
return width
# 生成自适应宽度的文本框
# lines_data: 每行文本内容（纯文本，不含颜色标签）
# color: 框的颜色代码（如 #33FF33）
# 返回带BBCode的完整框字符串
func _build_box(lines_data: Array[String], color: String) -> String:
# 计算最宽行的显示宽度
var max_width: int = 0
for line in lines_data:
var w: int = _display_width(line)
if w > max_width:
max_width = w
# 内部宽度 = 最宽行 + 左右各2个空格padding
var inner_width: int = max_width + 4
var border_h: String = "═".repeat(inner_width)
var result: String = ""
result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
for i in range(lines_data.size()):
var line: String = lines_data[i]
var line_width: int = _display_width(line)
var pad_total: int = inner_width - line_width
var pad_left: int = pad_total / 2
var pad_right: int = pad_total - pad_left
result += "[color=" + color + "]║" + " ".repeat(pad_left) + line + " ".repeat(pad_right) + "║[/color]\n"
# 如果不是最后一行，且下一行是分隔线标记，插入中间分隔
# 用特殊标记 "---" 表示需要插入分隔线
result += "[color=" + color + "]╚" + border_h + "╝[/color]"
return result
# 生成带中间分隔线的自适应方框
# sections: 二维数组，每个元素是一组行文本，组之间用分隔线隔开
func _build_box_sectioned(sections: Array, color: String) -> String:
# 计算所有行中最宽的显示宽度
var max_width: int = 0
for section in sections:
for line in section:
var w: int = _display_width(str(line))
if w > max_width:
max_width = w
var inner_width: int = max_width + 4
var border_h: String = "═".repeat(inner_width)
var divider_h: String = "═".repeat(inner_width)
var result: String = ""
result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
for s_idx in range(sections.size()):
var section: Array = sections[s_idx]
for line in section:
var line_str: String = str(line)
var line_width: int = _display_width(line_str)
var pad_total: int = inner_width - line_width
var pad_left: int = pad_total / 2
var pad_right: int = pad_total - pad_left
result += "[color=" + color + "]║" + " ".repeat(pad_left) + line_str + " ".repeat(pad_right) + "║[/color]\n"
# 在 section 之间插入分隔线（最后一组不加）
if s_idx < sections.size() - 1:
result += "[color=" + color + "]╠" + divider_h + "╣[/color]\n"
result += "[color=" + color + "]╚" + border_h + "╝[/color]"
return result
# ============================================================
# 虚拟文件系统 - 路径工具函数
# ============================================================
func _join_path(base: String, child: String) -> String:
if base == "/":
return "/" + child
else:
return base + "/" + child
func _get_parent_path(path: String) -> String:
if path == "/":
return "/"
var clean_path: String = path.rstrip("/")
var last_slash: int = clean_path.rfind("/")
if last_slash <= 0:
return "/"
return clean_path.substr(0, last_slash)
func _normalize_path(path: String) -> String:
if not path.begins_with("/"):
path = "/" + path
var parts := path.split("/", false)
var resolved: Array[String] = []
for part in parts:
if part == "..":
if resolved.size() > 0:
resolved.pop_back()
elif part == ".":
continue
else:
resolved.append(part)
if resolved.is_empty():
return "/"
return "/" + "/".join(resolved)
# ============================================================
# 虚拟文件系统 - 节点数据结构
# ============================================================
class FSNode:
var type: String
var content: String
func _init(p_type: String, p_content: String = "") -> void:
type = p_type
content = p_content
# 检查路径是否需要权限，返回所需等级（0表示无需权限）
func _get_required_clearance(path: String) -> int:
path = _normalize_path(path)
var highest: int = 0
for perm_path in story_permissions.keys():
var perm_value: int = int(float(story_permissions[perm_path]))
var normalized_perm: String = _normalize_path(perm_path)
# 精确匹配
if path == normalized_perm:
highest = max(highest, perm_value)
continue
# 目录前缀匹配：检查path是否在该目录下
var dir_prefix: String = normalized_perm + "/"
if path.begins_with(dir_prefix):
highest = max(highest, perm_value)
return highest
# 检查玩家是否有权限访问该路径
func _has_clearance(path: String) -> bool:
return player_clearance >= _get_required_clearance(path)
# 检查文件是否需要密码，返回对应的密码表key（空字符串表示不需要）
func _get_file_password_key(file_path: String) -> String:
file_path = _normalize_path(file_path)
# 精确匹配
for fp_path in story_file_passwords.keys():
var normalized_fp: String = _normalize_path(fp_path)
if file_path == normalized_fp:
return fp_path
return ""
# 验证文件密码
func _verify_file_password(input_password: String) -> void:
var fp_key: String = _get_file_password_key(_file_password_target)
if fp_key.is_empty():
append_output("[color=#FF6666][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
return
var fp_info: Dictionary = story_file_passwords[fp_key]
var correct_password: String = str(fp_info.get("password", ""))
if input_password == correct_password:
# 密码正确
unlocked_file_passwords.append(_file_password_target)
save_mgr.auto_save(story_id, player_clearance, read_files, unlocked_passwords, unlocked_file_passwords, current_path)
var box: String = _build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], "#33FF33")
append_output(box + "\n", false)
# 等打字完成后自动打开文件
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 重新执行打开文件
await _cmd_open([_file_password_filename])
else:
var box: String = _build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _get_node_at_path(path: String) -> FSNode:
path = _normalize_path(path)
if path == "/":
return FSNode.new("folder")
if file_system.has(path):
var entry: Dictionary = file_system[path]
var content: String = entry.get("content", "")
# 统一换行符，防止\r\n导致双倍行距
content = content.replace("\r\n", "\n").replace("\r", "\n")
return FSNode.new(entry.get("type", "file"), content)
return null
func _get_children_at_path(path: String) -> Array[String]:
path = _normalize_path(path)
var children: Array[String] = []
var prefix: String
if path == "/":
prefix = "/"
else:
prefix = path + "/"
for key in file_system.keys():
if key.begins_with(prefix):
var remainder: String = key.substr(prefix.length())
if not remainder.contains("/"):
children.append(remainder)
children.sort()
return children
func _setup_background() -> void:
# 动态创建 Background 节点（不依赖场景树中预设的节点）
background = TextureRect.new()
background.name = "Background"
add_child(background)
# 移到最底层，确保不遮挡其他UI
move_child(background, 0)
# 铺满整个窗口
background.set_anchors_preset(Control.PRESET_FULL_RECT)
background.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
background.mouse_filter = Control.MOUSE_FILTER_IGNORE
# 尝试从外部加载背景图，没有就用纯色
var bg_path: String = save_mgr.get_game_root_dir() + "background.png"
var tex: Texture2D = null
if FileAccess.file_exists(bg_path):
var image := Image.new()
var err := image.load(bg_path)
if err == OK:
tex = ImageTexture.create_from_image(image)
print("[UI] 已加载外部背景图: " + bg_path)
else:
print("[UI] 背景图加载失败: " + str(err))
if tex == null:
# 没有外部背景图，生成纯深色背景
var image := Image.create(4, 4, false, Image.FORMAT_RGB8)
image.fill(Color(0.02, 0.04, 0.02, 1.0))
tex = ImageTexture.create_from_image(image)
print("[UI] 使用默认深色背景")
background.texture = tex
# 加载 Shader
var shader_path: String = "res://background_vignette.gdshader"
if ResourceLoader.exists(shader_path):
var shader: Shader = load(shader_path)
var mat := ShaderMaterial.new()
mat.shader = shader
mat.set_shader_parameter("vignette_strength", 0.8)
mat.set_shader_parameter("vignette_radius", 0.9)
mat.set_shader_parameter("glow_strength", 0.08)
mat.set_shader_parameter("glow_radius", 0.4)
mat.set_shader_parameter("brightness", 0.7)
mat.set_shader_parameter("tint_color", Color(0.1, 0.3, 0.1, 0.15))
background.material = mat
print("[UI] 背景Shader已应用")
else:
print("[UI] 未找到背景Shader文件: " + shader_path)
# 尝试从 vdisc 目录加载第一个 .scp 文件
func _try_load_story() -> bool:
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
print("[StoryLoader] 搜索目录: " + vdisc_dir)
_scan_available_stories(vdisc_dir)
# 不再自动加载，由桌面模式的 load 命令触发
return not available_stories.is_empty()
# 扫描 vdisc 目录下所有可用的 .scp/.zip 文件
func _scan_available_stories(vdisc_dir: String) -> void:
available_stories.clear()
if not DirAccess.dir_exists_absolute(vdisc_dir):
return
var dir := DirAccess.open(vdisc_dir)
if dir == null:
return
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = vdisc_dir + file_name
# 快速预读 manifest 获取标题和ID
var info: Dictionary = _peek_story_info(full_path)
info["path"] = full_path
info["filename"] = file_name
available_stories.append(info)
print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
file_name = dir.get_next()
print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")
# 快速预读 .scp 文件的 manifest，只提取标题和ID
func _peek_story_info(path: String) -> Dictionary:
var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}
var reader := ZIPReader.new()
if reader.open(path) != OK:
return info
var files := reader.get_files()
for file_path in files:
var filename: String = file_path.get_file()
if filename == "manifest.json":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
var json := JSON.new()
if json.parse(content) == OK and json.data is Dictionary:
var data: Dictionary = json.data
if data.has("story"):
var story_info: Dictionary = data["story"]
info["title"] = story_info.get("title", "未知剧本")
info["id"] = story_info.get("id", "")
info["author"] = story_info.get("author", "未知")
break
elif filename == "manifest.cfg":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
# 简单解析 cfg 获取标题
for line in content.split("\n"):
line = line.strip_edges()
if line.begins_with("title="):
info["title"] = line.substr(6).strip_edges()
elif line.begins_with("id="):
info["id"] = line.substr(3).strip_edges()
elif line.begins_with("author="):
info["author"] = line.substr(7).strip_edges()
break
reader.close()
return info
# 按索引加载指定剧本
func _load_story_by_index(index: int) -> bool:
if index < 0 or index >= available_stories.size():
return false
var story_info: Dictionary = available_stories[index]
var path: String = story_info["path"]
if _load_story_file(path):
current_story_index = index
return true
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据
file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 读取盘ID
if story_manifest.has("story") and story_manifest["story"].has("id"):
story_id = story_manifest["story"]["id"]
else:
# 没有id就用文件名的哈希作为id
story_id = str(path.get_file().hash())
# 读取权限表
story_permissions.clear()
if story_manifest.has("permissions"):
var perms: Dictionary = story_manifest["permissions"]
for perm_path in perms.keys():
story_permissions[perm_path] = int(perms[perm_path])
print("[StoryLoader] 权限表已加载，共 " + str(story_permissions.size()) + " 条规则")
else:
print("[StoryLoader] 警告: manifest中未找到permissions字段")
if story_manifest.has("passwords"):
print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
else:
print("[StoryLoader] 警告: manifest中未找到passwords字段")
# 读取文件密码表
story_file_passwords.clear()
if story_manifest.has("file_passwords"):
var fps: Dictionary = story_manifest["file_passwords"]
for fp_path in fps.keys():
story_file_passwords[fp_path] = fps[fp_path]
print("[StoryLoader] 文件密码表已加载，共 " + str(story_file_passwords.size()) + " 条")
else:
print("[StoryLoader] 未配置文件密码表（file_passwords）")
# 应用 manifest 中的设置
var start_clearance: int = 0
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
_typewriter_speed = settings["typing_speed"].to_float()
if settings.has("start_clearance"):
start_clearance = int(settings["start_clearance"])
# 尝试加载该剧本的存档
var save_data = save_mgr.load_save(story_id)
if save_data != null:
player_clearance = int(save_data.get("player_clearance", 0))
read_files.clear()
if save_data.has("read_files"):
for f in save_data["read_files"]:
read_files.append(str(f))
unlocked_passwords.clear()
if save_data.has("unlocked_passwords"):
for p in save_data["unlocked_passwords"]:
unlocked_passwords.append(str(p))
unlocked_file_passwords.clear()
if save_data.has("unlocked_file_passwords"):
for p in save_data["unlocked_file_passwords"]:
unlocked_file_passwords.append(str(p))
if save_data.has("current_path"):
var saved_path: String = save_data["current_path"]
if _has_clearance(saved_path):
current_path = saved_path
else:
current_path = "/"
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
print("[Save] 权限等级: " + str(player_clearance))
else:
# 没有存档，用初始权限
player_clearance = start_clearance
read_files.clear()
unlocked_passwords.clear()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 盘ID: " + story_id)
print("[StoryLoader] 文件数量: " + str(file_system.size()))
print("[StoryLoader] 权限等级: " + str(player_clearance))
print("[StoryLoader] story_permissions 内容: " + str(story_permissions))
print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
return true
func _init_test_file_system() -> void:
file_system = {
"/reports": {
"type": "folder"
},
"/personnel": {
"type": "folder"
},
"/comms": {
"type": "folder"
},
"/welcome.txt": {
"type": "file",
"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
},
"/notice.txt": {
"type": "file",
"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
},
"/reports/scp_001.txt": {
"type": "file",
"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
},
"/reports/scp_173.txt": {
"type": "file",
"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
},
"/reports/incident_log.txt": {
"type": "file",
"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
},
"/personnel/dr_bright.txt": {
"type": "file",
"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
},
"/personnel/agent_a.txt": {
"type": "file",
"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
},
"/comms/radio_log.txt": {
"type": "file",
"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
}
}

### ASSISTANT
好的，我已经仔细阅读了你完整的 `main.gd` 代码。按照之前的拆分计划，下一步是 **Step 2：拆分 file_system.gd**。

我会一次性给出：
1. 新建的 `file_system.gd` 完整代码
2. 修改后的 `main.gd` 完整代码

---

## 1. 新建 `scripts/file_system.gd`

```gdscript
# ============================================================
# file_system.gd - 虚拟文件系统模块
# 负责：路径操作、节点查询、权限检查、文件密码、文本框构建
# ============================================================
class_name FileSystem
extends RefCounted

# ============================================================
# 节点数据结构
# ============================================================
class FSNode:
	var type: String
	var content: String
	func _init(p_type: String, p_content: String = "") -> void:
		type = p_type
		content = p_content

# ============================================================
# 数据引用（由 main.gd 设置）
# ============================================================
var file_system: Dictionary = {}
var story_permissions: Dictionary = {}
var story_file_passwords: Dictionary = {}
var player_clearance: int = 0
var unlocked_file_passwords: Array[String] = []

# ============================================================
# 路径工具函数
# ============================================================
func join_path(base: String, child: String) -> String:
	if base == "/":
		return "/" + child
	else:
		return base + "/" + child

func get_parent_path(path: String) -> String:
	if path == "/":
		return "/"
	var clean_path: String = path.rstrip("/")
	var last_slash: int = clean_path.rfind("/")
	if last_slash <= 0:
		return "/"
	return clean_path.substr(0, last_slash)

func normalize_path(path: String) -> String:
	if not path.begins_with("/"):
		path = "/" + path
	var parts := path.split("/", false)
	var resolved: Array[String] = []
	for part in parts:
		if part == "..":
			if resolved.size() > 0:
				resolved.pop_back()
		elif part == ".":
			continue
		else:
			resolved.append(part)
	if resolved.is_empty():
		return "/"
	return "/" + "/".join(resolved)

# ============================================================
# 节点查询
# ============================================================
func get_node_at_path(path: String) -> FSNode:
	path = normalize_path(path)
	if path == "/":
		return FSNode.new("folder")
	if file_system.has(path):
		var entry: Dictionary = file_system[path]
		var content: String = entry.get("content", "")
		# 统一换行符，防止\r\n导致双倍行距
		content = content.replace("\r\n", "\n").replace("\r", "\n")
		return FSNode.new(entry.get("type", "file"), content)
	return null

func get_children_at_path(path: String) -> Array[String]:
	path = normalize_path(path)
	var children: Array[String] = []
	var prefix: String
	if path == "/":
		prefix = "/"
	else:
		prefix = path + "/"
	for key in file_system.keys():
		if key.begins_with(prefix):
			var remainder: String = key.substr(prefix.length())
			if not remainder.contains("/"):
				children.append(remainder)
	children.sort()
	return children

# ============================================================
# 权限检查
# ============================================================
# 检查路径是否需要权限，返回所需等级（0表示无需权限）
func get_required_clearance(path: String) -> int:
	path = normalize_path(path)
	var highest: int = 0
	for perm_path in story_permissions.keys():
		var perm_value: int = int(float(story_permissions[perm_path]))
		var normalized_perm: String = normalize_path(perm_path)
		# 精确匹配
		if path == normalized_perm:
			highest = max(highest, perm_value)
			continue
		# 目录前缀匹配：检查path是否在该目录下
		var dir_prefix: String = normalized_perm + "/"
		if path.begins_with(dir_prefix):
			highest = max(highest, perm_value)
	return highest

# 检查玩家是否有权限访问该路径
func has_clearance(path: String) -> bool:
	return player_clearance >= get_required_clearance(path)

# ============================================================
# 文件密码
# ============================================================
# 检查文件是否需要密码，返回对应的密码表key（空字符串表示不需要）
func get_file_password_key(file_path: String) -> String:
	file_path = normalize_path(file_path)
	# 精确匹配
	for fp_path in story_file_passwords.keys():
		var normalized_fp: String = normalize_path(fp_path)
		if file_path == normalized_fp:
			return fp_path
	return ""

# 检查文件密码是否已解锁
func is_file_password_unlocked(file_path: String) -> bool:
	return unlocked_file_passwords.has(file_path)

# ============================================================
# 显示工具函数
# ============================================================
# 计算字符串的显示宽度（中文=2，英文/符号=1）
func display_width(text: String) -> int:
	var width: int = 0
	for ch in text:
		var code: int = ch.unicode_at(0)
		if code >= 0x4E00 and code <= 0x9FFF:
			width += 2  # CJK统一汉字
		elif code >= 0x3000 and code <= 0x303F:
			width += 2  # CJK标点
		elif code >= 0xFF00 and code <= 0xFFEF:
			width += 2  # 全角字符
		else:
			width += 1
	return width

# 生成自适应宽度的文本框
# lines_data: 每行文本内容（纯文本，不含颜色标签）
# color: 框的颜色代码（如 #33FF33）
# 返回带BBCode的完整框字符串
func build_box(lines_data: Array[String], color: String) -> String:
	# 计算最宽行的显示宽度
	var max_width: int = 0
	for line in lines_data:
		var w: int = display_width(line)
		if w > max_width:
			max_width = w
	# 内部宽度 = 最宽行 + 左右各2个空格padding
	var inner_width: int = max_width + 4
	var border_h: String = "═".repeat(inner_width)
	var result: String = ""
	result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
	for i in range(lines_data.size()):
		var line: String = lines_data[i]
		var line_width: int = display_width(line)
		var pad_total: int = inner_width - line_width
		var pad_left: int = pad_total / 2
		var pad_right: int = pad_total - pad_left
		result += "[color=" + color + "]║" + " ".repeat(pad_left) + line + " ".repeat(pad_right) + "║[/color]\n"
	result += "[color=" + color + "]╚" + border_h + "╝[/color]"
	return result

# 生成带中间分隔线的自适应方框
# sections: 二维数组，每个元素是一组行文本，组之间用分隔线隔开
func build_box_sectioned(sections: Array, color: String) -> String:
	# 计算所有行中最宽的显示宽度
	var max_width: int = 0
	for section in sections:
		for line in section:
			var w: int = display_width(str(line))
			if w > max_width:
				max_width = w
	var inner_width: int = max_width + 4
	var border_h: String = "═".repeat(inner_width)
	var divider_h: String = "═".repeat(inner_width)
	var result: String = ""
	result += "[color=" + color + "]╔" + border_h + "╗[/color]\n"
	for s_idx in range(sections.size()):
		var section: Array = sections[s_idx]
		for line in section:
			var line_str: String = str(line)
			var line_width: int = display_width(line_str)
			var pad_total: int = inner_width - line_width
			var pad_left: int = pad_total / 2
			var pad_right: int = pad_total - pad_left
			result += "[color=" + color + "]║" + " ".repeat(pad_left) + line_str + " ".repeat(pad_right) + "║[/color]\n"
		# 在 section 之间插入分隔线（最后一组不加）
		if s_idx < sections.size() - 1:
			result += "[color=" + color + "]╠" + divider_h + "╣[/color]\n"
	result += "[color=" + color + "]╚" + border_h + "╝[/color]"
	return result

# ============================================================
# 测试文件系统
# ============================================================
func init_test_file_system() -> void:
	file_system = {
		"/reports": {
			"type": "folder"
		},
		"/personnel": {
			"type": "folder"
		},
		"/comms": {
			"type": "folder"
		},
		"/welcome.txt": {
			"type": "file",
			"content": """欢迎接入SCP基金会安全终端系统。
本系统用于查阅基金会内部文件档案。
您的一切操作都将被记录和监控。
请遵守信息安全协议，不要尝试访问
超出您权限等级的文件。
- 基金会信息安全部门"""
		},
		"/notice.txt": {
			"type": "file",
			"content": """[通知] 2024-01-15
所有站点人员注意：
由于近期发生的安全事故，
所有B区以上的文件访问权限已被临时冻结。
如需紧急访问，请联系您的直属主管。
- Site-19 管理层"""
		},
		"/reports/scp_001.txt": {
			"type": "file",
			"content": """项目编号: SCP-001
项目等级: [DATA EXPUNGED]
特殊收容措施:
████████████████████████████████
████████████████████████████████
[本文件需要O5级权限才能查阅完整内容]
描述:
SCP-001的真实性质属于最高机密。
目前已知的信息表明 ██████████████
████████████████████████████████"""
		},
		"/reports/scp_173.txt": {
			"type": "file",
			"content": """项目编号: SCP-173
项目等级: Euclid
特殊收容措施:
项目SCP-173应被收容在一个锁闭的房间中。
当人员必须进入SCP-173的收容室时，
不得少于3人进入，且门在重新锁闭后，
应始终保持与SCP-173的视觉接触。
描述:
SCP-173是一个混凝土和钢筋结构的雕塑，
上面有Krylon牌喷漆的痕迹。
SCP-173具有生命，且极端敌意。"""
		},
		"/reports/incident_log.txt": {
			"type": "file",
			"content": """事故日志 #2024-0117
日期: 2024年1月17日
地点: Site-19, B区走廊
涉及人员: Dr.████, Agent ████
事故描述:
在例行巡查中，B区走廊的照明系统突然失效。
持续时间约为4.7秒。
在照明恢复后，发现 ████████████████
████████████████████████████████
后续处理:
所有涉及人员已被施行A级记忆删除。
B区已被临时封锁。"""
		},
		"/personnel/dr_bright.txt": {
			"type": "file",
			"content": """人员档案: Dr. Bright
安全等级: 4级
职位: 高级研究员
当前站点: Site-19
备注:
Dr. Bright目前佩戴SCP-963。
有关Dr. Bright不被允许做的事情，
请参阅文件 bright_restrictions.txt
[警告: Dr. Bright的个人请求不应被认真对待]"""
		},
		"/personnel/agent_a.txt": {
			"type": "file",
			"content": """人员档案: Agent A
安全等级: 2级
职位: 外勤特工
当前站点: Site-19
状态: [color=#FF6666]失联[/color]
最后已知位置: Site-19 B区
最后联络时间: 2024-01-17 03:42
备注:
Agent A在事故#2024-0117后失去联络。
搜索行动正在进行中。"""
		},
		"/comms/radio_log.txt": {
			"type": "file",
			"content": """无线电通讯记录
频道: SITE-19-SECURE-7
日期: 2024-01-17
[03:38] 控制室: Alpha小组，报告状态。
[03:38] Agent A: 控制室，Alpha已到达B区入口。一切正常。
[03:39] Agent A: 开始例行巡查。
[03:41] Agent A: 控制室......这里的灯......
[03:41] 控制室: Alpha，请重复。
[03:42] Agent A: ......不对......这里有什么东西在......
[03:42] [信号中断]
[03:42] 控制室: Alpha? Alpha请回复!
[03:45] 控制室: Alpha小组失联。启动应急预案。"""
		}
	}

# ============================================================
# 数据重置
# ============================================================
func clear_all() -> void:
	file_system.clear()
	story_permissions.clear()
	story_file_passwords.clear()
	player_clearance = 0
	unlocked_file_passwords.clear()
```

---

## 2. 修改后的 `main.gd` 完整代码

```gdscript
extends Control

# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
var background: TextureRect = null  # 由代码动态创建背景

# 模块实例
var save_mgr: SaveManager = SaveManager.new()
var fs: FileSystem = FileSystem.new()

# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false

# 桌面/终端模式
var _desktop_mode: bool = true             # true=桌面模式，false=终端模式（已加载磁盘）

# 打字机效果
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率

# ============================================================
# 剧本系统
# ============================================================
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []  # [{path, title, id}]
var current_story_index: int = -1              # 当前加载的剧本索引
var story_id: String = ""                   # 当前剧本唯一ID
var read_files: Array[String] = []          # 已读文件列表
var unlocked_passwords: Array[String] = []  # 已解锁的密码

# 密码输入弹窗状态
var _password_mode: bool = false            # 是否处于密码输入模式（unlock用）
var _password_target_path: String = ""      # 密码输入针对的路径（空表示通用unlock）

# 文件密码系统
var _file_password_mode: bool = false       # 是否处于文件密码输入模式
var _file_password_target: String = ""      # 当前等待密码的文件路径
var _file_password_filename: String = ""    # 当前等待密码的文件名（用于显示）

# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
	save_mgr.ensure_stories_dir()
	save_mgr.ensure_saves_dir()

	# 启动时只扫描，不自动加载
	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	# === 背景初始化 ===
	_setup_background()

	# 确保主内容在背景之上
	var main_content := $MainContent
	if main_content:
		move_child(main_content, get_child_count() - 1)
		# 让主内容区背景透明以显示底层背景图
		if main_content is Control:
			var transparent_style := StyleBoxFlat.new()
			transparent_style.bg_color = Color(0, 0, 0, 0)
			transparent_style.set_border_width_all(0)
			main_content.add_theme_stylebox_override("panel", transparent_style)

	# === UI 边框样式 ===
	# 状态栏外框（StatusFrame）- 保留外层框，降低发光
	var status_frame_style := StyleBoxFlat.new()
	status_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
	status_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
	status_frame_style.set_border_width_all(1)
	status_frame_style.content_margin_left = 4
	status_frame_style.content_margin_right = 4
	status_frame_style.content_margin_top = 3
	status_frame_style.content_margin_bottom = 3
	status_frame.add_theme_stylebox_override("panel", status_frame_style)

	# PathLabel - 去掉内框（透明无边框）
	var path_label_style := StyleBoxFlat.new()
	path_label_style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
	path_label_style.border_color = Color(0.0, 0.0, 0.0, 0.0)
	path_label_style.set_border_width_all(0)
	path_label_style.content_margin_left = 6
	path_label_style.content_margin_right = 6
	path_label_style.content_margin_top = 2
	path_label_style.content_margin_bottom = 2
	path_label.add_theme_stylebox_override("normal", path_label_style)

	# MailIcon - 保留内框，降低发光
	var mail_style := StyleBoxFlat.new()
	mail_style.bg_color = Color(0.0, 0.03, 0.0, 0.6)
	mail_style.border_color = Color(0.2, 0.6, 0.2, 0.35)
	mail_style.set_border_width_all(1)
	mail_style.content_margin_left = 8
	mail_style.content_margin_right = 8
	mail_style.content_margin_top = 2
	mail_style.content_margin_bottom = 2
	mail_icon.add_theme_stylebox_override("normal", mail_style)

	# 输入区外框（InputFrame）- 只保留这一层框，降低发光
	var input_frame_style := StyleBoxFlat.new()
	input_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
	input_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
	input_frame_style.set_border_width_all(1)
	input_frame_style.content_margin_left = 4
	input_frame_style.content_margin_right = 4
	input_frame_style.content_margin_top = 3
	input_frame_style.content_margin_bottom = 3
	input_frame.add_theme_stylebox_override("panel", input_frame_style)

	# InputField - 去掉内框（透明无边框），只靠外层 InputFrame 提供边框
	var input_no_border := StyleBoxFlat.new()
	input_no_border.bg_color = Color(0.0, 0.0, 0.0, 0.0)
	input_no_border.border_color = Color(0.0, 0.0, 0.0, 0.0)
	input_no_border.set_border_width_all(0)
	input_no_border.content_margin_left = 6
	input_no_border.content_margin_right = 6
	input_no_border.content_margin_top = 2
	input_no_border.content_margin_bottom = 2
	input_field.add_theme_stylebox_override("normal", input_no_border)
	input_field.add_theme_stylebox_override("focus", input_no_border.duplicate())

	output_text.text = ""
	output_text.bbcode_enabled = true
	output_text.selection_enabled = true
	output_text.meta_underlined = true
	output_text.meta_clicked.connect(_on_meta_clicked)

	input_field.focus_mode = Control.FOCUS_ALL
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
	input_field.grab_focus()

	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()

# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
	# 鼠标滚轮滚动
	if event is InputEventMouseButton and event.pressed:
		match event.button_index:
			MOUSE_BUTTON_WHEEL_UP:
				scroll_container.scroll_vertical -= 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_WHEEL_DOWN:
				scroll_container.scroll_vertical += 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_LEFT:
				# 点击任意位置聚焦输入框
				input_field.grab_focus()
				return

	if not event is InputEventKey or not event.pressed:
		return

	# 点击任何键都确保输入框有焦点
	if not input_field.has_focus():
		input_field.grab_focus()

	# 如果正在打字或加载，按空格或ESC跳过动画
	if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
		_typewriter_instant = true
		get_viewport().set_input_as_handled()
		return

	match event.keycode:
		KEY_ENTER, KEY_KP_ENTER:
			# 如果正在打字，忽略回车（防止干扰）
			if _is_typing:
				get_viewport().set_input_as_handled()
			else:
				var command_text: String = input_field.text
				input_field.clear()
				_on_command_submitted(command_text)
				get_viewport().set_input_as_handled()
		KEY_UP:
			_history_previous()
			get_viewport().set_input_as_handled()
		KEY_DOWN:
			_history_next()
			get_viewport().set_input_as_handled()
		KEY_PAGEUP:
			scroll_container.scroll_vertical -= 100
			get_viewport().set_input_as_handled()
		KEY_PAGEDOWN:
			scroll_container.scroll_vertical += 100
			get_viewport().set_input_as_handled()
		KEY_TAB:
			_auto_complete()
			get_viewport().set_input_as_handled()

# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	input_field.clear()

	if raw_input.is_empty():
		return

	# 如果处于文件密码输入模式
	if _file_password_mode:
		_file_password_mode = false
		input_field.placeholder_text = "> 输入命令..."
		# 等待打字队列完成
		while _is_typing:
			await get_tree().process_frame
		# 密码回显用星号
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")

		if raw_input.to_lower() == "cancel":
			append_output("[color=#AAAAAA]已取消文件密码输入。[/color]\n", false)
			_file_password_target = ""
			_file_password_filename = ""
			return
		await _verify_file_password(raw_input)
		return

	# 如果处于密码输入模式
	if _password_mode:
		_password_mode = false
		input_field.placeholder_text = "> 输入命令..."
		# 等待打字队列完成
		while _is_typing:
			await get_tree().process_frame
		# 密码回显用星号
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")

		if raw_input.to_lower() == "cancel":
			append_output("[color=#AAAAAA]已取消密码输入。[/color]\n", false)
			return
		_verify_password(raw_input)
		return

	command_history.append(raw_input)
	history_index = -1

	# 等待打字队列完成
	while _is_typing:
		await get_tree().process_frame

	# 命令回显用即时显示（不走打字机）
	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text("> " + raw_input + "\n")

	# 执行命令（命令输出走打字机效果）
	await _execute_command(raw_input)

# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
	_typewriter_instant = false

	var parts := raw_input.split(" ", false)
	if parts.is_empty():
		return

	var command: String = parts[0].to_lower()
	var args := parts.slice(1)

	# 桌面模式：只允许少数命令
	if _desktop_mode:
		match command:
			"load":
				await _cmd_desktop_load(args)
			"scan":
				await _cmd_scan()
			"clear", "cls":
				_cmd_clear()
			"exit", "quit":
				await _cmd_exit()
			"help", "?":
				_cmd_desktop_help()
			"vdisc", "disc", "disk":
				_cmd_story_info()
			"reboot", "restart":
				await _cmd_reboot()
			_:
				append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n[color=#AAAAAA]输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n", false)
		return

	# 终端模式：所有命令可用
	match command:
		"help", "?":
			_cmd_help()
		"ls", "dir":
			_cmd_ls()
		"cd":
			_cmd_cd(args)
		"open", "cat":
			await _cmd_open(args)
		"back":
			_cmd_back()
		"clear", "cls":
			_cmd_clear()
		"status":
			_cmd_status()
		"mail":
			_cmd_mail(args)
		"exit", "quit":
			await _cmd_exit()
		"whoami":
			_cmd_whoami()
		"vdisc", "disc", "disk":
			if args.size() >= 1 and args[0].to_lower() == "load":
				await _cmd_vdisc_load(args.slice(1))
			else:
				_cmd_story_info()
		"unlock":
			_cmd_unlock(args)
		"scan":
			await _cmd_scan()
		"reboot", "restart":
			await _cmd_reboot()
		"eject":
			await _cmd_eject()
		"load":
			append_output("[color=#AAAAAA]磁盘已加载。使用 [/color][color=#66FF66]eject[/color][color=#AAAAAA] 返回桌面后再切换磁盘，或使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 直接切换。[/color]\n", false)
		_:
			append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)

# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_desktop_help() -> void:
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════════ 桌面命令 ═══════════════[/color]")
	lines.append("  [color=#66FF66]load <编号>[/color]   加载指定虚拟磁盘")
	lines.append("  [color=#66FF66]scan[/color]   重新扫描vdisc目录")
	lines.append("  [color=#66FF66]vdisc[/color] 查看磁盘列表详情")
	lines.append("  [color=#66FF66]clear[/color] 清空屏幕")
	lines.append("  [color=#66FF66]reboot[/color] 重启终端")
	lines.append("  [color=#66FF66]exit[/color]   退出终端")
	lines.append("[color=#66FF66]═══════════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_help() -> void:
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
	lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
	lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
	lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
	lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
	lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
	lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
	lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
	lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
	lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
	lines.append("  [color=#66FF66]vdisc[/color]         查看虚拟磁盘列表和信息")
	lines.append("  [color=#66FF66]vdisc load <编号>[/color] 切换加载指定磁盘")
	lines.append("  [color=#66FF66]scan[/color]          重新扫描虚拟磁盘")
	lines.append("  [color=#66FF66]unlock[/color]        进入密码认证（或 unlock <密码>）")
	lines.append("  [color=#66FF66]eject[/color]         卸载磁盘，返回桌面")
	lines.append("  [color=#66FF66]reboot[/color]        重启终端")
	lines.append("  [color=#66FF66]exit[/color]          退出终端")
	lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
	lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_ls() -> void:
	var items := fs.get_children_at_path(current_path)
	if items.is_empty():
		append_output("[color=#AAAAAA]该目录为空。[/color]")
		return

	var lines: Array[String] = []
	lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
	lines.append("")

	for item in items:
		var item_path := fs.join_path(current_path, item)
		var node := fs.get_node_at_path(item_path)
		if node == null:
			continue

		var item_required: int = fs.get_required_clearance(item_path)
		var is_locked: bool = not fs.has_clearance(item_path)

		if node.type == "folder":
			if is_locked:
				lines.append("  [color=#FF6666][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
			else:
				lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
		else:
			if is_locked:
				lines.append("  [color=#FF6666][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
			else:
				# 检查是否需要文件密码
				var fp_key: String = fs.get_file_password_key(item_path)
				if not fp_key.is_empty() and not fs.is_file_password_unlocked(item_path):
					lines.append("  [color=#FFB000][FILE] " + item + "  [PASSWORD][/color]")
				else:
					lines.append("  [color=#33FF33][FILE] " + item + "[/color]")

	lines.append("")
	append_output("\n".join(lines) + "\n", false)

func _cmd_cd(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
		return

	var target: String = args[0]
	var new_path: String

	if target == "/":
		new_path = "/"
	elif target == "..":
		new_path = fs.get_parent_path(current_path)
	elif target.begins_with("/"):
		new_path = target
	else:
		new_path = fs.join_path(current_path, target)

	new_path = fs.normalize_path(new_path)
	var node := fs.get_node_at_path(new_path)

	if node == null:
		append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
		return

	if node.type != "folder":
		print("[DEBUG] cd 目标: " + new_path + " 需要权限: " + str(fs.get_required_clearance(new_path)) + " 当前权限: " + str(fs.player_clearance))
		append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
		return

	# 权限检查
	var required: int = fs.get_required_clearance(new_path)
	if not fs.has_clearance(new_path):
		var box: String = fs.build_box_sectioned([
			["ACCESS DENIED", "权限不足"],
			["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
			["输入 unlock 尝试密码认证"]
		], "#FF6666")
		append_output(box + "\n", false)
		return

	current_path = new_path
	_update_status_bar()
	append_output("已切换到: " + current_path + "\n", false)

func _cmd_open(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
		return

	var filename: String = args[0]
	var file_path: String

	if filename.begins_with("/"):
		file_path = filename
	else:
		file_path = fs.join_path(current_path, filename)

	file_path = fs.normalize_path(file_path)
	var node := fs.get_node_at_path(file_path)

	if node == null:
		append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
		return

	if node.type != "file":
		print("[DEBUG] open 目标: " + file_path + " 需要权限: " + str(fs.get_required_clearance(file_path)) + " 当前权限: " + str(fs.player_clearance))
		append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
		return

	# 权限检查
	var required: int = fs.get_required_clearance(file_path)
	if not fs.has_clearance(file_path):
		var box: String = fs.build_box_sectioned([
			["ACCESS DENIED", "权限不足"],
			["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
			["输入 unlock 尝试密码认证"]
		], "#FF6666")
		append_output(box + "\n", false)
		return

	# 文件密码检查（独立于权限等级）
	var fp_key: String = fs.get_file_password_key(file_path)
	if not fp_key.is_empty() and not fs.is_file_password_unlocked(file_path):
		# 需要文件密码且尚未解锁
		var fp_info: Dictionary = fs.story_file_passwords[fp_key]
		var hint_text: String = fp_info.get("hint", "")

		var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
		if not hint_text.is_empty():
			box_lines.append(["提示: " + hint_text])
		box_lines.append(["请输入密码:", "(输入 cancel 取消)"])

		var box: String = fs.build_box_sectioned(box_lines, "#FFB000")
		append_output(box + "\n", false)

		# 进入文件密码输入模式
		_file_password_mode = true
		_file_password_target = file_path
		_file_password_filename = filename
		input_field.placeholder_text = "输入文件密码..."
		return

	# 先等待打字队列全部完成
	while _is_typing:
		await get_tree().process_frame

	# 显示进度条（直接操作output_text，不走打字队列）
	var content_size: int = node.content.length()
	await _show_progress_bar(content_size)

	# 进度条完成后等待一小会
	await get_tree().create_timer(0.5).timeout

	# 清屏进入阅读模式
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false

	# 显示文件头
	var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
	output_text.append_text(header + "\n\n")

	# 记录已读
	if not read_files.has(file_path):
		read_files.append(file_path)
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

	# 显示文件内容（走打字机，不加额外空行）
	var clean_content: String = node.content.strip_edges()
	clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
	append_output(clean_content, false)

	# 文件尾放入队列，等内容打完后显示
	append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)

func _cmd_back() -> void:
	if current_path == "/":
		append_output("[color=#AAAAAA]已经在根目录了。[/color]")
		return

	current_path = fs.get_parent_path(current_path)
	_update_status_bar()
	append_output("已返回: " + current_path + "\n", false)

func _cmd_clear() -> void:
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false

func _cmd_status() -> void:
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
	lines.append("  用户名: [color=#66FF66]未登录[/color]")
	lines.append("  权限等级:   [color=#FFB000]" + str(fs.player_clearance) + "[/color]")
	lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
	lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
	lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
	lines.append("  已解锁文件: [color=#66FF66]" + str(fs.unlocked_file_passwords.size()) + "[/color]")
	if not story_id.is_empty():
		lines.append("  盘ID: [color=#AAAAAA]" + story_id + "[/color]")
	lines.append("[color=#66FF66]════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_mail(args: Array) -> void:
	append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)

func _cmd_exit() -> void:
	append_output("[color=#AAAAAA]正在断开连接...[/color]")
	await get_tree().create_timer(1.0).timeout
	get_tree().quit()

func _cmd_whoami() -> void:
	append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)

func _cmd_story_info() -> void:
	if story_manifest.is_empty() and available_stories.is_empty():
		append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
		return

	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")

	if available_stories.size() > 0:
		lines.append("")
		lines.append("  已发现 [color=#66FF66]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
		lines.append("")
		for i in range(available_stories.size()):
			var info: Dictionary = available_stories[i]
			var marker: String = ""
			if i == current_story_index:
				marker = " [color=#33FF33]<< 当前[/color]"
			lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]" + marker)
			lines.append("     作者: [color=#AAAAAA]" + info.get("author", "未知") + "[/color]")
		lines.append("")
		lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 切换磁盘[/color]")
		lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]scan[/color][color=#AAAAAA] 重新扫描目录[/color]")

	# 当前加载的磁盘详细信息
	if story_manifest.has("story"):
		lines.append("")
		lines.append("[color=#66FF66]─────────── 当前磁盘详情 ───────────[/color]")
		var info: Dictionary = story_manifest["story"]
		lines.append("  磁盘标签: [color=#66FF66]" + info.get("title", "未知") + "[/color]")
		lines.append("  制作者:   [color=#66FF66]" + info.get("author", "未知") + "[/color]")
		lines.append("  版本: [color=#66FF66]" + info.get("version", "未知") + "[/color]")
		if info.has("description"):
			lines.append("  描述: [color=#AAAAAA]" + info["description"] + "[/color]")
		lines.append("  文件总数: [color=#66FF66]" + str(fs.file_system.size()) + "[/color]")
		lines.append("  磁盘来源: [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
		lines.append("  磁盘状态: [color=#33FF33]已挂载[/color]")

	lines.append("[color=#66FF66]═══════════════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_vdisc_load(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: vdisc load <编号>[/color]\n[color=#AAAAAA]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
		return

	var index_str: String = args[0]
	if not index_str.is_valid_int():
		append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
		return

	var index: int = index_str.to_int() - 1  # 用户输入从1开始
	if index < 0 or index >= available_stories.size():
		append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return

	if index == current_story_index:
		append_output("[color=#AAAAAA]该磁盘已经是当前加载的磁盘。[/color]\n", false)
		return

	# 保存当前剧本存档
	save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

	append_output("[color=#AAAAAA]正在卸载当前磁盘...[/color]", false)

	# 等待打字完成
	while _is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.3).timeout

	# 重置状态
	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	read_files.clear()
	unlocked_passwords.clear()

	# 显示加载进度条
	await _show_progress_bar(800)
	await get_tree().create_timer(0.3).timeout

	# 加载新剧本
	if _load_story_by_index(index):
		var title: String = available_stories[index].get("title", "未知")
		var box: String = fs.build_box_sectioned([
			["DISC LOADED", "磁盘加载完成"],
			[title]
		], "#33FF33")
		append_output(box + "\n", false)
		_update_status_bar()
		append_output("[color=#AAAAAA]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
		append_output("[color=#AAAAAA]当前路径: " + current_path + "  权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
	else:
		append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
		fs.init_test_file_system()
		_update_status_bar()

func _cmd_unlock(args: Array) -> void:
	# 如果带了参数，直接验证（兼容旧用法）
	if not args.is_empty():
		_verify_password(args[0])
		return
	# 无参数，进入密码输入模式
	_enter_password_mode()

func _enter_password_mode(target_path: String = "") -> void:
	_password_mode = true
	_password_target_path = target_path
	var box: String = fs.build_box_sectioned([
		["SECURITY AUTHENTICATION", "安全认证系统"],
		["请输入访问密码:", "(输入 cancel 取消)"]
	], "#FFB000")
	append_output(box + "\n", false)
	# 修改输入框提示
	input_field.placeholder_text = "输入密码..."

func _verify_password(password: String) -> void:
	# 从manifest中查找密码
	if not story_manifest.has("passwords"):
		append_output("[color=#FF6666][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
		return

	var passwords: Dictionary = story_manifest["passwords"]

	if passwords.has(password):
		var pwd_info: Dictionary = passwords[password]
		var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))

		if unlocked_passwords.has(password):
			append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
			return
		if grant_level <= fs.player_clearance:
			append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。当前: " + str(fs.player_clearance) + "[/color]\n", false)
			return

		# 解锁成功
		unlocked_passwords.append(password)
		var old_level: int = fs.player_clearance
		fs.player_clearance = grant_level
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

		# 成功动画
		var box: String = fs.build_box_sectioned([
			["ACCESS GRANTED", "权限认证通过"],
			["权限等级: " + str(old_level) + " -> " + str(fs.player_clearance)]
		], "#33FF33")
		append_output(box + "\n", false)

		# 显示提示信息（如果有）
		if pwd_info.has("message"):
			append_output("[color=#AAAAAA]" + str(pwd_info["message"]) + "[/color]\n", false)
	else:
		var box: String = fs.build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], "#FF6666")
		append_output(box + "\n", false)

func _verify_file_password(input_password: String) -> void:
	var fp_key: String = fs.get_file_password_key(_file_password_target)
	if fp_key.is_empty():
		append_output("[color=#FF6666][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
		return

	var fp_info: Dictionary = fs.story_file_passwords[fp_key]
	var correct_password: String = str(fp_info.get("password", ""))

	if input_password == correct_password:
		# 密码正确
		fs.unlocked_file_passwords.append(_file_password_target)
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

		var box: String = fs.build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], "#33FF33")
		append_output(box + "\n", false)

		# 等打字完成后自动打开文件
		while _is_typing:
			await get_tree().process_frame
		await get_tree().create_timer(0.5).timeout
		# 重新执行打开文件
		await _cmd_open([_file_password_filename])
	else:
		var box: String = fs.build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], "#FF6666")
		append_output(box + "\n", false)

func _cmd_scan() -> void:
	append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)

	# 等待打字完成
	while _is_typing:
		await get_tree().process_frame

	# 显示扫描进度条
	await _show_progress_bar(500)
	await get_tree().create_timer(0.3).timeout

	# 保存旧状态用于对比
	var old_story_path: String = current_story_path

	# 重置文件系统和权限
	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	read_files.clear()
	unlocked_passwords.clear()
	available_stories.clear()
	current_story_index = -1

	# 重新扫描
	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	if _desktop_mode:
		# 桌面模式：只扫描，不自动加载
		if available_stories.is_empty():
			append_output("[color=#FFB000][WARN] 未找到虚拟磁盘文件。[/color]", false)
			append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
		else:
			var scan_lines: Array[String] = []
			scan_lines.append("[color=#33FF33][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
			scan_lines.append("")
			for i in range(available_stories.size()):
				var info: Dictionary = available_stories[i]
				scan_lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]")
			scan_lines.append("")
			scan_lines.append("[color=#AAAAAA]输入 [/color][color=#66FF66]load <编号>[/color][color=#AAAAAA] 加载磁盘。[/color]")
			append_output("\n".join(scan_lines) + "\n", false)
		_update_status_bar()
	else:
		# 终端模式：重新加载当前磁盘
		if available_stories.is_empty():
			_desktop_mode = true
			fs.init_test_file_system()
			current_path = "/"
			_update_status_bar()
			append_output("[color=#FFB000][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
		elif _load_story_by_index(0):
			var title: String = "未知"
			if story_manifest.has("story") and story_manifest["story"].has("title"):
				title = story_manifest["story"]["title"]
			append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]", false)
			append_output("[color=#AAAAAA]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions

### USER
继续，把剩下的file_system.gd代码发给我

### ASSISTANT
好的，之前的回复在 `_cmd_scan()` 函数中间被截断了。以下是 `main.gd` 从截断处开始的**剩余完整代码**：

```gdscript
# ============================================================
# _cmd_scan 函数的剩余部分（接上文 story_permissions 那行）
# ============================================================
			append_output("[color=#AAAAAA]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
			if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
				current_path = story_manifest["settings"]["start_path"]
			else:
				current_path = "/"
			_update_status_bar()
		else:
			append_output("[color=#FF6666][ERROR] 重新加载失败。[/color]\n", false)

func _cmd_reboot() -> void:
	append_output("[color=#AAAAAA]正在重启终端...[/color]", false)

	# 等待打字完成
	while _is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.5).timeout

	# 清空所有状态
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false
	command_history.clear()
	history_index = -1

	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	has_new_mail = false
	read_files.clear()
	unlocked_passwords.clear()
	available_stories.clear()
	current_story_index = -1

	# 重新加载
	save_mgr.ensure_stories_dir()
	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	# 模拟重启效果
	output_text.append_text("[color=#AAAAAA]...[/color]\n")
	await get_tree().create_timer(0.3).timeout
	output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
	await get_tree().create_timer(0.5).timeout
	output_text.text = ""

	# 回到桌面
	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()
	input_field.grab_focus()

# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
	if command_history.is_empty():
		return
	if history_index == -1:
		current_input_backup = input_field.text
		history_index = command_history.size() - 1
	elif history_index > 0:
		history_index -= 1
	input_field.text = command_history[history_index]
	input_field.caret_column = input_field.text.length()

func _history_next() -> void:
	if command_history.is_empty() or history_index == -1:
		return
	if history_index < command_history.size() - 1:
		history_index += 1
		input_field.text = command_history[history_index]
	else:
		history_index = -1
		input_field.text = current_input_backup
	input_field.caret_column = input_field.text.length()

# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
	var current_text: String = input_field.text
	if current_text.strip_edges().is_empty():
		return

	var parts := current_text.split(" ", false)

	# 只输入了一个词：补全命令
	if parts.size() == 1:
		if current_text.ends_with(" "):
			# 命令已输入完，补全文件名
			var cmd: String = parts[0].to_lower()
			if cmd in ["cd", "open", "cat"]:
				var children := fs.get_children_at_path(current_path)
				if children.size() > 0:
					var display: Array[String] = []
					for child in children:
						var child_path := fs.join_path(current_path, child)
						var node := fs.get_node_at_path(child_path)
						if node == null:
							continue
						if cmd == "cd" and node.type == "folder":
							display.append(child + "/")
						elif cmd in ["open", "cat"] and node.type == "file":
							display.append(child)
						elif cmd not in ["cd"]:
							display.append(child)
					if display.size() > 0:
						output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
						_do_scroll()
		else:
			# 补全命令名
			var partial_cmd: String = parts[0].to_lower()
			var commands: Array
			if _desktop_mode:
				commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
			else:
				commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
					"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
					"scan", "reboot", "restart", "unlock", "eject"]

			var matches: Array[String] = []
			for cmd in commands:
				if cmd.begins_with(partial_cmd):
					matches.append(cmd)

			if matches.size() == 1:
				input_field.text = matches[0] + " "
				input_field.caret_column = input_field.text.length()
			elif matches.size() > 1:
				output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
				_do_scroll()

	# 两个词：命令 + 部分文件名
	elif parts.size() == 2:
		var cmd: String = parts[0].to_lower()
		var partial_name: String = parts[1]

		if cmd in ["cd", "open", "cat"]:
			var children := fs.get_children_at_path(current_path)
			var matches: Array[String] = []

			for child in children:
				if child.to_lower().begins_with(partial_name.to_lower()):
					var child_path := fs.join_path(current_path, child)
					var node := fs.get_node_at_path(child_path)
					if node == null:
						continue
					if cmd == "cd" and node.type == "folder":
						matches.append(child)
					elif cmd in ["open", "cat"] and node.type == "file":
						matches.append(child)

			if matches.size() == 1:
				input_field.text = cmd + " " + matches[0]
				input_field.caret_column = input_field.text.length()
			elif matches.size() > 1:
				var common: String = _find_common_prefix(matches)
				if common.length() > partial_name.length():
					input_field.text = cmd + " " + common
					input_field.caret_column = input_field.text.length()
				output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
				_do_scroll()

func _find_common_prefix(strings: Array[String]) -> String:
	if strings.is_empty():
		return ""
	if strings.size() == 1:
		return strings[0]
	var prefix: String = strings[0]
	for i in range(1, strings.size()):
		while not strings[i].to_lower().begins_with(prefix.to_lower()):
			prefix = prefix.substr(0, prefix.length() - 1)
			if prefix.is_empty():
				return ""
	return prefix

# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
	_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
	if not _is_typing:
		_process_typewriter_queue()

func _process_typewriter_queue() -> void:
	if _typewriter_queue.is_empty():
		_is_typing = false
		return
	_is_typing = true
	var entry = _typewriter_queue.pop_front()
	var text: String = entry["text"]
	var extra_newline: bool = entry["extra_newline"]

	if _typewriter_instant:
		output_text.append_text(text)
		if extra_newline:
			output_text.append_text("\n")
		_do_scroll()
		_process_typewriter_queue()
	else:
		_typewrite_text(text, extra_newline)

func _typewrite_text(text: String, extra_newline: bool = true) -> void:
	var i: int = 0
	var length: int = text.length()
	_current_char_speed = _typewriter_speed

	while i < length:
		if _typewriter_instant:
			output_text.append_text(text.substr(i))
			break

		if text[i] == "[":
			var close_bracket: int = text.find("]", i)
			if close_bracket != -1:
				var tag: String = text.substr(i, close_bracket - i + 1)

				if tag.begins_with("[speed="):
					var speed_str: String = tag.substr(7, tag.length() - 8)
					_current_char_speed = speed_str.to_float()
					i = close_bracket + 1
					continue
				elif tag == "[/speed]":
					_current_char_speed = _typewriter_speed
					i = close_bracket + 1
					continue
				elif tag.begins_with("[pause="):
					var pause_str: String = tag.substr(7, tag.length() - 8)
					var pause_time: float = pause_str.to_float()
					await get_tree().create_timer(pause_time).timeout
					i = close_bracket + 1
					continue

				var tag_inner: String = tag.substr(1, tag.length() - 2)
				if tag_inner.length() > 0 and (tag_inner[0] == "/" or tag_inner[0].unicode_at(0) >= 65 and tag_inner[0].unicode_at(0) <= 122):
					output_text.append_text(tag)
					i = close_bracket + 1
					continue

				output_text.append_text("[lb]")
				i += 1
				continue

		var ch: String = text[i]

		if ch == "\n":
			var newlines: String = "\n"
			i += 1
			while i < length and text[i] == "\n":
				newlines += "\n"
				i += 1
			output_text.append_text(newlines)
			if not _typewriter_instant:
				await get_tree().create_timer(_typewriter_period_pause).timeout
			_do_scroll()
			continue

		output_text.append_text(ch)
		i += 1

		var delay: float = _current_char_speed
		if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
			delay += _typewriter_period_pause
		elif ch in ["、", "—", "-", "…"]:
			delay += _typewriter_comma_pause
		else:
			if randf() < _typewriter_pause_chance:
				delay += _typewriter_pause_duration

		await get_tree().create_timer(delay).timeout

		if i % 8 == 0:
			_do_scroll()

	if extra_newline:
		output_text.append_text("\n")
	_do_scroll()
	_process_typewriter_queue()

func _do_scroll() -> void:
	_needs_scroll = true

func _process(_delta: float) -> void:
	if _needs_scroll:
		var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
		scroll_container.scroll_vertical = int(v_scroll.max_value)
		_needs_scroll = false

func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
	var bar_width: int = 30
	var speed: float = _progress_bar_speed
	if speed_override > 0.0:
		speed = speed_override

	var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
	base_delay /= speed

	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text("[color=#66FF66]加载中 [[/color]")

	for i in range(bar_width):
		if _typewriter_instant:
			var remaining: int = bar_width - i
			output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
			break
		output_text.append_text("[color=#33FF33]█[/color]")
		_do_scroll()
		var jitter: float = randf_range(0.7, 1.5)
		await get_tree().create_timer(base_delay * jitter).timeout

	output_text.append_text("[color=#66FF66]] 完成[/color]\n")
	_do_scroll()

# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
	if _desktop_mode:
		path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
		mail_icon.text = "[Mail]"
		return

	var disc_name: String = ""
	if current_story_index >= 0 and current_story_index < available_stories.size():
		disc_name = available_stories[current_story_index].get("title", "")

	if disc_name.is_empty():
		path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance)
	else:
		path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance) + "  DISC:" + disc_name

	if has_new_mail:
		mail_icon.text = "[Mail NEW]"
	else:
		mail_icon.text = "[Mail]"

# ============================================================
# 超链接处理
# ============================================================
func _on_meta_clicked(meta: Variant) -> void:
	var meta_str: String = str(meta)

	if meta_str.begins_with("cmd://"):
		var cmd: String = meta_str.substr(6)
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + cmd)
		output_text.append_text("\n")
		_execute_command(cmd)
		return

	if meta_str.begins_with("file://"):
		var file_path: String = meta_str.substr(7)
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> open " + file_path)
		output_text.append_text("\n")
		await _cmd_open([file_path])
		return

	print("[Terminal] 未知链接: " + meta_str)

# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
	var title: String = "SCP FOUNDATION TERMINAL v0.1"
	var subtitle: String = "SECURE - CONTAIN - PROTECT"
	var box: String = fs.build_box([title, subtitle] as Array[String], "#66FF66")

	output_text.append_text(box + "\n\n")

	if available_stories.is_empty():
		output_text.append_text("[color=#FFB000]未检测到虚拟磁盘。[/color]\n")
		output_text.append_text("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
	else:
		output_text.append_text("[color=#66FF66]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
		for i in range(available_stories.size()):
			var info: Dictionary = available_stories[i]
			output_text.append_text("  [color=#FFB000]" + str(i + 1) + ".[/color] [color=#66FF66]" + info.get("title", "未知") + "[/color]\n")
			output_text.append_text("     [color=#AAAAAA]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
		output_text.append_text("\n")

	output_text.append_text("[color=#AAAAAA]可用命令:[/color]\n")
	output_text.append_text("  [color=#66FF66]load <编号>[/color]   加载指定磁盘\n")
	output_text.append_text("  [color=#66FF66]scan[/color]   重新扫描磁盘目录\n")
	output_text.append_text("  [color=#66FF66]clear[/color] 清空屏幕\n")
	output_text.append_text("  [color=#66FF66]exit[/color]   退出终端\n")

func _cmd_desktop_load(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: load <编号>[/color]", false)
		if available_stories.size() > 0:
			append_output("[color=#AAAAAA]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return

	var index_str: String = args[0]
	if not index_str.is_valid_int():
		append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
		return

	var index: int = index_str.to_int() - 1
	if index < 0 or index >= available_stories.size():
		append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return

	append_output("[color=#AAAAAA]正在加载虚拟磁盘...[/color]", false)

	while _is_typing:
		await get_tree().process_frame

	await _show_progress_bar(800)
	await get_tree().create_timer(0.3).timeout

	if _load_story_by_index(index):
		_desktop_mode = false
		var title: String = available_stories[index].get("title", "未知")

		output_text.text = ""
		_typewriter_queue.clear()
		_is_typing = false
		_typewriter_instant = false

		_update_status_bar()
		_show_welcome_message()
	else:
		append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)

func _cmd_eject() -> void:
	if _desktop_mode:
		append_output("[color=#AAAAAA]当前已在桌面模式。[/color]\n", false)
		return

	save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

	append_output("[color=#AAAAAA]正在卸载磁盘...[/color]", false)

	while _is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.5).timeout

	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	read_files.clear()
	unlocked_passwords.clear()
	current_story_index = -1

	_desktop_mode = true
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false

	_update_status_bar()
	_show_desktop_welcome()

# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
	var title: String = "SCP FOUNDATION TERMINAL v0.1"
	var subtitle: String = "SECURE - CONTAIN - PROTECT"

	if story_manifest.has("story"):
		var story_info: Dictionary = story_manifest["story"]
		if story_info.has("title"):
			subtitle = story_info["title"]

	var title_display_len: int = fs.display_width(title)
	var subtitle_display_len: int = fs.display_width(subtitle)
	var inner_width: int = max(title_display_len, subtitle_display_len) + 6

	var title_pad_total: int = inner_width - title_display_len
	var title_pad_left: int = title_pad_total / 2
	var title_pad_right: int = title_pad_total - title_pad_left

	var subtitle_pad_total: int = inner_width - subtitle_display_len
	var subtitle_pad_left: int = subtitle_pad_total / 2
	var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left

	var border_h: String = "═".repeat(inner_width)

	var welcome: String = ""
	welcome += "[color=#66FF66]╔" + border_h + "╗\n"
	welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
	welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
	welcome += "╚" + border_h + "╝[/color]\n"
	welcome += "\n"
	welcome += "[color=#AAAAAA]终端系统已启动。\n"
	welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"

	output_text.append_text(welcome)

# ============================================================
# 背景初始化
# ============================================================
func _setup_background() -> void:
	background = TextureRect.new()
	background.name = "Background"
	add_child(background)
	move_child(background, 0)

	background.set_anchors_preset(Control.PRESET_FULL_RECT)
	background.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
	background.mouse_filter = Control.MOUSE_FILTER_IGNORE

	var bg_path: String = save_mgr.get_game_root_dir() + "background.png"
	var tex: Texture2D = null

	if FileAccess.file_exists(bg_path):
		var image := Image.new()
		var err := image.load(bg_path)
		if err == OK:
			tex = ImageTexture.create_from_image(image)
			print("[UI] 已加载外部背景图: " + bg_path)
		else:
			print("[UI] 背景图加载失败: " + str(err))

	if tex == null:
		var image := Image.create(4, 4, false, Image.FORMAT_RGB8)
		image.fill(Color(0.02, 0.04, 0.02, 1.0))
		tex = ImageTexture.create_from_image(image)
		print("[UI] 使用默认深色背景")

	background.texture = tex

	var shader_path: String = "res://background_vignette.gdshader"
	if ResourceLoader.exists(shader_path):
		var shader: Shader = load(shader_path)
		var mat := ShaderMaterial.new()
		mat.shader = shader
		mat.set_shader_parameter("vignette_strength", 0.8)
		mat.set_shader_parameter("vignette_radius", 0.9)
		mat.set_shader_parameter("glow_strength", 0.08)
		mat.set_shader_parameter("glow_radius", 0.4)
		mat.set_shader_parameter("brightness", 0.7)
		mat.set_shader_parameter("tint_color", Color(0.1, 0.3, 0.1, 0.15))
		background.material = mat
		print("[UI] 背景Shader已应用")
	else:
		print("[UI] 未找到背景Shader文件: " + shader_path)

# ============================================================
# 剧本加载系统
# ============================================================
func _try_load_story() -> bool:
	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	print("[StoryLoader] 搜索目录: " + vdisc_dir)
	_scan_available_stories(vdisc_dir)
	return not available_stories.is_empty()

func _scan_available_stories(vdisc_dir: String) -> void:
	available_stories.clear()

	if not DirAccess.dir_exists_absolute(vdisc_dir):
		return

	var dir := DirAccess.open(vdisc_dir)
	if dir == null:
		return

	dir.list_dir_begin()
	var file_name := dir.get_next()
	while file_name != "":
		if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
			var full_path: String = vdisc_dir + file_name
			var info: Dictionary = _peek_story_info(full_path)
			info["path"] = full_path
			info["filename"] = file_name
			available_stories.append(info)
			print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
		file_name = dir.get_next()

	print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")

func _peek_story_info(path: String) -> Dictionary:
	var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}

	var reader := ZIPReader.new()
	if reader.open(path) != OK:
		return info

	var files := reader.get_files()
	for file_path in files:
		var filename: String = file_path.get_file()
		if filename == "manifest.json":
			var content_bytes := reader.read_file(file_path)
			if content_bytes != null:
				var content: String = content_bytes.get_string_from_utf8()
				var json := JSON.new()
				if json.parse(content) == OK and json.data is Dictionary:
					var data: Dictionary = json.data
					if data.has("story"):
						var story_info: Dictionary = data["story"]
						info["title"] = story_info.get("title", "未知剧本")
						info["id"] = story_info.get("id", "")
						info["author"] = story_info.get("author", "未知")
			break
		elif filename == "manifest.cfg":
			var content_bytes := reader.read_file(file_path)
			if content_bytes != null:
				var content: String = content_bytes.get_string_from_utf8()
				for line in content.split("\n"):
					line = line.strip_edges()
					if line.begins_with("title="):
						info["title"] = line.substr(6).strip_edges()
					elif line.begins_with("id="):
						info["id"] = line.substr(3).strip_edges()
					elif line.begins_with("author="):
						info["author"] = line.substr(7).strip_edges()
			break

	reader.close()
	return info

func _load_story_by_index(index: int) -> bool:
	if index < 0 or index >= available_stories.size():
		return false
	var story_info: Dictionary = available_stories[index]
	var path: String = story_info["path"]
	if _load_story_file(path):
		current_story_index = index
		return true
	return false

func _load_story_file(path: String) -> bool:
	story_loader = StoryLoader.new()
	if not story_loader.load_story(path):
		print("[StoryLoader] 加载失败: " + story_loader.error_message)
		return false

	# 应用加载的数据到 fs 模块
	fs.file_system = story_loader.file_system
	story_manifest = story_loader.manifest
	current_story_path = path

	# 读取盘ID
	if story_manifest.has("story") and story_manifest["story"].has("id"):
		story_id = story_manifest["story"]["id"]
	else:
		story_id = str(path.get_file().hash())

	# 读取权限表
	fs.story_permissions.clear()
	if story_manifest.has("permissions"):
		var perms: Dictionary = story_manifest["permissions"]
		for perm_path in perms.keys():
			fs.story_permissions[perm_path] = int(perms[perm_path])
		print("[StoryLoader] 权限表已加载，共 " + str(fs.story_permissions.size()) + " 条规则")
	else:
		print("[StoryLoader] 警告: manifest中未找到permissions字段")

	if story_manifest.has("passwords"):
		print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
	else:
		print("[StoryLoader] 警告: manifest中未找到passwords字段")

	# 读取文件密码表
	fs.story_file_passwords.clear()
	if story_manifest.has("file_passwords"):
		var fps: Dictionary = story_manifest["file_passwords"]
		for fp_path in fps.keys():
			fs.story_file_passwords[fp_path] = fps[fp_path]
		print("[StoryLoader] 文件密码表已加载，共 " + str(fs.story_file_passwords.size()) + " 条")
	else:
		print("[StoryLoader] 未配置文件密码表（file_passwords）")

	# 应用 manifest 中的设置
	var start_clearance: int = 0
	if story_manifest.has("settings"):
		var settings: Dictionary = story_manifest["settings"]
		if settings.has("start_path"):
			current_path = settings["start_path"]
		if settings.has("typing_speed"):
			_typewriter_speed = settings["typing_speed"].to_float()
		if settings.has("start_clearance"):
			start_clearance = int(settings["start_clearance"])

	# 尝试加载该剧本的存档
	var save_data = save_mgr.load_save(story_id)
	if save_data != null:
		fs.player_clearance = int(save_data.get("player_clearance", 0))

		read_files.clear()
		if save_data.has("read_files"):
			for f in save_data["read_files"]:
				read_files.append(str(f))

		unlocked_passwords.clear()
		if save_data.has("unlocked_passwords"):
			for p in save_data["unlocked_passwords"]:
				unlocked_passwords.append(str(p))

		fs.unlocked_file_passwords.clear()
		if save_data.has("unlocked_file_passwords"):
			for p in save_data["unlocked_file_passwords"]:
				fs.unlocked_file_passwords.append(str(p))

		if save_data.has("current_path"):
			var saved_path: String = save_data["current_path"]
			if fs.has_clearance(saved_path):
				current_path = saved_path
			else:
				current_path = "/"
				if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
					current_path = story_manifest["settings"]["start_path"]
		print("[Save] 权限等级: " + str(fs.player_clearance))
	else:
		# 没有存档，用初始权限
		fs.player_clearance = start_clearance
		read_files.clear()
		unlocked_passwords.clear()

	var title: String = "未知剧本"
	if story_manifest.has("story") and story_manifest["story"].has("title"):
		title = story_manifest["story"]["title"]

	print("[StoryLoader] 成功加载: " + title)
	print("[StoryLoader] 盘ID: " + story_id)
	print("[StoryLoader] 文件数量: " + str(fs.file_system.size()))
	print("[StoryLoader] 权限等级: " + str(fs.player_clearance))
	print("[StoryLoader] story_permissions 内容: " + str(fs.story_permissions))
	print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))

	return true
```

---

## 改动总结

**新建文件：`scripts/file_system.gd`**
- `FSNode` 内部类
- 路径工具：`join_path()`、`get_parent_path()`、`normalize_path()`
- 节点查询：`get_node_at_path()`、`get_children_at_path()`
- 权限检查：`get_required_clearance()`、`has_clearance()`
- 文件密码：`get_file_password_key()`、`is_file_password_unlocked()`
- 显示工具：`display_width()`、`build_box()`、`build_box_sectioned()`
- 测试数据：`init_test_file_system()`
- 重置方法：`clear_all()`

**main.gd 关键变更：**
- 新增模块实例 `var fs: FileSystem = FileSystem.new()`
- 删除了原有的 `file_system`、`story_permissions`、`story_file_passwords`、`player_clearance`（权限）、`unlocked_file_passwords` 变量，改为通过 `fs.xxx` 访问
- 所有调用点统一改为 `fs.` 前缀，例如：
  - `_join_path()` → `fs.join_path()` 
  - `_get_node_at_path()` → `fs.get_node_at_path()` 
  - `_has_clearance()` → `fs.has_clearance()` 
  - `_build_box()` → `fs.build_box()` 
  - `_display_width()` → `fs.display_width()` [1]
- `_load_story_file()` 中数据写入改为 `fs.file_system =`、`fs.story_permissions[]=`、`fs.player_clearance =` 等 [1]
- 存档调用中的 `player_clearance` 改为 `fs.player_clearance`，`unlocked_file_passwords` 改为 `fs.unlocked_file_passwords`

**验证清单：**
1. 运行项目，确认桌面欢迎界面正常
2. `load` 加载磁盘 → 确认文件系统数据加载正确
3. `ls` → 确认目录列表、LOCKED/PASSWORD 标记正常
4. `cd` → 确认路径切换和权限拦截正常
5. `open` → 确认文件打开、文件密码流程正常
6. `unlock` → 确认权限提升和存档保存正常
7. `status` → 确认显示的权限等级正确
8. `eject` → 确认 `fs.clear_all()` 正确重置
9. `reboot` → 确认完全重置正常

### USER
没问题了，进行下一步拆分。注意不要把修改部分的代码全部发给我，会导致对话中断。

### ASSISTANT
# Step 3：拆分 typewriter.gd — 打字机效果引擎

## 新建 `scripts/typewriter.gd` 完整代码

```gdscript
# ============================================================
# typewriter.gd - 打字机效果引擎
# 负责：逐字输出、队列管理、进度条动画、滚动控制
# ============================================================
class_name Typewriter
extends Node

# ============================================================
# UI 节点引用（由 main.gd 初始化时传入）
# ============================================================
var output_text: RichTextLabel = null
var scroll_container: ScrollContainer = null

# ============================================================
# 打字机状态
# ============================================================
var queue: Array[Dictionary] = []       # 待显示的文本队列
var is_typing: bool = false             # 是否正在打字
var instant: bool = false               # 是否跳过动画（用户按了空格/ESC）

# ============================================================
# 速度参数
# ============================================================
var base_speed: float = 0.008            # 基础打字速度
var pause_chance: float = 0.08           # 随机停顿概率
var pause_duration: float = 0.06         # 随机停顿时长
var comma_pause: float = 0.04            # 逗号/分号后的停顿
var period_pause: float = 0.08           # 句号/冒号/换行后的停顿
var progress_bar_speed: float = 1.0      # 进度条基础速度倍率
var _current_char_speed: float = 0.008   # 当前生效速度（可被 [speed=] 控制）

# ============================================================
# 滚动控制
# ============================================================
var _needs_scroll: bool = false

# ============================================================
# 初始化
# ============================================================
func setup(p_output: RichTextLabel, p_scroll: ScrollContainer) -> void:
	output_text = p_output
	scroll_container = p_scroll

# ============================================================
# 外部接口：追加文本到队列
# ============================================================
func append(text: String, extra_newline: bool = true) -> void:
	queue.append({"text": text, "extra_newline": extra_newline})
	if not is_typing:
		_process_queue()

# ============================================================
# 队列处理
# ============================================================
func _process_queue() -> void:
	if queue.is_empty():
		is_typing = false
		return

	is_typing = true
	var entry = queue.pop_front()
	var text: String = entry["text"]
	var extra_newline: bool = entry["extra_newline"]

	if instant:
		output_text.append_text(text)
		if extra_newline:
			output_text.append_text("\n")
		_do_scroll()
		_process_queue()
	else:
		_typewrite_text(text, extra_newline)

# ============================================================
# 逐字输出核心逻辑
# ============================================================
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
	var i: int = 0
	var length: int = text.length()
	_current_char_speed = base_speed

	while i < length:
		# 如果中途切换为即时模式，把剩余文本一次性输出
		if instant:
			output_text.append_text(text.substr(i))
			break

		# 检查是否是BBCode标签
		if text[i] == "[":
			var close_bracket: int = text.find("]", i)
			if close_bracket != -1:
				var tag: String = text.substr(i, close_bracket - i + 1)

				# 自定义速度标签 [speed=0.05]
				if tag.begins_with("[speed="):
					var speed_str: String = tag.substr(7, tag.length() - 8)
					_current_char_speed = speed_str.to_float()
					i = close_bracket + 1
					continue
				elif tag == "[/speed]":
					_current_char_speed = base_speed
					i = close_bracket + 1
					continue
				elif tag.begins_with("[pause="):
					# 自定义暂停标签 [pause=0.5]
					var pause_str: String = tag.substr(7, tag.length() - 8)
					var pause_time: float = pause_str.to_float()
					await get_tree().create_timer(pause_time).timeout
					i = close_bracket + 1
					continue

				# 判断是否是合法的BBCode标签
				var tag_inner: String = tag.substr(1, tag.length() - 2)
				if tag_inner.length() > 0 and (tag_inner[0] == "/" or tag_inner[0].unicode_at(0) >= 65 and tag_inner[0].unicode_at(0) <= 122):
					output_text.append_text(tag)
					i = close_bracket + 1
					continue

				# 不是BBCode标签，转义方括号后逐字输出
				output_text.append_text("[lb]")
				i += 1
				continue

		# 普通字符
		var ch: String = text[i]

		# 换行符批量处理
		if ch == "\n":
			var newlines: String = "\n"
			i += 1
			while i < length and text[i] == "\n":
				newlines += "\n"
				i += 1
			output_text.append_text(newlines)
			if not instant:
				await get_tree().create_timer(period_pause).timeout
			_do_scroll()
			continue

		output_text.append_text(ch)
		i += 1

		# 根据字符类型决定延迟
		var delay: float = _current_char_speed
		if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
			delay += period_pause
		elif ch in ["、", "—", "-", "…"]:
			delay += comma_pause
		else:
			if randf() < pause_chance:
				delay += pause_duration

		await get_tree().create_timer(delay).timeout

		# 每隔几个字符滚动一次
		if i % 8 == 0:
			_do_scroll()

	# 当前文本打完
	if extra_newline:
		output_text.append_text("\n")
	_do_scroll()

	# 继续处理队列
	_process_queue()

# ============================================================
# 进度条动画
# ============================================================
func show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
	var bar_width: int = 30
	var speed: float = progress_bar_speed
	if speed_override > 0.0:
		speed = speed_override

	var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
	base_delay /= speed

	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text("[color=#66FF66]加载中 [[/color]")

	for i in range(bar_width):
		if instant:
			var remaining: int = bar_width - i
			output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
			break
		output_text.append_text("[color=#33FF33]█[/color]")
		_do_scroll()
		var jitter: float = randf_range(0.7, 1.5)
		await get_tree().create_timer(base_delay * jitter).timeout

	output_text.append_text("[color=#66FF66]] 完成[/color]\n")
	_do_scroll()

# ============================================================
# 滚动控制
# ============================================================
func _do_scroll() -> void:
	_needs_scroll = true

func process_scroll() -> void:
	if _needs_scroll:
		var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
		scroll_container.scroll_vertical = int(v_scroll.max_value)
		_needs_scroll = false

# ============================================================
# 重置
# ============================================================
func clear_queue() -> void:
	queue.clear()
	is_typing = false
	instant = false

func skip() -> void:
	instant = true
```

---

## main.gd 修改指南（差异说明）

由于完整代码太长会导致中断，以下用**差异说明**方式告诉你要改哪些地方：

### 1. 新增模块实例声明（在 `var fs: FileSystem` 下方）

```gdscript
var fs: FileSystem = FileSystem.new()
var tw: Typewriter = null  # 需要作为 Node 添加到场景树（因为用了 await）
```

### 2. 删除以下变量（已移入 typewriter.gd）

```
删除: _typewriter_queue
删除: _is_typing
删除: _typewriter_speed
删除: _typewriter_instant
删除: _typewriter_pause_chance
删除: _typewriter_pause_duration
删除: _typewriter_comma_pause
删除: _typewriter_period_pause
删除: _current_char_speed
删除: _progress_bar_speed
删除: _needs_scroll
```

### 3. 在 `_ready()` 开头添加 Typewriter 初始化

```gdscript
func _ready() -> void:
	# 初始化打字机模块（必须作为子节点添加，因为内部用了 await get_tree()）
	tw = Typewriter.new()
	tw.name = "Typewriter"
	add_child(tw)
	
	save_mgr.ensure_stories_dir()
	save_mgr.ensure_saves_dir()
	# ...后面的代码不变...
```

然后在 `_ready()` 中，在获取完节点引用、设置完样式之后，找到 `output_text.text = ""` 那行附近，添加：

```gdscript
	output_text.text = ""
	output_text.bbcode_enabled = true
	# ... 其他 output_text 设置不变 ...
	
	# 初始化打字机
	tw.setup(output_text, scroll_container)
```

### 4. 全局替换变量引用

以下是**逐项替换规则**（在 main.gd 中全文搜索替换）：

| 搜索 | 替换为 |
|------|--------|
| `_is_typing` | `tw.is_typing` |
| `_typewriter_instant = true` | `tw.skip()` |
| `_typewriter_instant = false` | `tw.instant = false` |
| `_typewriter_instant` | `tw.instant` |
| `_typewriter_speed` | `tw.base_speed` |
| `_typewriter_queue.clear()` | `tw.clear_queue()` |
| `_typewriter_queue` | `tw.queue` |（理论上不应再出现）
| `_progress_bar_speed` | `tw.progress_bar_speed` |

### 5. 删除以下函数（已移入 typewriter.gd）

```
删除: func append_output(...)      → 改为转发
删除: func _process_typewriter_queue(...)
删除: func _typewrite_text(...)
删除: func _show_progress_bar(...)
删除: func _do_scroll(...)
```

### 6. 替换为转发函数

```gdscript
# ============================================================
# 输出工具（转发到打字机模块）
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
	tw.append(text, extra_newline)
```

### 7. 修改 `_process()` 函数

```gdscript
func _process(_delta: float) -> void:
	tw.process_scroll()
```

### 8. 修改 `_input()` 中跳过动画的部分

找到：
```gdscript
	if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
		_typewriter_instant = true
```
改为：
```gdscript
	if tw.is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
		tw.skip()
```

### 9. 修改 `_cmd_clear()`

```gdscript
func _cmd_clear() -> void:
	output_text.text = ""
	tw.clear_queue()
```

### 10. 修改所有 `await _show_progress_bar(...)` 调用

搜索所有 `_show_progress_bar`，替换为 `tw.show_progress_bar`：

- `await _show_progress_bar(content_size)` → `await tw.show_progress_bar(content_size)`
- `await _show_progress_bar(800)` → `await tw.show_progress_bar(800)`
- `await _show_progress_bar(500)` → `await tw.show_progress_bar(500)`

### 11. 修改 `_cmd_open()` 中的清屏部分

找到：
```gdscript
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false
```
改为：
```gdscript
	output_text.text = ""
	tw.clear_queue()
```

### 12. 修改 `_cmd_reboot()` 中的清空部分

找到：
```gdscript
	output_text.text = ""
	_typewriter_queue.clear()
	_is_typing = false
	_typewriter_instant = false
```
改为：
```gdscript
	output_text.text = ""
	tw.clear_queue()
```

### 13. 修改 `_cmd_eject()` 中的清空部分

同上，找到类似的四行改为两行。

### 14. 修改 `_cmd_desktop_load()` 中的清空部分

同上。

### 15. 修改 `_execute_command()` 开头

找到：
```gdscript
	_typewriter_instant = false
```
改为：
```gdscript
	tw.instant = false
```

### 16. 修改 `_load_story_file()` 中的速度设置

找到：
```gdscript
		if settings.has("typing_speed"):
			_typewriter_speed = settings["typing_speed"].to_float()
```
改为：
```gdscript
		if settings.has("typing_speed"):
			tw.base_speed = settings["typing_speed"].to_float()
```

---

## 验证清单

完成以上修改后，逐项测试：

1. **启动** → 桌面欢迎界面正常显示
2. **load 1** → 进度条动画正常播放
3. **open 任意文件** → 打字机逐字输出正常
4. **打字过程中按空格** → 立即跳过完成
5. **连续 open 多个文件** → 队列顺序正确
6. **滚动** → 鼠标滚轮和 PageUp/Down 正常
7. **clear** → 清屏且队列清空
8. **reboot** → 完全重置，打字机状态清空
9. **eject** → 返回桌面，打字机状态清空

完成验证后告诉我结果，我们继续 Step 4（ui_manager.gd）。

### USER
下面是目前的main.gd，你还是把修改好的代码全部发给我吧。
extends Control
# ============================================================
# 节点引用 - 通过 @onready 在场景准备好后自动获取节点
# ============================================================
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
var background: TextureRect = null  # 由代码动态创建背景
# 模块实例
var save_mgr: SaveManager = SaveManager.new()
var fs: FileSystem = FileSystem.new()
var tw: Typewriter = null  # 需要作为 Node 添加到场景树（因为用了 await）
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
var _needs_scroll: bool = false
# 桌面/终端模式
var _desktop_mode: bool = true             # true=桌面模式，false=终端模式（已加载磁盘）
# 打字机效果
var _typewriter_queue: Array[Dictionary] = []  # 待显示的文本队列
var _is_typing: bool = false               # 是否正在打字
var _typewriter_speed: float = 0.008         # 基础速度
var _typewriter_instant: bool = false
var _typewriter_pause_chance: float = 0.08   # 随机停顿概率（0~1）
var _typewriter_pause_duration: float = 0.06 # 停顿时长（秒）
var _typewriter_comma_pause: float = 0.04    # 逗号/分号后的停顿
var _typewriter_period_pause: float = 0.08   # 句号/冒号/换行后的停顿
var _current_char_speed: float = 0.008       # 当前生效的速度（可被文档局部控制）
var _progress_bar_speed: float = 1.0         # 进度条基础速度倍率
# ============================================================
# 剧本系统
# ============================================================
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []  # [{path, title, id}]
var current_story_index: int = -1              # 当前加载的剧本索引
var story_id: String = ""                   # 当前剧本唯一ID
var read_files: Array[String] = []          # 已读文件列表
var unlocked_passwords: Array[String] = []  # 已解锁的密码
# 密码输入弹窗状态
var _password_mode: bool = false            # 是否处于密码输入模式（unlock用）
var _password_target_path: String = ""      # 密码输入针对的路径（空表示通用unlock）
# 文件密码系统
var _file_password_mode: bool = false       # 是否处于文件密码输入模式
var _file_password_target: String = ""      # 当前等待密码的文件路径
var _file_password_filename: String = ""    # 当前等待密码的文件名（用于显示）
# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
save_mgr.ensure_stories_dir()
save_mgr.ensure_saves_dir()
# 启动时只扫描，不自动加载
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# === 背景初始化 ===
_setup_background()
# 确保主内容在背景之上
var main_content := $MainContent
if main_content:
move_child(main_content, get_child_count() - 1)
# 让主内容区背景透明以显示底层背景图
if main_content is Control:
var transparent_style := StyleBoxFlat.new()
transparent_style.bg_color = Color(0, 0, 0, 0)
transparent_style.set_border_width_all(0)
main_content.add_theme_stylebox_override("panel", transparent_style)
# === UI 边框样式 ===
# 状态栏外框（StatusFrame）- 保留外层框，降低发光
var status_frame_style := StyleBoxFlat.new()
status_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
status_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
status_frame_style.set_border_width_all(1)
status_frame_style.content_margin_left = 4
status_frame_style.content_margin_right = 4
status_frame_style.content_margin_top = 3
status_frame_style.content_margin_bottom = 3
status_frame.add_theme_stylebox_override("panel", status_frame_style)
# PathLabel - 去掉内框（透明无边框）
var path_label_style := StyleBoxFlat.new()
path_label_style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
path_label_style.border_color = Color(0.0, 0.0, 0.0, 0.0)
path_label_style.set_border_width_all(0)
path_label_style.content_margin_left = 6
path_label_style.content_margin_right = 6
path_label_style.content_margin_top = 2
path_label_style.content_margin_bottom = 2
path_label.add_theme_stylebox_override("normal", path_label_style)
# MailIcon - 保留内框，降低发光
var mail_style := StyleBoxFlat.new()
mail_style.bg_color = Color(0.0, 0.03, 0.0, 0.6)
mail_style.border_color = Color(0.2, 0.6, 0.2, 0.35)
mail_style.set_border_width_all(1)
mail_style.content_margin_left = 8
mail_style.content_margin_right = 8
mail_style.content_margin_top = 2
mail_style.content_margin_bottom = 2
mail_icon.add_theme_stylebox_override("normal", mail_style)
# 输入区外框（InputFrame）- 只保留这一层框，降低发光
var input_frame_style := StyleBoxFlat.new()
input_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
input_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
input_frame_style.set_border_width_all(1)
input_frame_style.content_margin_left = 4
input_frame_style.content_margin_right = 4
input_frame_style.content_margin_top = 3
input_frame_style.content_margin_bottom = 3
input_frame.add_theme_stylebox_override("panel", input_frame_style)
# InputField - 去掉内框（透明无边框），只靠外层 InputFrame 提供边框
var input_no_border := StyleBoxFlat.new()
input_no_border.bg_color = Color(0.0, 0.0, 0.0, 0.0)
input_no_border.border_color = Color(0.0, 0.0, 0.0, 0.0)
input_no_border.set_border_width_all(0)
input_no_border.content_margin_left = 6
input_no_border.content_margin_right = 6
input_no_border.content_margin_top = 2
input_no_border.content_margin_bottom = 2
input_field.add_theme_stylebox_override("normal", input_no_border)
input_field.add_theme_stylebox_override("focus", input_no_border.duplicate())
output_text.text = ""
output_text.bbcode_enabled = true
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.meta_clicked.connect(_on_meta_clicked)
input_field.focus_mode = Control.FOCUS_ALL
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
input_field.grab_focus()
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 输入处理 - 处理键盘事件（命令历史等）
# ============================================================
func _input(event: InputEvent) -> void:
# 鼠标滚轮滚动
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 点击任意位置聚焦输入框
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
# 点击任何键都确保输入框有焦点
if not input_field.has_focus():
input_field.grab_focus()
# 如果正在打字或加载，按空格或ESC跳过动画
if _is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
_typewriter_instant = true
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
# 如果正在打字，忽略回车（防止干扰）
if _is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理 - 用户按回车后调用
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
# 如果处于文件密码输入模式
if _file_password_mode:
_file_password_mode = false
input_field.placeholder_text = "> 输入命令..."
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 密码回显用星号
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消文件密码输入。[/color]\n", false)
_file_password_target = ""
_file_password_filename = ""
return
await _verify_file_password(raw_input)
return
# 如果处于密码输入模式
if _password_mode:
_password_mode = false
input_field.placeholder_text = "> 输入命令..."
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 密码回显用星号
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消密码输入。[/color]\n", false)
return
_verify_password(raw_input)
return
command_history.append(raw_input)
history_index = -1
# 等待打字队列完成
while _is_typing:
await get_tree().process_frame
# 命令回显用即时显示（不走打字机）
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
# 执行命令（命令输出走打字机效果）
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
_typewriter_instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
# 桌面模式：只允许少数命令
if _desktop_mode:
match command:
"load":
await _cmd_desktop_load(args)
"scan":
await _cmd_scan()
"clear", "cls":
_cmd_clear()
"exit", "quit":
await _cmd_exit()
"help", "?":
_cmd_desktop_help()
"vdisc", "disc", "disk":
_cmd_story_info()
"reboot", "restart":
await _cmd_reboot()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n[color=#AAAAAA]输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n", false)
return
# 终端模式：所有命令可用
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
if args.size() >= 1 and args[0].to_lower() == "load":
await _cmd_vdisc_load(args.slice(1))
else:
_cmd_story_info()
"unlock":
_cmd_unlock(args)
"scan":
await _cmd_scan()
"reboot", "restart":
await _cmd_reboot()
"eject":
await _cmd_eject()
"load":
append_output("[color=#AAAAAA]磁盘已加载。使用 [/color][color=#66FF66]eject[/color][color=#AAAAAA] 返回桌面后再切换磁盘，或使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 直接切换。[/color]\n", false)
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_desktop_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 桌面命令 ═══════════════[/color]")
lines.append("  [color=#66FF66]load <编号>[/color]   加载指定虚拟磁盘")
lines.append("  [color=#66FF66]scan[/color]   重新扫描vdisc目录")
lines.append("  [color=#66FF66]vdisc[/color] 查看磁盘列表详情")
lines.append("  [color=#66FF66]clear[/color] 清空屏幕")
lines.append("  [color=#66FF66]reboot[/color] 重启终端")
lines.append("  [color=#66FF66]exit[/color]   退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]vdisc[/color]         查看虚拟磁盘列表和信息")
lines.append("  [color=#66FF66]vdisc load <编号>[/color] 切换加载指定磁盘")
lines.append("  [color=#66FF66]scan[/color]          重新扫描虚拟磁盘")
lines.append("  [color=#66FF66]unlock[/color]        进入密码认证（或 unlock <密码>）")
lines.append("  [color=#66FF66]eject[/color]         卸载磁盘，返回桌面")
lines.append("  [color=#66FF66]reboot[/color]        重启终端")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := fs.get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := fs.join_path(current_path, item)
var node := fs.get_node_at_path(item_path)
if node == null:
continue
var item_required: int = fs.get_required_clearance(item_path)
var is_locked: bool = not fs.has_clearance(item_path)
if node.type == "folder":
if is_locked:
lines.append("  [color=#FF6666][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
else:
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
if is_locked:
lines.append("  [color=#FF6666][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
else:
# 检查是否需要文件密码
var fp_key: String = fs.get_file_password_key(item_path)
if not fp_key.is_empty() and not fs.is_file_password_unlocked(item_path):
lines.append("  [color=#FFB000][FILE] " + item + "  [PASSWORD][/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = fs.get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = fs.join_path(current_path, target)
new_path = fs.normalize_path(new_path)
var node := fs.get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
print("[DEBUG] cd 目标: " + new_path + " 需要权限: " + str(fs.get_required_clearance(new_path)) + " 当前权限: " + str(fs.player_clearance))
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
# 权限检查
var required: int = fs.get_required_clearance(new_path)
if not fs.has_clearance(new_path):
var box: String = fs.build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = fs.join_path(current_path, filename)
file_path = fs.normalize_path(file_path)
var node := fs.get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
print("[DEBUG] open 目标: " + file_path + " 需要权限: " + str(fs.get_required_clearance(file_path)) + " 当前权限: " + str(fs.player_clearance))
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
# 权限检查
var required: int = fs.get_required_clearance(file_path)
if not fs.has_clearance(file_path):
var box: String = fs.build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
# 文件密码检查（独立于权限等级）
var fp_key: String = fs.get_file_password_key(file_path)
if not fp_key.is_empty() and not fs.is_file_password_unlocked(file_path):
# 需要文件密码且尚未解锁
var fp_info: Dictionary = fs.story_file_passwords[fp_key]
var hint_text: String = fp_info.get("hint", "")
var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
if not hint_text.is_empty():
box_lines.append(["提示: " + hint_text])
box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
var box: String = fs.build_box_sectioned(box_lines, "#FFB000")
append_output(box + "\n", false)
# 进入文件密码输入模式
_file_password_mode = true
_file_password_target = file_path
_file_password_filename = filename
input_field.placeholder_text = "输入文件密码..."
return
# 先等待打字队列全部完成
while _is_typing:
await get_tree().process_frame
# 显示进度条（直接操作output_text，不走打字队列）
var content_size: int = node.content.length()
await _show_progress_bar(content_size)
# 进度条完成后等待一小会
await get_tree().create_timer(0.5).timeout
# 清屏进入阅读模式
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
# 显示文件头
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
# 记录已读
if not read_files.has(file_path):
read_files.append(file_path)
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
# 显示文件内容（走打字机，不加额外空行）
var clean_content: String = node.content.strip_edges()
clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
append_output(clean_content, false)
# 文件尾放入队列，等内容打完后显示
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = fs.get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名: [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]" + str(fs.player_clearance) + "[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
lines.append("  已解锁文件: [color=#66FF66]" + str(fs.unlocked_file_passwords.size()) + "[/color]")
if not story_id.is_empty():
lines.append("  盘ID: [color=#AAAAAA]" + story_id + "[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty() and available_stories.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")
if available_stories.size() > 0:
lines.append("")
lines.append("  已发现 [color=#66FF66]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
var marker: String = ""
if i == current_story_index:
marker = " [color=#33FF33]<< 当前[/color]"
lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]" + marker)
lines.append("     作者: [color=#AAAAAA]" + info.get("author", "未知") + "[/color]")
lines.append("")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 切换磁盘[/color]")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]scan[/color][color=#AAAAAA] 重新扫描目录[/color]")
# 当前加载的磁盘详细信息
if story_manifest.has("story"):
lines.append("")
lines.append("[color=#66FF66]─────────── 当前磁盘详情 ───────────[/color]")
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签: [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者:   [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本: [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述: [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数: [color=#66FF66]" + str(fs.file_system.size()) + "[/color]")
lines.append("  磁盘来源: [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态: [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_vdisc_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: vdisc load <编号>[/color]\n[color=#AAAAAA]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1  # 用户输入从1开始
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
if index == current_story_index:
append_output("[color=#AAAAAA]该磁盘已经是当前加载的磁盘。[/color]\n", false)
return
# 保存当前剧本存档
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
append_output("[color=#AAAAAA]正在卸载当前磁盘...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.3).timeout
# 重置状态
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
read_files.clear()
unlocked_passwords.clear()
# 显示加载进度条
await _show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
# 加载新剧本
if _load_story_by_index(index):
var title: String = available_stories[index].get("title", "未知")
var box: String = fs.build_box_sectioned([
["DISC LOADED", "磁盘加载完成"],
[title]
], "#33FF33")
append_output(box + "\n", false)
_update_status_bar()
append_output("[color=#AAAAAA]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
append_output("[color=#AAAAAA]当前路径: " + current_path + "  权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
fs.init_test_file_system()
_update_status_bar()
func _cmd_unlock(args: Array) -> void:
# 如果带了参数，直接验证（兼容旧用法）
if not args.is_empty():
_verify_password(args[0])
return
# 无参数，进入密码输入模式
_enter_password_mode()
func _enter_password_mode(target_path: String = "") -> void:
_password_mode = true
_password_target_path = target_path
var box: String = fs.build_box_sectioned([
["SECURITY AUTHENTICATION", "安全认证系统"],
["请输入访问密码:", "(输入 cancel 取消)"]
], "#FFB000")
append_output(box + "\n", false)
# 修改输入框提示
input_field.placeholder_text = "输入密码..."
func _verify_password(password: String) -> void:
# 从manifest中查找密码
if not story_manifest.has("passwords"):
append_output("[color=#FF6666][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
return
var passwords: Dictionary = story_manifest["passwords"]
if passwords.has(password):
var pwd_info: Dictionary = passwords[password]
var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
if unlocked_passwords.has(password):
append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
return
if grant_level <= fs.player_clearance:
append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。当前: " + str(fs.player_clearance) + "[/color]\n", false)
return
# 解锁成功
unlocked_passwords.append(password)
var old_level: int = fs.player_clearance
fs.player_clearance = grant_level
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
# 成功动画
var box: String = fs.build_box_sectioned([
["ACCESS GRANTED", "权限认证通过"],
["权限等级: " + str(old_level) + " -> " + str(fs.player_clearance)]
], "#33FF33")
append_output(box + "\n", false)
# 显示提示信息（如果有）
if pwd_info.has("message"):
append_output("[color=#AAAAAA]" + str(pwd_info["message"]) + "[/color]\n", false)
else:
var box: String = fs.build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _verify_file_password(input_password: String) -> void:
var fp_key: String = fs.get_file_password_key(_file_password_target)
if fp_key.is_empty():
append_output("[color=#FF6666][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
return
var fp_info: Dictionary = fs.story_file_passwords[fp_key]
var correct_password: String = str(fp_info.get("password", ""))
if input_password == correct_password:
# 密码正确
fs.unlocked_file_passwords.append(_file_password_target)
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
var box: String = fs.build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], "#33FF33")
append_output(box + "\n", false)
# 等打字完成后自动打开文件
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 重新执行打开文件
await _cmd_open([_file_password_filename])
else:
var box: String = fs.build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _cmd_scan() -> void:
append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
# 显示扫描进度条
await _show_progress_bar(500)
await get_tree().create_timer(0.3).timeout
# 保存旧状态用于对比
var old_story_path: String = current_story_path
# 重置文件系统和权限
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
read_files.clear()
unlocked_passwords.clear()
available_stories.clear()
current_story_index = -1
# 重新扫描
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
if _desktop_mode:
# 桌面模式：只扫描，不自动加载
if available_stories.is_empty():
append_output("[color=#FFB000][WARN] 未找到虚拟磁盘文件。[/color]", false)
append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
else:
var scan_lines: Array[String] = []
scan_lines.append("[color=#33FF33][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
scan_lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
scan_lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]")
scan_lines.append("")
scan_lines.append("[color=#AAAAAA]输入 [/color][color=#66FF66]load <编号>[/color][color=#AAAAAA] 加载磁盘。[/color]")
append_output("\n".join(scan_lines) + "\n", false)
_update_status_bar()
else:
# 终端模式：重新加载当前磁盘
if available_stories.is_empty():
_desktop_mode = true
fs.init_test_file_system()
current_path = "/"
_update_status_bar()
append_output("[color=#FFB000][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
elif _load_story_by_index(0):
var title: String = "未知"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]", false)
append_output("[color=#AAAAAA]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
else:
current_path = "/"
_update_status_bar()
else:
append_output("[color=#FF6666][ERROR] 重新加载失败。[/color]\n", false)
func _cmd_reboot() -> void:
append_output("[color=#AAAAAA]正在重启终端...[/color]", false)
# 等待打字完成
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
# 清空所有状态
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
command_history.clear()
history_index = -1
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
has_new_mail = false
read_files.clear()
unlocked_passwords.clear()
available_stories.clear()
current_story_index = -1
# 重新加载
save_mgr.ensure_stories_dir()
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# 模拟重启效果
output_text.append_text("[color=#AAAAAA]...[/color]\n")
await get_tree().create_timer(0.3).timeout
output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
await get_tree().create_timer(0.5).timeout
output_text.text = ""
# 回到桌面
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
input_field.grab_focus()
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全（命令和文件名）
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
# 只输入了一个词：补全命令
if parts.size() == 1:
if current_text.ends_with(" "):
# 命令已输入完，补全文件名
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := fs.get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := fs.join_path(current_path, child)
var node := fs.get_node_at_path(child_path)
if node == null:
continue
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
_do_scroll()
else:
# 补全命令名
var partial_cmd: String = parts[0].to_lower()
var commands: Array
if _desktop_mode:
commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
else:
commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
"scan", "reboot", "restart", "unlock", "eject"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
_do_scroll()
# 两个词：命令 + 部分文件名
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := fs.get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := fs.join_path(current_path, child)
var node := fs.get_node_at_path(child_path)
if node == null:
continue
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
_do_scroll()
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具函数
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
_typewriter_queue.append({"text": text, "extra_newline": extra_newline})
if not _is_typing:
_process_typewriter_queue()
func _process_typewriter_queue() -> void:
if _typewriter_queue.is_empty():
_is_typing = false
return
_is_typing = true
var entry = _typewriter_queue.pop_front()
var text: String = entry["text"]
var extra_newline: bool = entry["extra_newline"]
if _typewriter_instant:
output_text.append_text(text)
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
else:
_typewrite_text(text, extra_newline)
func _typewrite_text(text: String, extra_newline: bool = true) -> void:
var i: int = 0
var length: int = text.length()
_current_char_speed = _typewriter_speed
while i < length:
if _typewriter_instant:
output_text.append_text(text.substr(i))
break
if text[i] == "[":
var close_bracket: int = text.find("]", i)
if close_bracket != -1:
var tag: String = text.substr(i, close_bracket - i + 1)
if tag.begins_with("[speed="):
var speed_str: String = tag.substr(7, tag.length() - 8)
_current_char_speed = speed_str.to_float()
i = close_bracket + 1
continue
elif tag == "[/speed]":
_current_char_speed = _typewriter_speed
i = close_bracket + 1
continue
elif tag.begins_with("[pause="):
var pause_str: String = tag.substr(7, tag.length() - 8)
var pause_time: float = pause_str.to_float()
await get_tree().create_timer(pause_time).timeout
i = close_bracket + 1
continue
var tag_inner: String = tag.substr(1, tag.length() - 2)
if tag_inner.length() > 0 and (tag_inner[0] == "/" or tag_inner[0].unicode_at(0) >= 65 and tag_inner[0].unicode_at(0) <= 122):
output_text.append_text(tag)
i = close_bracket + 1
continue
output_text.append_text("[lb]")
i += 1
continue
var ch: String = text[i]
if ch == "\n":
var newlines: String = "\n"
i += 1
while i < length and text[i] == "\n":
newlines += "\n"
i += 1
output_text.append_text(newlines)
if not _typewriter_instant:
await get_tree().create_timer(_typewriter_period_pause).timeout
_do_scroll()
continue
output_text.append_text(ch)
i += 1
var delay: float = _current_char_speed
if ch in ["，", "。", "；", "：", "！", "？", ",", ".", ";", ":", "!", "?"]:
delay += _typewriter_period_pause
elif ch in ["、", "—", "-", "…"]:
delay += _typewriter_comma_pause
else:
if randf() < _typewriter_pause_chance:
delay += _typewriter_pause_duration
await get_tree().create_timer(delay).timeout
if i % 8 == 0:
_do_scroll()
if extra_newline:
output_text.append_text("\n")
_do_scroll()
_process_typewriter_queue()
func _do_scroll() -> void:
_needs_scroll = true
func _process(_delta: float) -> void:
if _needs_scroll:
var v_scroll: VScrollBar = scroll_container.get_v_scroll_bar()
scroll_container.scroll_vertical = int(v_scroll.max_value)
_needs_scroll = false
func _show_progress_bar(file_size: int, speed_override: float = -1.0) -> void:
var bar_width: int = 30
var speed: float = _progress_bar_speed
if speed_override > 0.0:
speed = speed_override
var base_delay: float = clamp(float(file_size) / 5000.0, 0.01, 0.08)
base_delay /= speed
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("[color=#66FF66]加载中 [[/color]")
for i in range(bar_width):
if _typewriter_instant:
var remaining: int = bar_width - i
output_text.append_text("[color=#33FF33]" + "█".repeat(remaining) + "[/color]")
break
output_text.append_text("[color=#33FF33]█[/color]")
_do_scroll()
var jitter: float = randf_range(0.7, 1.5)
await get_tree().create_timer(base_delay * jitter).timeout
output_text.append_text("[color=#66FF66]] 完成[/color]\n")
_do_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
if _desktop_mode:
path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
mail_icon.text = "[Mail]"
return
var disc_name: String = ""
if current_story_index >= 0 and current_story_index < available_stories.size():
disc_name = available_stories[current_story_index].get("title", "")
if disc_name.is_empty():
path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance)
else:
path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance) + "  DISC:" + disc_name
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
var box: String = fs.build_box([title, subtitle] as Array[String], "#66FF66")
output_text.append_text(box + "\n\n")
if available_stories.is_empty():
output_text.append_text("[color=#FFB000]未检测到虚拟磁盘。[/color]\n")
output_text.append_text("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
else:
output_text.append_text("[color=#66FF66]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
output_text.append_text("  [color=#FFB000]" + str(i + 1) + ".[/color] [color=#66FF66]" + info.get("title", "未知") + "[/color]\n")
output_text.append_text("     [color=#AAAAAA]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
output_text.append_text("\n")
output_text.append_text("[color=#AAAAAA]可用命令:[/color]\n")
output_text.append_text("  [color=#66FF66]load <编号>[/color]   加载指定磁盘\n")
output_text.append_text("  [color=#66FF66]scan[/color]   重新扫描磁盘目录\n")
output_text.append_text("  [color=#66FF66]clear[/color] 清空屏幕\n")
output_text.append_text("  [color=#66FF66]exit[/color]   退出终端\n")
func _cmd_desktop_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: load <编号>[/color]", false)
if available_stories.size() > 0:
append_output("[color=#AAAAAA]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
append_output("[color=#AAAAAA]正在加载虚拟磁盘...[/color]", false)
while _is_typing:
await get_tree().process_frame
await _show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
if _load_story_by_index(index):
_desktop_mode = false
var title: String = available_stories[index].get("title", "未知")
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
_update_status_bar()
_show_welcome_message()
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
func _cmd_eject() -> void:
if _desktop_mode:
append_output("[color=#AAAAAA]当前已在桌面模式。[/color]\n", false)
return
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
append_output("[color=#AAAAAA]正在卸载磁盘...[/color]", false)
while _is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
read_files.clear()
unlocked_passwords.clear()
current_story_index = -1
_desktop_mode = true
output_text.text = ""
_typewriter_queue.clear()
_is_typing = false
_typewriter_instant = false
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
var title_display_len: int = fs.display_width(title)
var subtitle_display_len: int = fs.display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# ============================================================
# 背景初始化
# ============================================================
func _setup_background() -> void:
background = TextureRect.new()
background.name = "Background"
add_child(background)
move_child(background, 0)
background.set_anchors_preset(Control.PRESET_FULL_RECT)
background.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
background.mouse_filter = Control.MOUSE_FILTER_IGNORE
var bg_path: String = save_mgr.get_game_root_dir() + "background.png"
var tex: Texture2D = null
if FileAccess.file_exists(bg_path):
var image := Image.new()
var err := image.load(bg_path)
if err == OK:
tex = ImageTexture.create_from_image(image)
print("[UI] 已加载外部背景图: " + bg_path)
else:
print("[UI] 背景图加载失败: " + str(err))
if tex == null:
var image := Image.create(4, 4, false, Image.FORMAT_RGB8)
image.fill(Color(0.02, 0.04, 0.02, 1.0))
tex = ImageTexture.create_from_image(image)
print("[UI] 使用默认深色背景")
background.texture = tex
var shader_path: String = "res://background_vignette.gdshader"
if ResourceLoader.exists(shader_path):
var shader: Shader = load(shader_path)
var mat := ShaderMaterial.new()
mat.shader = shader
mat.set_shader_parameter("vignette_strength", 0.8)
mat.set_shader_parameter("vignette_radius", 0.9)
mat.set_shader_parameter("glow_strength", 0.08)
mat.set_shader_parameter("glow_radius", 0.4)
mat.set_shader_parameter("brightness", 0.7)
mat.set_shader_parameter("tint_color", Color(0.1, 0.3, 0.1, 0.15))
background.material = mat
print("[UI] 背景Shader已应用")
else:
print("[UI] 未找到背景Shader文件: " + shader_path)
# ============================================================
# 剧本加载系统
# ============================================================
func _try_load_story() -> bool:
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
print("[StoryLoader] 搜索目录: " + vdisc_dir)
_scan_available_stories(vdisc_dir)
return not available_stories.is_empty()
func _scan_available_stories(vdisc_dir: String) -> void:
available_stories.clear()
if not DirAccess.dir_exists_absolute(vdisc_dir):
return
var dir := DirAccess.open(vdisc_dir)
if dir == null:
return
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = vdisc_dir + file_name
var info: Dictionary = _peek_story_info(full_path)
info["path"] = full_path
info["filename"] = file_name
available_stories.append(info)
print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
file_name = dir.get_next()
print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")
func _peek_story_info(path: String) -> Dictionary:
var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}
var reader := ZIPReader.new()
if reader.open(path) != OK:
return info
var files := reader.get_files()
for file_path in files:
var filename: String = file_path.get_file()
if filename == "manifest.json":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
var json := JSON.new()
if json.parse(content) == OK and json.data is Dictionary:
var data: Dictionary = json.data
if data.has("story"):
var story_info: Dictionary = data["story"]
info["title"] = story_info.get("title", "未知剧本")
info["id"] = story_info.get("id", "")
info["author"] = story_info.get("author", "未知")
break
elif filename == "manifest.cfg":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
for line in content.split("\n"):
line = line.strip_edges()
if line.begins_with("title="):
info["title"] = line.substr(6).strip_edges()
elif line.begins_with("id="):
info["id"] = line.substr(3).strip_edges()
elif line.begins_with("author="):
info["author"] = line.substr(7).strip_edges()
break
reader.close()
return info
func _load_story_by_index(index: int) -> bool:
if index < 0 or index >= available_stories.size():
return false
var story_info: Dictionary = available_stories[index]
var path: String = story_info["path"]
if _load_story_file(path):
current_story_index = index
return true
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据到 fs 模块
fs.file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 读取盘ID
if story_manifest.has("story") and story_manifest["story"].has("id"):
story_id = story_manifest["story"]["id"]
else:
story_id = str(path.get_file().hash())
# 读取权限表
fs.story_permissions.clear()
if story_manifest.has("permissions"):
var perms: Dictionary = story_manifest["permissions"]
for perm_path in perms.keys():
fs.story_permissions[perm_path] = int(perms[perm_path])
print("[StoryLoader] 权限表已加载，共 " + str(fs.story_permissions.size()) + " 条规则")
else:
print("[StoryLoader] 警告: manifest中未找到permissions字段")
if story_manifest.has("passwords"):
print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
else:
print("[StoryLoader] 警告: manifest中未找到passwords字段")
# 读取文件密码表
fs.story_file_passwords.clear()
if story_manifest.has("file_passwords"):
var fps: Dictionary = story_manifest["file_passwords"]
for fp_path in fps.keys():
fs.story_file_passwords[fp_path] = fps[fp_path]
print("[StoryLoader] 文件密码表已加载，共 " + str(fs.story_file_passwords.size()) + " 条")
else:
print("[StoryLoader] 未配置文件密码表（file_passwords）")
# 应用 manifest 中的设置
var start_clearance: int = 0
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
_typewriter_speed = settings["typing_speed"].to_float()
if settings.has("start_clearance"):
start_clearance = int(settings["start_clearance"])
# 尝试加载该剧本的存档
var save_data = save_mgr.load_save(story_id)
if save_data != null:
fs.player_clearance = int(save_data.get("player_clearance", 0))
read_files.clear()
if save_data.has("read_files"):
for f in save_data["read_files"]:
read_files.append(str(f))
unlocked_passwords.clear()
if save_data.has("unlocked_passwords"):
for p in save_data["unlocked_passwords"]:
unlocked_passwords.append(str(p))
fs.unlocked_file_passwords.clear()
if save_data.has("unlocked_file_passwords"):
for p in save_data["unlocked_file_passwords"]:
fs.unlocked_file_passwords.append(str(p))
if save_data.has("current_path"):
var saved_path: String = save_data["current_path"]
if fs.has_clearance(saved_path):
current_path = saved_path
else:
current_path = "/"
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
print("[Save] 权限等级: " + str(fs.player_clearance))
else:
# 没有存档，用初始权限
fs.player_clearance = start_clearance
read_files.clear()
unlocked_passwords.clear()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 盘ID: " + story_id)
print("[StoryLoader] 文件数量: " + str(fs.file_system.size()))
print("[StoryLoader] 权限等级: " + str(fs.player_clearance))
print("[StoryLoader] story_permissions 内容: " + str(fs.story_permissions))
print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
return true

### ASSISTANT
好的，下面是完整的修改后的 `main.gd`，已将打字机相关逻辑全部委托给 `tw`（Typewriter 模块），删除了所有旧的打字机变量和函数。

由于代码很长，我将分为**上半部分**和**下半部分**两段发送，请依次拼接。

---

## main.gd 上半部分（从开头到 `_cmd_open` 结束）

```gdscript
extends Control

# ============================================================
# 节点引用
# ============================================================
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
var background: TextureRect = null

# 模块实例
var save_mgr: SaveManager = SaveManager.new()
var fs: FileSystem = FileSystem.new()
var tw: Typewriter = null

# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""

# 桌面/终端模式
var _desktop_mode: bool = true

# ============================================================
# 剧本系统
# ============================================================
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []
var current_story_index: int = -1
var story_id: String = ""
var read_files: Array[String] = []
var unlocked_passwords: Array[String] = []

# 密码输入弹窗状态
var _password_mode: bool = false
var _password_target_path: String = ""

# 文件密码系统
var _file_password_mode: bool = false
var _file_password_target: String = ""
var _file_password_filename: String = ""

# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
	# 初始化打字机模块
	tw = Typewriter.new()
	tw.name = "Typewriter"
	add_child(tw)

	save_mgr.ensure_stories_dir()
	save_mgr.ensure_saves_dir()

	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	_setup_background()

	var main_content := $MainContent
	if main_content:
		move_child(main_content, get_child_count() - 1)
		if main_content is Control:
			var transparent_style := StyleBoxFlat.new()
			transparent_style.bg_color = Color(0, 0, 0, 0)
			transparent_style.set_border_width_all(0)
			main_content.add_theme_stylebox_override("panel", transparent_style)

	var status_frame_style := StyleBoxFlat.new()
	status_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
	status_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
	status_frame_style.set_border_width_all(1)
	status_frame_style.content_margin_left = 4
	status_frame_style.content_margin_right = 4
	status_frame_style.content_margin_top = 3
	status_frame_style.content_margin_bottom = 3
	status_frame.add_theme_stylebox_override("panel", status_frame_style)

	var path_label_style := StyleBoxFlat.new()
	path_label_style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
	path_label_style.border_color = Color(0.0, 0.0, 0.0, 0.0)
	path_label_style.set_border_width_all(0)
	path_label_style.content_margin_left = 6
	path_label_style.content_margin_right = 6
	path_label_style.content_margin_top = 2
	path_label_style.content_margin_bottom = 2
	path_label.add_theme_stylebox_override("normal", path_label_style)

	var mail_style := StyleBoxFlat.new()
	mail_style.bg_color = Color(0.0, 0.03, 0.0, 0.6)
	mail_style.border_color = Color(0.2, 0.6, 0.2, 0.35)
	mail_style.set_border_width_all(1)
	mail_style.content_margin_left = 8
	mail_style.content_margin_right = 8
	mail_style.content_margin_top = 2
	mail_style.content_margin_bottom = 2
	mail_icon.add_theme_stylebox_override("normal", mail_style)

	var input_frame_style := StyleBoxFlat.new()
	input_frame_style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
	input_frame_style.border_color = Color(0.2, 0.6, 0.2, 0.4)
	input_frame_style.set_border_width_all(1)
	input_frame_style.content_margin_left = 4
	input_frame_style.content_margin_right = 4
	input_frame_style.content_margin_top = 3
	input_frame_style.content_margin_bottom = 3
	input_frame.add_theme_stylebox_override("panel", input_frame_style)

	var input_no_border := StyleBoxFlat.new()
	input_no_border.bg_color = Color(0.0, 0.0, 0.0, 0.0)
	input_no_border.border_color = Color(0.0, 0.0, 0.0, 0.0)
	input_no_border.set_border_width_all(0)
	input_no_border.content_margin_left = 6
	input_no_border.content_margin_right = 6
	input_no_border.content_margin_top = 2
	input_no_border.content_margin_bottom = 2
	input_field.add_theme_stylebox_override("normal", input_no_border)
	input_field.add_theme_stylebox_override("focus", input_no_border.duplicate())

	output_text.text = ""
	output_text.bbcode_enabled = true
	output_text.selection_enabled = true
	output_text.meta_underlined = true
	output_text.meta_clicked.connect(_on_meta_clicked)

	# 初始化打字机引用
	tw.setup(output_text, scroll_container)

	input_field.focus_mode = Control.FOCUS_ALL
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
	input_field.grab_focus()

	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()

# ============================================================
# 输入处理
# ============================================================
func _input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		match event.button_index:
			MOUSE_BUTTON_WHEEL_UP:
				scroll_container.scroll_vertical -= 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_WHEEL_DOWN:
				scroll_container.scroll_vertical += 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_LEFT:
				input_field.grab_focus()
				return

	if not event is InputEventKey or not event.pressed:
		return

	if not input_field.has_focus():
		input_field.grab_focus()

	if tw.is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
		tw.skip()
		get_viewport().set_input_as_handled()
		return

	match event.keycode:
		KEY_ENTER, KEY_KP_ENTER:
			if tw.is_typing:
				get_viewport().set_input_as_handled()
			else:
				var command_text: String = input_field.text
				input_field.clear()
				_on_command_submitted(command_text)
				get_viewport().set_input_as_handled()
		KEY_UP:
			_history_previous()
			get_viewport().set_input_as_handled()
		KEY_DOWN:
			_history_next()
			get_viewport().set_input_as_handled()
		KEY_PAGEUP:
			scroll_container.scroll_vertical -= 100
			get_viewport().set_input_as_handled()
		KEY_PAGEDOWN:
			scroll_container.scroll_vertical += 100
			get_viewport().set_input_as_handled()
		KEY_TAB:
			_auto_complete()
			get_viewport().set_input_as_handled()

# ============================================================
# 命令提交处理
# ============================================================
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	input_field.clear()

	if raw_input.is_empty():
		return

	if _file_password_mode:
		_file_password_mode = false
		input_field.placeholder_text = "> 输入命令..."
		while tw.is_typing:
			await get_tree().process_frame
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
		if raw_input.to_lower() == "cancel":
			append_output("[color=#AAAAAA]已取消文件密码输入。[/color]\n", false)
			_file_password_target = ""
			_file_password_filename = ""
			return
		await _verify_file_password(raw_input)
		return

	if _password_mode:
		_password_mode = false
		input_field.placeholder_text = "> 输入命令..."
		while tw.is_typing:
			await get_tree().process_frame
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
		if raw_input.to_lower() == "cancel":
			append_output("[color=#AAAAAA]已取消密码输入。[/color]\n", false)
			return
		_verify_password(raw_input)
		return

	command_history.append(raw_input)
	history_index = -1

	while tw.is_typing:
		await get_tree().process_frame

	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text("> " + raw_input + "\n")

	await _execute_command(raw_input)

# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
	tw.instant = false

	var parts := raw_input.split(" ", false)
	if parts.is_empty():
		return

	var command: String = parts[0].to_lower()
	var args := parts.slice(1)

	if _desktop_mode:
		match command:
			"load":
				await _cmd_desktop_load(args)
			"scan":
				await _cmd_scan()
			"clear", "cls":
				_cmd_clear()
			"exit", "quit":
				await _cmd_exit()
			"help", "?":
				_cmd_desktop_help()
			"vdisc", "disc", "disk":
				_cmd_story_info()
			"reboot", "restart":
				await _cmd_reboot()
			_:
				append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n[color=#AAAAAA]输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n", false)
		return

	match command:
		"help", "?":
			_cmd_help()
		"ls", "dir":
			_cmd_ls()
		"cd":
			_cmd_cd(args)
		"open", "cat":
			await _cmd_open(args)
		"back":
			_cmd_back()
		"clear", "cls":
			_cmd_clear()
		"status":
			_cmd_status()
		"mail":
			_cmd_mail(args)
		"exit", "quit":
			await _cmd_exit()
		"whoami":
			_cmd_whoami()
		"vdisc", "disc", "disk":
			if args.size() >= 1 and args[0].to_lower() == "load":
				await _cmd_vdisc_load(args.slice(1))
			else:
				_cmd_story_info()
		"unlock":
			_cmd_unlock(args)
		"scan":
			await _cmd_scan()
		"reboot", "restart":
			await _cmd_reboot()
		"eject":
			await _cmd_eject()
		"load":
			append_output("[color=#AAAAAA]磁盘已加载。使用 [/color][color=#66FF66]eject[/color][color=#AAAAAA] 返回桌面后再切换磁盘，或使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 直接切换。[/color]\n", false)
		_:
			append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)

# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_desktop_help() -> void:
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════════ 桌面命令 ═══════════════[/color]")
	lines.append("  [color=#66FF66]load <编号>[/color]   加载指定虚拟磁盘")
	lines.append("  [color=#66FF66]scan[/color]   重新扫描vdisc目录")
	lines.append("  [color=#66FF66]vdisc[/color] 查看磁盘列表详情")
	lines.append("  [color=#66FF66]clear[/color] 清空屏幕")
	lines.append("  [color=#66FF66]reboot[/color] 重启终端")
	lines.append("  [color=#66FF66]exit[/color]   退出终端")
	lines.append("[color=#66FF66]═══════════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_help() -> void:
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
	lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
	lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
	lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
	lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
	lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
	lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
	lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
	lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
	lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
	lines.append("  [color=#66FF66]vdisc[/color]         查看虚拟磁盘列表和信息")
	lines.append("  [color=#66FF66]vdisc load <编号>[/color] 切换加载指定磁盘")
	lines.append("  [color=#66FF66]scan[/color]          重新扫描虚拟磁盘")
	lines.append("  [color=#66FF66]unlock[/color]        进入密码认证（或 unlock <密码>）")
	lines.append("  [color=#66FF66]eject[/color]         卸载磁盘，返回桌面")
	lines.append("  [color=#66FF66]reboot[/color]        重启终端")
	lines.append("  [color=#66FF66]exit[/color]          退出终端")
	lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
	lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_ls() -> void:
	var items := fs.get_children_at_path(current_path)
	if items.is_empty():
		append_output("[color=#AAAAAA]该目录为空。[/color]")
		return
	var lines: Array[String] = []
	lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
	lines.append("")
	for item in items:
		var item_path := fs.join_path(current_path, item)
		var node := fs.get_node_at_path(item_path)
		if node == null:
			continue
		var item_required: int = fs.get_required_clearance(item_path)
		var is_locked: bool = not fs.has_clearance(item_path)
		if node.type == "folder":
			if is_locked:
				lines.append("  [color=#FF6666][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
			else:
				lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
		else:
			if is_locked:
				lines.append("  [color=#FF6666][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
			else:
				var fp_key: String = fs.get_file_password_key(item_path)
				if not fp_key.is_empty() and not fs.is_file_password_unlocked(item_path):
					lines.append("  [color=#FFB000][FILE] " + item + "  [PASSWORD][/color]")
				else:
					lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
	lines.append("")
	append_output("\n".join(lines) + "\n", false)

func _cmd_cd(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
		return
	var target: String = args[0]
	var new_path: String
	if target == "/":
		new_path = "/"
	elif target == "..":
		new_path = fs.get_parent_path(current_path)
	elif target.begins_with("/"):
		new_path = target
	else:
		new_path = fs.join_path(current_path, target)
	new_path = fs.normalize_path(new_path)
	var node := fs.get_node_at_path(new_path)
	if node == null:
		append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
		return
	if node.type != "folder":
		append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
		return
	var required: int = fs.get_required_clearance(new_path)
	if not fs.has_clearance(new_path):
		var box: String = fs.build_box_sectioned([
			["ACCESS DENIED", "权限不足"],
			["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
			["输入 unlock 尝试密码认证"]
		], "#FF6666")
		append_output(box + "\n", false)
		return
	current_path = new_path
	_update_status_bar()
	append_output("已切换到: " + current_path + "\n", false)

func _cmd_open(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
		return
	var filename: String = args[0]
	var file_path: String
	if filename.begins_with("/"):
		file_path = filename
	else:
		file_path = fs.join_path(current_path, filename)
	file_path = fs.normalize_path(file_path)
	var node := fs.get_node_at_path(file_path)
	if node == null:
		append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
		return
	if node.type != "file":
		append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
		return
	var required: int = fs.get_required_clearance(file_path)
	if not fs.has_clearance(file_path):
		var box: String = fs.build_box_sectioned([
			["ACCESS DENIED", "权限不足"],
			["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
			["输入 unlock 尝试密码认证"]
		], "#FF6666")
		append_output(box + "\n", false)
		return
	var fp_key: String = fs.get_file_password_key(file_path)
	if not fp_key.is_empty() and not fs.is_file_password_unlocked(file_path):
		var fp_info: Dictionary = fs.story_file_passwords[fp_key]
		var hint_text: String = fp_info.get("hint", "")
		var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
		if not hint_text.is_empty():
			box_lines.append(["提示: " + hint_text])
		box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
		var box: String = fs.build_box_sectioned(box_lines, "#FFB000")
		append_output(box + "\n", false)
		_file_password_mode = true
		_file_password_target = file_path
		_file_password_filename = filename
		input_field.placeholder_text = "输入文件密码..."
		return
	while tw.is_typing:
		await get_tree().process_frame
	var content_size: int = node.content.length()
	await tw.show_progress_bar(content_size)
	await get_tree().create_timer(0.5).timeout
	output_text.text = ""
	tw.clear_queue()
	var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
	output_text.append_text(header + "\n\n")
	if not read_files.has(file_path):
		read_files.append(file_path)
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
	var clean_content: String = node.content.strip_edges()
	clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
	append_output(clean_content, false)
	append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
```

---

## main.gd 下半部分（从 `_cmd_back` 到文件结尾）

```gdscript
func _cmd_back() -> void:
	if current_path == "/":
		append_output("[color=#AAAAAA]已经在根目录了。[/color]")
		return
	current_path = fs.get_parent_path(current_path)
	_update_status_bar()
	append_output("已返回: " + current_path + "\n", false)

func _cmd_clear() -> void:
	output_text.text = ""
	tw.clear_queue()

func _cmd_status() -> void:
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
	lines.append("  用户名: [color=#66FF66]未登录[/color]")
	lines.append("  权限等级:   [color=#FFB000]" + str(fs.player_clearance) + "[/color]")
	lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
	lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
	lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
	lines.append("  已解锁文件: [color=#66FF66]" + str(fs.unlocked_file_passwords.size()) + "[/color]")
	if not story_id.is_empty():
		lines.append("  盘ID: [color=#AAAAAA]" + story_id + "[/color]")
	lines.append("[color=#66FF66]════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_mail(args: Array) -> void:
	append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)

func _cmd_exit() -> void:
	append_output("[color=#AAAAAA]正在断开连接...[/color]")
	await get_tree().create_timer(1.0).timeout
	get_tree().quit()

func _cmd_whoami() -> void:
	append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)

func _cmd_story_info() -> void:
	if story_manifest.is_empty() and available_stories.is_empty():
		append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
		return
	var lines: Array[String] = []
	lines.append("[color=#66FF66]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")
	if available_stories.size() > 0:
		lines.append("")
		lines.append("  已发现 [color=#66FF66]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
		lines.append("")
		for i in range(available_stories.size()):
			var info: Dictionary = available_stories[i]
			var marker: String = ""
			if i == current_story_index:
				marker = " [color=#33FF33]<< 当前[/color]"
			lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]" + marker)
			lines.append("     作者: [color=#AAAAAA]" + info.get("author", "未知") + "[/color]")
		lines.append("")
		lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 切换磁盘[/color]")
		lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]scan[/color][color=#AAAAAA] 重新扫描目录[/color]")
	if story_manifest.has("story"):
		lines.append("")
		lines.append("[color=#66FF66]─────────── 当前磁盘详情 ───────────[/color]")
		var info: Dictionary = story_manifest["story"]
		lines.append("  磁盘标签: [color=#66FF66]" + info.get("title", "未知") + "[/color]")
		lines.append("  制作者:   [color=#66FF66]" + info.get("author", "未知") + "[/color]")
		lines.append("  版本: [color=#66FF66]" + info.get("version", "未知") + "[/color]")
		if info.has("description"):
			lines.append("  描述: [color=#AAAAAA]" + info["description"] + "[/color]")
		lines.append("  文件总数: [color=#66FF66]" + str(fs.file_system.size()) + "[/color]")
		lines.append("  磁盘来源: [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
		lines.append("  磁盘状态: [color=#33FF33]已挂载[/color]")
	lines.append("[color=#66FF66]═══════════════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_vdisc_load(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: vdisc load <编号>[/color]\n[color=#AAAAAA]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
		return
	var index_str: String = args[0]
	if not index_str.is_valid_int():
		append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
		return
	var index: int = index_str.to_int() - 1
	if index < 0 or index >= available_stories.size():
		append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return
	if index == current_story_index:
		append_output("[color=#AAAAAA]该磁盘已经是当前加载的磁盘。[/color]\n", false)
		return
	save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
	append_output("[color=#AAAAAA]正在卸载当前磁盘...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.3).timeout
	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	read_files.clear()
	unlocked_passwords.clear()
	await tw.show_progress_bar(800)
	await get_tree().create_timer(0.3).timeout
	if _load_story_by_index(index):
		var title: String = available_stories[index].get("title", "未知")
		var box: String = fs.build_box_sectioned([
			["DISC LOADED", "磁盘加载完成"],
			[title]
		], "#33FF33")
		append_output(box + "\n", false)
		_update_status_bar()
		append_output("[color=#AAAAAA]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
		append_output("[color=#AAAAAA]当前路径: " + current_path + "  权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
	else:
		append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
		fs.init_test_file_system()
		_update_status_bar()

func _cmd_unlock(args: Array) -> void:
	if not args.is_empty():
		_verify_password(args[0])
		return
	_enter_password_mode()

func _enter_password_mode(target_path: String = "") -> void:
	_password_mode = true
	_password_target_path = target_path
	var box: String = fs.build_box_sectioned([
		["SECURITY AUTHENTICATION", "安全认证系统"],
		["请输入访问密码:", "(输入 cancel 取消)"]
	], "#FFB000")
	append_output(box + "\n", false)
	input_field.placeholder_text = "输入密码..."

func _verify_password(password: String) -> void:
	if not story_manifest.has("passwords"):
		append_output("[color=#FF6666][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
		return
	var passwords: Dictionary = story_manifest["passwords"]
	if passwords.has(password):
		var pwd_info: Dictionary = passwords[password]
		var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
		if unlocked_passwords.has(password):
			append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
			return
		if grant_level <= fs.player_clearance:
			append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。当前: " + str(fs.player_clearance) + "[/color]\n", false)
			return
		unlocked_passwords.append(password)
		var old_level: int = fs.player_clearance
		fs.player_clearance = grant_level
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
		var box: String = fs.build_box_sectioned([
			["ACCESS GRANTED", "权限认证通过"],
			["权限等级: " + str(old_level) + " -> " + str(fs.player_clearance)]
		], "#33FF33")
		append_output(box + "\n", false)
		if pwd_info.has("message"):
			append_output("[color=#AAAAAA]" + str(pwd_info["message"]) + "[/color]\n", false)
	else:
		var box: String = fs.build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], "#FF6666")
		append_output(box + "\n", false)

func _verify_file_password(input_password: String) -> void:
	var fp_key: String = fs.get_file_password_key(_file_password_target)
	if fp_key.is_empty():
		append_output("[color=#FF6666][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
		return
	var fp_info: Dictionary = fs.story_file_passwords[fp_key]
	var correct_password: String = str(fp_info.get("password", ""))
	if input_password == correct_password:
		fs.unlocked_file_passwords.append(_file_password_target)
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
		var box: String = fs.build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], "#33FF33")
		append_output(box + "\n", false)
		while tw.is_typing:
			await get_tree().process_frame
		await get_tree().create_timer(0.5).timeout
		await _cmd_open([_file_password_filename])
	else:
		var box: String = fs.build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], "#FF6666")
		append_output(box + "\n", false)

func _cmd_scan() -> void:
	append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await tw.show_progress_bar(500)
	await get_tree().create_timer(0.3).timeout
	var old_story_path: String = current_story_path
	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	read_files.clear()
	unlocked_passwords.clear()
	available_stories.clear()
	current_story_index = -1
	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)
	if _desktop_mode:
		if available_stories.is_empty():
			append_output("[color=#FFB000][WARN] 未找到虚拟磁盘文件。[/color]", false)
			append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
		else:
			var scan_lines: Array[String] = []
			scan_lines.append("[color=#33FF33][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
			scan_lines.append("")
			for i in range(available_stories.size()):
				var info: Dictionary = available_stories[i]
				scan_lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]")
			scan_lines.append("")
			scan_lines.append("[color=#AAAAAA]输入 [/color][color=#66FF66]load <编号>[/color][color=#AAAAAA] 加载磁盘。[/color]")
			append_output("\n".join(scan_lines) + "\n", false)
		_update_status_bar()
	else:
		if available_stories.is_empty():
			_desktop_mode = true
			fs.init_test_file_system()
			current_path = "/"
			_update_status_bar()
			append_output("[color=#FFB000][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
		elif _load_story_by_index(0):
			var title: String = "未知"
			if story_manifest.has("story") and story_manifest["story"].has("title"):
				title = story_manifest["story"]["title"]
			append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]", false)
			append_output("[color=#AAAAAA]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
			if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
				current_path = story_manifest["settings"]["start_path"]
			else:
				current_path = "/"
			_update_status_bar()
		else:
			append_output("[color=#FF6666][ERROR] 重新加载失败。[/color]\n", false)

func _cmd_reboot() -> void:
	append_output("[color=#AAAAAA]正在重启终端...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.5).timeout
	output_text.text = ""
	tw.clear_queue()
	command_history.clear()
	history_index = -1
	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	has_new_mail = false
	read_files.clear()
	unlocked_passwords.clear()
	available_stories.clear()
	current_story_index = -1
	save_mgr.ensure_stories_dir()
	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)
	output_text.append_text("[color=#AAAAAA]...[/color]\n")
	await get_tree().create_timer(0.3).timeout
	output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
	await get_tree().create_timer(0.5).timeout
	output_text.text = ""
	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()
	input_field.grab_focus()

# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
	if command_history.is_empty():
		return
	if history_index == -1:
		current_input_backup = input_field.text
		history_index = command_history.size() - 1
	elif history_index > 0:
		history_index -= 1
	input_field.text = command_history[history_index]
	input_field.caret_column = input_field.text.length()

func _history_next() -> void:
	if command_history.is_empty() or history_index == -1:
		return
	if history_index < command_history.size() - 1:
		history_index += 1
		input_field.text = command_history[history_index]
	else:
		history_index = -1
		input_field.text = current_input_backup
	input_field.caret_column = input_field.text.length()

# ============================================================
# 自动补全
# ============================================================
func _auto_complete() -> void:
	var current_text: String = input_field.text
	if current_text.strip_edges().is_empty():
		return
	var parts := current_text.split(" ", false)
	if parts.size() == 1:
		if current_text.ends_with(" "):
			var cmd: String = parts[0].to_lower()
			if cmd in ["cd", "open", "cat"]:
				var children := fs.get_children_at_path(current_path)
				if children.size() > 0:
					var display: Array[String] = []
					for child in children:
						var child_path := fs.join_path(current_path, child)
						var node := fs.get_node_at_path(child_path)
						if node == null:
							continue
						if cmd == "cd" and node.type == "folder":
							display.append(child + "/")
						elif cmd in ["open", "cat"] and node.type == "file":
							display.append(child)
						elif cmd not in ["cd"]:
							display.append(child)
					if display.size() > 0:
						output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
						tw._do_scroll()
		else:
			var partial_cmd: String = parts[0].to_lower()
			var commands: Array
			if _desktop_mode:
				commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
			else:
				commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
					"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
					"scan", "reboot", "restart", "unlock", "eject"]
			var matches: Array[String] = []
			for cmd in commands:
				if cmd.begins_with(partial_cmd):
					matches.append(cmd)
			if matches.size() == 1:
				input_field.text = matches[0] + " "
				input_field.caret_column = input_field.text.length()
			elif matches.size() > 1:
				output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
				tw._do_scroll()
	elif parts.size() == 2:
		var cmd: String = parts[0].to_lower()
		var partial_name: String = parts[1]
		if cmd in ["cd", "open", "cat"]:
			var children := fs.get_children_at_path(current_path)
			var matches: Array[String] = []
			for child in children:
				if child.to_lower().begins_with(partial_name.to_lower()):
					var child_path := fs.join_path(current_path, child)
					var node := fs.get_node_at_path(child_path)
					if node == null:
						continue
					if cmd == "cd" and node.type == "folder":
						matches.append(child)
					elif cmd in ["open", "cat"] and node.type == "file":
						matches.append(child)
			if matches.size() == 1:
				input_field.text = cmd + " " + matches[0]
				input_field.caret_column = input_field.text.length()
			elif matches.size() > 1:
				var common: String = _find_common_prefix(matches)
				if common.length() > partial_name.length():
					input_field.text = cmd + " " + common
					input_field.caret_column = input_field.text.length()
				output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
				tw._do_scroll()

func _find_common_prefix(strings: Array[String]) -> String:
	if strings.is_empty():
		return ""
	if strings.size() == 1:
		return strings[0]
	var prefix: String = strings[0]
	for i in range(1, strings.size()):
		while not strings[i].to_lower().begins_with(prefix.to_lower()):
			prefix = prefix.substr(0, prefix.length() - 1)
			if prefix.is_empty():
				return ""
	return prefix

# ============================================================
# 输出工具（转发到打字机模块）
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
	tw.append(text, extra_newline)

# ============================================================
# 每帧处理（滚动）
# ============================================================
func _process(_delta: float) -> void:
	tw.process_scroll()

# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
	if _desktop_mode:
		path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
		mail_icon.text = "[Mail]"
		return
	var disc_name: String = ""
	if current_story_index >= 0 and current_story_index < available_stories.size():
		disc_name = available_stories[current_story_index].get("title", "")
	if disc_name.is_empty():
		path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance)
	else:
		path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance) + "  DISC:" + disc_name
	if has_new_mail:
		mail_icon.text = "[Mail NEW]"
	else:
		mail_icon.text = "[Mail]"

# ============================================================
# 超链接处理
# ============================================================
func _on_meta_clicked(meta: Variant) -> void:
	var meta_str: String = str(meta)
	if meta_str.begins_with("cmd://"):
		var cmd: String = meta_str.substr(6)
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + cmd)
		output_text.append_text("\n")
		_execute_command(cmd)
		return
	if meta_str.begins_with("file://"):
		var file_path: String = meta_str.substr(7)
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> open " + file_path)
		output_text.append_text("\n")
		await _cmd_open([file_path])
		return
	print("[Terminal] 未知链接: " + meta_str)

# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
	var title: String = "SCP FOUNDATION TERMINAL v0.1"
	var subtitle: String = "SECURE - CONTAIN - PROTECT"
	var box: String = fs.build_box([title, subtitle] as Array[String], "#66FF66")
	output_text.append_text(box + "\n\n")
	if available_stories.is_empty():
		output_text.append_text("[color=#FFB000]未检测到虚拟磁盘。[/color]\n")
		output_text.append_text("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
	else:
		output_text.append_text("[color=#66FF66]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
		for i in range(available_stories.size()):
			var info: Dictionary = available_stories[i]
			output_text.append_text("  [color=#FFB000]" + str(i + 1) + ".[/color] [color=#66FF66]" + info.get("title", "未知") + "[/color]\n")
			output_text.append_text("     [color=#AAAAAA]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
		output_text.append_text("\n")
	output_text.append_text("[color=#AAAAAA]可用命令:[/color]\n")
	output_text.append_text("  [color=#66FF66]load <编号>[/color]   加载指定磁盘\n")
	output_text.append_text("  [color=#66FF66]scan[/color]   重新扫描磁盘目录\n")
	output_text.append_text("  [color=#66FF66]clear[/color] 清空屏幕\n")
	output_text.append_text("  [color=#66FF66]exit[/color]   退出终端\n")

func _cmd_desktop_load(args: Array) -> void:
	if args.is_empty():
		append_output("[color=#FF6666][ERROR] 用法: load <编号>[/color]", false)
		if available_stories.size() > 0:
			append_output("[color=#AAAAAA]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return
	var index_str: String = args[0]
	if not index_str.is_valid_int():
		append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
		return
	var index: int = index_str.to_int() - 1
	if index < 0 or index >= available_stories.size():
		append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return
	append_output("[color=#AAAAAA]正在加载虚拟磁盘...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await tw.show_progress_bar(800)
	await get_tree().create_timer(0.3).timeout
	if _load_story_by_index(index):
		_desktop_mode = false
		var title: String = available_stories[index].get("title", "未知")
		output_text.text = ""
		tw.clear_queue()
		_update_status_bar()
		_show_welcome_message()
	else:
		append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)

func _cmd_eject() -> void:
	if _desktop_mode:
		append_output("[color=#AAAAAA]当前已在桌面模式。[/color]\n", false)
		return
	save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
	append_output("[color=#AAAAAA]正在卸载磁盘...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.5).timeout
	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	read_files.clear()
	unlocked_passwords.clear()
	current_story_index = -1
	_desktop_mode = true
	output_text.text = ""
	tw.clear_queue()
	_update_status_bar()
	_show_desktop_welcome()

# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
	var title: String = "SCP FOUNDATION TERMINAL v0.1"
	var subtitle: String = "SECURE - CONTAIN - PROTECT"
	if story_manifest.has("story"):
		var story_info: Dictionary = story_manifest["story"]
		if story_info.has("title"):
			subtitle = story_info["title"]
	var title_display_len: int = fs.display_width(title)
	var subtitle_display_len: int = fs.display_width(subtitle)
	var inner_width: int = max(title_display_len, subtitle_display_len) + 6
	var title_pad_total: int = inner_width - title_display_len
	var title_pad_left: int = title_pad_total / 2
	var title_pad_right: int = title_pad_total - title_pad_left
	var subtitle_pad_total: int = inner_width - subtitle_display_len
	var subtitle_pad_left: int = subtitle_pad_total / 2
	var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
	var border_h: String = "═".repeat(inner_width)
	var welcome: String = ""
	welcome += "[color=#66FF66]╔" + border_h + "╗\n"
	welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
	welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
	welcome += "╚" + border_h + "╝[/color]\n"
	welcome += "\n"
	welcome += "[color=#AAAAAA]终端系统已启动。\n"
	welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
	output_text.append_text(welcome)

# ============================================================
# 背景初始化
# ============================================================
func _setup_background() -> void:
	background = TextureRect.new()
	background.name = "Background"
	add_child(background)
	move_child(background, 0)
	background.set_anchors_preset(Control.PRESET_FULL_RECT)
	background.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
	background.mouse_filter = Control.MOUSE_FILTER_IGNORE
	var bg_path: String = save_mgr.get_game_root_dir() + "background.png"
	var tex: Texture2D = null
	if FileAccess.file_exists(bg_path):
		var image := Image.new()
		var err := image.load(bg_path)
		if err == OK:
			tex = ImageTexture.create_from_image(image)
			print("[UI] 已加载外部背景图: " + bg_path)
		else:
			print("[UI] 背景图加载失败: " + str(err))
	if tex == null:
		var image := Image.create(4, 4, false, Image.FORMAT_RGB8)
		image.fill(Color(0.02, 0.04, 0.02, 1.0))
		tex = ImageTexture.create_from_image(image)
		print("[UI] 使用默认深色背景")
	background.texture = tex
	var shader_path: String = "res://background_vignette.gdshader"
	if ResourceLoader.exists(shader_path):
		var shader: Shader = load(shader_path)
		var mat := ShaderMaterial.new()
		mat.shader = shader
		mat.set_shader_parameter("vignette_strength", 0.8)
		mat.set_shader_parameter("vignette_radius", 0.9)
		mat.set_shader_parameter("glow_strength", 0.08)
		mat.set_shader_parameter("glow_radius", 0.4)
		mat.set_shader_parameter("brightness", 0.7)
		mat.set_shader_parameter("tint_color", Color(0.1, 0.3, 0.1, 0.15))
		background.material = mat
		print("[UI] 背景Shader已应用")
	else:
		print("[UI] 未找到背景Shader文件: " + shader_path)

# ============================================================
# 剧本加载系统
# ============================================================
func _try_load_story() -> bool:
	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	print("[StoryLoader] 搜索目录: " + vdisc_dir)
	_scan_available_stories(vdisc_dir)
	return not available_stories.is_empty()

func _scan_available_stories(vdisc_dir: String) -> void:
	available_stories.clear()
	if not DirAccess.dir_exists_absolute(vdisc_dir):
		return
	var dir := DirAccess.open(vdisc_dir)
	if dir == null:
		return
	dir.list_dir_begin()
	var file_name := dir.get_next()
	while file_name != "":
		if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
			var full_path: String = vdisc_dir + file_name
			var info: Dictionary = _peek_story_info(full_path)
			info["path"] = full_path
			info["filename"] = file_name
			available_stories.append(info)
			print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
		file_name = dir.get_next()
	print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")

func _peek_story_info(path: String) -> Dictionary:
	var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未

### USER
继续完成代码

### ASSISTANT
根据上下文，我来继续完成 `_peek_story_info` 函数以及 `main.gd` 文件剩余的代码部分：

```gdscript
func _peek_story_info(path: String) -> Dictionary:
	var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}
	var reader := ZIPReader.new()
	if reader.open(path) != OK:
		return info
	var files := reader.get_files()
	for file_path in files:
		var filename: String = file_path.get_file()
		if filename == "manifest.json":
			var content_bytes := reader.read_file(file_path)
			if content_bytes != null:
				var content: String = content_bytes.get_string_from_utf8()
				var json := JSON.new()
				if json.parse(content) == OK and json.data is Dictionary:
					var data: Dictionary = json.data
					if data.has("story"):
						var story_info: Dictionary = data["story"]
						info["title"] = story_info.get("title", "未知剧本")
						info["id"] = story_info.get("id", "")
						info["author"] = story_info.get("author", "未知")
			break
		elif filename == "manifest.cfg":
			var content_bytes := reader.read_file(file_path)
			if content_bytes != null:
				var content: String = content_bytes.get_string_from_utf8()
				for line in content.split("\n"):
					line = line.strip_edges()
					if line.begins_with("title="):
						info["title"] = line.substr(6).strip_edges()
					elif line.begins_with("id="):
						info["id"] = line.substr(3).strip_edges()
					elif line.begins_with("author="):
						info["author"] = line.substr(7).strip_edges()
			break
	reader.close()
	return info

func _load_story_by_index(index: int) -> bool:
	if index < 0 or index >= available_stories.size():
		return false
	var story_info: Dictionary = available_stories[index]
	var path: String = story_info["path"]
	if _load_story_file(path):
		current_story_index = index
		return true
	return false

func _load_story_file(path: String) -> bool:
	story_loader = StoryLoader.new()
	if not story_loader.load_story(path):
		print("[StoryLoader] 加载失败: " + story_loader.error_message)
		return false

	# 应用加载的数据到 fs 模块
	fs.file_system = story_loader.file_system
	story_manifest = story_loader.manifest
	current_story_path = path

	# 读取盘ID
	if story_manifest.has("story") and story_manifest["story"].has("id"):
		story_id = story_manifest["story"]["id"]
	else:
		story_id = str(path.get_file().hash())

	# 读取权限表
	fs.story_permissions.clear()
	if story_manifest.has("permissions"):
		var perms: Dictionary = story_manifest["permissions"]
		for perm_path in perms.keys():
			fs.story_permissions[perm_path] = int(perms[perm_path])
		print("[StoryLoader] 权限表已加载，共 " + str(fs.story_permissions.size()) + " 条规则")
	else:
		print("[StoryLoader] 警告: manifest中未找到permissions字段")

	if story_manifest.has("passwords"):
		print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
	else:
		print("[StoryLoader] 警告: manifest中未找到passwords字段")

	# 读取文件密码表
	fs.story_file_passwords.clear()
	if story_manifest.has("file_passwords"):
		var fps: Dictionary = story_manifest["file_passwords"]
		for fp_path in fps.keys():
			fs.story_file_passwords[fp_path] = fps[fp_path]
		print("[StoryLoader] 文件密码表已加载，共 " + str(fs.story_file_passwords.size()) + " 条")
	else:
		print("[StoryLoader] 未配置文件密码表（file_passwords）")

	# 应用 manifest 中的设置
	var start_clearance: int = 0
	if story_manifest.has("settings"):
		var settings: Dictionary = story_manifest["settings"]
		if settings.has("start_path"):
			current_path = settings["start_path"]
		if settings.has("typing_speed"):
			tw.base_speed = settings["typing_speed"].to_float()
		if settings.has("start_clearance"):
			start_clearance = int(settings["start_clearance"])

	# 尝试加载该剧本的存档
	var save_data = save_mgr.load_save(story_id)
	if save_data != null:
		fs.player_clearance = int(save_data.get("player_clearance", 0))

		read_files.clear()
		if save_data.has("read_files"):
			for f in save_data["read_files"]:
				read_files.append(str(f))

		unlocked_passwords.clear()
		if save_data.has("unlocked_passwords"):
			for p in save_data["unlocked_passwords"]:
				unlocked_passwords.append(str(p))

		fs.unlocked_file_passwords.clear()
		if save_data.has("unlocked_file_passwords"):
			for p in save_data["unlocked_file_passwords"]:
				fs.unlocked_file_passwords.append(str(p))

		if save_data.has("current_path"):
			var saved_path: String = save_data["current_path"]
			if fs.has_clearance(saved_path):
				current_path = saved_path
			else:
				current_path = "/"
				if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
					current_path = story_manifest["settings"]["start_path"]
		print("[Save] 权限等级: " + str(fs.player_clearance))
	else:
		# 没有存档，用初始权限
		fs.player_clearance = start_clearance
		read_files.clear()
		unlocked_passwords.clear()

	var title: String = "未知剧本"
	if story_manifest.has("story") and story_manifest["story"].has("title"):
		title = story_manifest["story"]["title"]

	print("[StoryLoader] 成功加载: " + title)
	print("[StoryLoader] 盘ID: " + story_id)
	print("[StoryLoader] 文件数量: " + str(fs.file_system.size()))
	print("[StoryLoader] 权限等级: " + str(fs.player_clearance))
	print("[StoryLoader] story_permissions 内容: " + str(fs.story_permissions))
	print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))

	return true
```

这段代码完成了以下关键功能：

1. **`_peek_story_info`**：从 ZIP/SCP 包中快速读取剧本基本信息（标题、ID、作者），支持 `manifest.json` 和 `manifest.cfg` 两种格式 [2]
2. **`_load_story_by_index`**：根据索引加载指定剧本
3. **`_load_story_file`**：完整的剧本加载流程，包括：
   - 文件系统数据加载
   - 权限表、密码表、文件密码表解析
   - 打字速度设置（`tw.base_speed`）[1]
   - 存档恢复（权限等级、已读文件、已解锁密码等）
   - 路径权限校验后的安全回退

注意 `typing_speed` 的设置已从旧的 `_typewriter_speed` 改为 `tw.base_speed`，与打字机模块拆分后的接口保持一致。

### USER
总结一下还有哪些没有拆分，继续下一步拆分

### ASSISTANT
# 当前拆分进度总结

根据之前的对话和代码上下文，目前已完成的拆分：

| 模块 | 文件 | 状态 |
|------|------|------|
| 存档管理 | `scripts/save_manager.gd` | ✅ 已拆分 |
| 文件系统 | `scripts/file_system.gd` | ✅ 已拆分 |
| 打字机引擎 | `scripts/typewriter.gd` | ✅ 已拆分 |
| 剧本加载 | `scripts/story_loader.gd` | ✅ 已有（原有模块） |

---

## 仍留在 main.gd 中未拆分的部分

### 1. **UI 初始化与背景系统**
- `_setup_background()` — 背景图加载、Shader 设置
- `_ready()` 中大量的 StyleBox 样式代码（状态栏、输入框、路径标签等）

### 2. **命令系统（核心，最大块）**
- `_execute_command()` — 命令分发路由
- 20+ 个 `_cmd_xxx()` 函数：`_cmd_help`、`_cmd_ls`、`_cmd_cd`、`_cmd_open`、`_cmd_back`、`_cmd_clear`、`_cmd_status`、`_cmd_mail`、`_cmd_exit`、`_cmd_whoami`、`_cmd_story_info`、`_cmd_vdisc_load`、`_cmd_unlock`、`_cmd_scan`、`_cmd_reboot`、`_cmd_desktop_load`、`_cmd_desktop_help`、`_cmd_eject` 等
- 密码验证：`_verify_password()`、`_verify_file_password()`、`_enter_password_mode()`

### 3. **输入处理与自动补全**
- `_input()` — 键盘事件处理
- `_on_command_submitted()` — 命令提交
- `_auto_complete()` — Tab 自动补全
- `_history_previous()` / `_history_next()` — 命令历史导航
- `_find_common_prefix()` — 补全辅助

### 4. **桌面/欢迎界面**
- `_show_desktop_welcome()`
- `_show_welcome_message()`

### 5. **超链接处理**
- `_on_meta_clicked()`

### 6. **剧本扫描与加载（主控端）**
- `_scan_available_stories()`、`_peek_story_info()`、`_load_story_by_index()`、`_load_story_file()`

---

## 建议的下一步拆分：Step 4 — `ui_manager.gd`

将 UI 初始化和背景系统拆出，这是最独立且改动风险最小的一块。

### 新建 `scripts/ui_manager.gd` 完整代码

```gdscript
# ============================================================
# ui_manager.gd - UI 初始化与背景管理
# 负责：背景图加载、Shader应用、各UI组件样式初始化
# ============================================================
class_name UIManager
extends RefCounted

# ============================================================
# 背景初始化
# ============================================================
static func setup_background(parent: Control, game_root_dir: String) -> TextureRect:
	var background := TextureRect.new()
	background.name = "Background"
	parent.add_child(background)
	parent.move_child(background, 0)

	background.set_anchors_preset(Control.PRESET_FULL_RECT)
	background.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
	background.mouse_filter = Control.MOUSE_FILTER_IGNORE

	var bg_path: String = game_root_dir + "background.png"
	var tex: Texture2D = null

	if FileAccess.file_exists(bg_path):
		var image := Image.new()
		var err := image.load(bg_path)
		if err == OK:
			tex = ImageTexture.create_from_image(image)
			print("[UI] 已加载外部背景图: " + bg_path)
		else:
			print("[UI] 背景图加载失败: " + str(err))

	if tex == null:
		var image := Image.create(4, 4, false, Image.FORMAT_RGB8)
		image.fill(Color(0.02, 0.04, 0.02, 1.0))
		tex = ImageTexture.create_from_image(image)
		print("[UI] 使用默认深色背景")

	background.texture = tex

	var shader_path: String = "res://background_vignette.gdshader"
	if ResourceLoader.exists(shader_path):
		var shader: Shader = load(shader_path)
		var mat := ShaderMaterial.new()
		mat.shader = shader
		mat.set_shader_parameter("vignette_strength", 0.8)
		mat.set_shader_parameter("vignette_radius", 0.9)
		mat.set_shader_parameter("glow_strength", 0.08)
		mat.set_shader_parameter("glow_radius", 0.4)
		mat.set_shader_parameter("brightness", 0.7)
		mat.set_shader_parameter("tint_color", Color(0.1, 0.3, 0.1, 0.15))
		background.material = mat
		print("[UI] 背景Shader已应用")
	else:
		print("[UI] 未找到背景Shader文件: " + shader_path)

	return background

# ============================================================
# 主内容区透明化（让背景图透出来）
# ============================================================
static func setup_main_content(parent: Control, main_content: Control) -> void:
	if main_content == null:
		return
	parent.move_child(main_content, parent.get_child_count() - 1)
	if main_content is Control:
		var transparent_style := StyleBoxFlat.new()
		transparent_style.bg_color = Color(0, 0, 0, 0)
		transparent_style.set_border_width_all(0)
		main_content.add_theme_stylebox_override("panel", transparent_style)

# ============================================================
# 状态栏样式
# ============================================================
static func setup_status_frame(status_frame: PanelContainer) -> void:
	var style := StyleBoxFlat.new()
	style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
	style.border_color = Color(0.2, 0.6, 0.2, 0.4)
	style.set_border_width_all(1)
	style.content_margin_left = 4
	style.content_margin_right = 4
	style.content_margin_top = 3
	style.content_margin_bottom = 3
	status_frame.add_theme_stylebox_override("panel", style)

# ============================================================
# 路径标签样式（透明无边框）
# ============================================================
static func setup_path_label(path_label: Label) -> void:
	var style := StyleBoxFlat.new()
	style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
	style.border_color = Color(0.0, 0.0, 0.0, 0.0)
	style.set_border_width_all(0)
	style.content_margin_left = 6
	style.content_margin_right = 6
	style.content_margin_top = 2
	style.content_margin_bottom = 2
	path_label.add_theme_stylebox_override("normal", style)

# ============================================================
# 邮件图标样式
# ============================================================
static func setup_mail_icon(mail_icon: Label) -> void:
	var style := StyleBoxFlat.new()
	style.bg_color = Color(0.0, 0.03, 0.0, 0.6)
	style.border_color = Color(0.2, 0.6, 0.2, 0.35)
	style.set_border_width_all(1)
	style.content_margin_left = 8
	style.content_margin_right = 8
	style.content_margin_top = 2
	style.content_margin_bottom = 2
	mail_icon.add_theme_stylebox_override("normal", style)

# ============================================================
# 输入区外框样式
# ============================================================
static func setup_input_frame(input_frame: PanelContainer) -> void:
	var style := StyleBoxFlat.new()
	style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
	style.border_color = Color(0.2, 0.6, 0.2, 0.4)
	style.set_border_width_all(1)
	style.content_margin_left = 4
	style.content_margin_right = 4
	style.content_margin_top = 3
	style.content_margin_bottom = 3
	input_frame.add_theme_stylebox_override("panel", style)

# ============================================================
# 输入框样式（透明无边框，靠外层 InputFrame 提供边框）
# ============================================================
static func setup_input_field(input_field: LineEdit) -> void:
	var style := StyleBoxFlat.new()
	style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
	style.border_color = Color(0.0, 0.0, 0.0, 0.0)
	style.set_border_width_all(0)
	style.content_margin_left = 6
	style.content_margin_right = 6
	style.content_margin_top = 2
	style.content_margin_bottom = 2
	input_field.add_theme_stylebox_override("normal", style)
	input_field.add_theme_stylebox_override("focus", style.duplicate())

# ============================================================
# 输出文本框初始化
# ============================================================
static func setup_output_text(output_text: RichTextLabel) -> void:
	output_text.text = ""
	output_text.bbcode_enabled = true
	output_text.selection_enabled = true
	output_text.meta_underlined = true

# ============================================================
# 一次性初始化所有 UI 样式
# ============================================================
static func setup_all_styles(
	status_frame: PanelContainer,
	path_label: Label,
	mail_icon: Label,
	input_frame: PanelContainer,
	input_field: LineEdit,
	output_text: RichTextLabel
) -> void:
	setup_status_frame(status_frame)
	setup_path_label(path_label)
	setup_mail_icon(mail_icon)
	setup_input_frame(input_frame)
	setup_input_field(input_field)
	setup_output_text(output_text)
```

---

## main.gd 中对应的修改

### 1. 删除整个 `_setup_background()` 函数

### 2. 删除 `background` 变量声明行中的注释可保留，但改为由 UIManager 返回：

```gdscript
var background: TextureRect = null  # 由 UIManager 创建
```

### 3. 修改 `_ready()` 函数

将原来 `_ready()` 中的大段样式代码替换为：

```gdscript
func _ready() -> void:
	# 初始化打字机模块
	tw = Typewriter.new()
	tw.name = "Typewriter"
	add_child(tw)

	save_mgr.ensure_stories_dir()
	save_mgr.ensure_saves_dir()

	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	# === UI 初始化（全部委托给 UIManager） ===
	background = UIManager.setup_background(self, save_mgr.get_game_root_dir())
	UIManager.setup_main_content(self, $MainContent)
	UIManager.setup_all_styles(status_frame, path_label, mail_icon, input_frame, input_field, output_text)

	# 连接超链接信号
	output_text.meta_clicked.connect(_on_meta_clicked)

	# 初始化打字机引用
	tw.setup(output_text, scroll_container)

	# 输入框设置
	input_field.focus_mode = Control.FOCUS_ALL
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
	input_field.grab_focus()

	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()
```

这样 `_ready()` 从原来约 **80 行**缩减到约 **25 行**，所有 StyleBox 细节都封装进了 `UIManager`。

---

## 验证清单

1. **启动** → 背景图/Shader 正常显示
2. **状态栏** → 绿色边框、透明路径标签、邮件图标样式正确
3. **输入框** → 透明内框、外框绿色边框
4. **输出区** → BBCode 启用、可选中文本
5. **load 磁盘** → 所有功能不受影响

完成验证后告诉我，继续 Step 5（命令系统拆分 `command_handler.gd`，这是最大的一块）。

### USER
验证完成了，但是**输出区** → BBCode 启用、可选中文本这个功能是什么样的，我该如何验证？

### ASSISTANT
## BBCode 启用与可选中文本的验证方法

这两个功能对应的是 `UIManager.setup_output_text()` 中设置的两个属性：

### 1. BBCode 启用 (`bbcode_enabled = true`)

**表现**：输出区的文字能正确渲染颜色、加粗等富文本效果。

**验证方法**：
- 启动终端后，看桌面欢迎界面是否有**绿色文字**（如 `SCP FOUNDATION TERMINAL`）、**橙色编号**（如磁盘列表的 `1.`）、**灰色提示文字**等
- 如果 BBCode **没有**启用，你会看到类似 `[color=#66FF66]SCP FOUNDATION TERMINAL[/color]` 这样的**原始标签文字**直接显示在屏幕上 [1]
- **正常情况**：只看到带颜色的文字，看不到任何 `[color=...]` 标签 → ✅ 通过

### 2. 可选中文本 (`selection_enabled = true`)

**表现**：可以用鼠标在输出区拖选文字进行复制。

**验证方法**：
1. 在终端中执行 `help` 或 `ls` 命令，让输出区有一些文字
2. 用鼠标在输出区的文字上**按住左键拖动**
3. 如果能看到文字被**高亮选中**（类似在网页上选中文字的效果），说明可选中功能正常
4. 选中后按 `Ctrl+C` 能复制到剪贴板 → ✅ 通过

### 快速判断

| 检查项 | 正常 | 异常 |
|--------|------|------|
| BBCode | 看到彩色文字 | 看到 `[color=#66FF66]` 等原始标签 |
| 可选中 | 鼠标拖动能高亮选中文字 | 鼠标拖动无任何反应 |

如果你之前启动终端时已经能看到**彩色的欢迎界面**，并且能用鼠标选中输出区的文字，那这两项就已经验证通过了，可以继续下一步拆分。

### USER
没有高亮被选中的效果，你检查一下是什么问题。

### ASSISTANT
## 分析文本无法选中的问题

问题出在 `RichTextLabel` 的文本选中功能上。虽然我们在 `UIManager.setup_output_text()` 中设置了 `selection_enabled = true`，但有几个可能的原因导致无法选中：

### 可能原因

**1. `_input()` 中鼠标左键点击被拦截了**

在 `main.gd` 的 `_input()` 函数中 [1]，鼠标左键点击事件被拦截用于聚焦输入框：

```gdscript
MOUSE_BUTTON_LEFT:
    input_field.grab_focus()
    return
```

这个 `return` 导致鼠标左键事件在到达 `RichTextLabel` 之前就被消费掉了，所以无法拖选文字。

**2. `mouse_filter` 可能阻挡了事件传递**

`ScrollContainer` 或其他父节点可能把鼠标事件吞掉了。

### 修复方案

修改 `main.gd` 中 `_input()` 的鼠标左键处理部分，**不要直接 return**，让事件能继续传递到 `RichTextLabel`：

```gdscript
func _input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		match event.button_index:
			MOUSE_BUTTON_WHEEL_UP:
				scroll_container.scroll_vertical -= 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_WHEEL_DOWN:
				scroll_container.scroll_vertical += 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_LEFT:
				# 只在点击非输出区时才抢焦点，不拦截事件
				# 让 RichTextLabel 能接收拖选操作
				input_field.grab_focus()
				# 注意：这里不 return，也不 set_input_as_handled
				# 让事件继续传递给 RichTextLabel 处理选中
```

关键改动：**删除 `MOUSE_BUTTON_LEFT` 分支中的 `return`**，让事件继续向下传递。

如果改完后仍然无法选中，还需要检查 `output_text` 节点的 `mouse_filter` 属性，确保不是 `MOUSE_FILTER_IGNORE`。可以在 `UIManager.setup_output_text()` 中补充：

```gdscript
static func setup_output_text(output_text: RichTextLabel) -> void:
	output_text.text = ""
	output_text.bbcode_enabled = true
	output_text.selection_enabled = true
	output_text.meta_underlined = true
	output_text.mouse_filter = Control.MOUSE_FILTER_PASS  # 确保能接收鼠标事件
```

两处都改完后重新测试，应该就能用鼠标拖选高亮文字了。

### USER
output_text 节点中mouse filter为stop，按你说的改完后仍然无法选中，我给你目前所有的main.gd代码，你将需要修改的部分发回给我。注意不要全部发回，不然会导致对话卡死。
extends Control
# ============================================================
# 节点引用
# ============================================================
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
var background: TextureRect = null  # 由 UIManager 创建
# 模块实例
var save_mgr: SaveManager = SaveManager.new()
var fs: FileSystem = FileSystem.new()
var tw: Typewriter = null
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
# 桌面/终端模式
var _desktop_mode: bool = true
# ============================================================
# 剧本系统
# ============================================================
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []
var current_story_index: int = -1
var story_id: String = ""
var read_files: Array[String] = []
var unlocked_passwords: Array[String] = []
# 密码输入弹窗状态
var _password_mode: bool = false
var _password_target_path: String = ""
# 文件密码系统
var _file_password_mode: bool = false
var _file_password_target: String = ""
var _file_password_filename: String = ""
# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
# 初始化打字机模块
tw = Typewriter.new()
tw.name = "Typewriter"
add_child(tw)
save_mgr.ensure_stories_dir()
save_mgr.ensure_saves_dir()
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# === UI 初始化（全部委托给 UIManager） ===
background = UIManager.setup_background(self, save_mgr.get_game_root_dir())
UIManager.setup_main_content(self, $MainContent)
UIManager.setup_all_styles(status_frame, path_label, mail_icon, input_frame, input_field, output_text)
# 连接超链接信号
output_text.meta_clicked.connect(_on_meta_clicked)
# 初始化打字机引用
tw.setup(output_text, scroll_container)
# 输入框设置
input_field.focus_mode = Control.FOCUS_ALL
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
input_field.grab_focus()
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 输入处理
# ============================================================
func _input(event: InputEvent) -> void:
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 只在点击非输出区时才抢焦点，不拦截事件,让 RichTextLabel 能接收拖选操作
input_field.grab_focus()
# 注意：这里不 return，也不 set_input_as_handled，让事件继续传递给 RichTextLabel 处理选中
if not event is InputEventKey or not event.pressed:
return
if not input_field.has_focus():
input_field.grab_focus()
if tw.is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
tw.skip()
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
if tw.is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
if _file_password_mode:
_file_password_mode = false
input_field.placeholder_text = "> 输入命令..."
while tw.is_typing:
await get_tree().process_frame
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消文件密码输入。[/color]\n", false)
_file_password_target = ""
_file_password_filename = ""
return
await _verify_file_password(raw_input)
return
if _password_mode:
_password_mode = false
input_field.placeholder_text = "> 输入命令..."
while tw.is_typing:
await get_tree().process_frame
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消密码输入。[/color]\n", false)
return
_verify_password(raw_input)
return
command_history.append(raw_input)
history_index = -1
while tw.is_typing:
await get_tree().process_frame
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
tw.instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
if _desktop_mode:
match command:
"load":
await _cmd_desktop_load(args)
"scan":
await _cmd_scan()
"clear", "cls":
_cmd_clear()
"exit", "quit":
await _cmd_exit()
"help", "?":
_cmd_desktop_help()
"vdisc", "disc", "disk":
_cmd_story_info()
"reboot", "restart":
await _cmd_reboot()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n[color=#AAAAAA]输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n", false)
return
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
if args.size() >= 1 and args[0].to_lower() == "load":
await _cmd_vdisc_load(args.slice(1))
else:
_cmd_story_info()
"unlock":
_cmd_unlock(args)
"scan":
await _cmd_scan()
"reboot", "restart":
await _cmd_reboot()
"eject":
await _cmd_eject()
"load":
append_output("[color=#AAAAAA]磁盘已加载。使用 [/color][color=#66FF66]eject[/color][color=#AAAAAA] 返回桌面后再切换磁盘，或使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 直接切换。[/color]\n", false)
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_desktop_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 桌面命令 ═══════════════[/color]")
lines.append("  [color=#66FF66]load <编号>[/color]   加载指定虚拟磁盘")
lines.append("  [color=#66FF66]scan[/color]   重新扫描vdisc目录")
lines.append("  [color=#66FF66]vdisc[/color] 查看磁盘列表详情")
lines.append("  [color=#66FF66]clear[/color] 清空屏幕")
lines.append("  [color=#66FF66]reboot[/color] 重启终端")
lines.append("  [color=#66FF66]exit[/color]   退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]vdisc[/color]         查看虚拟磁盘列表和信息")
lines.append("  [color=#66FF66]vdisc load <编号>[/color] 切换加载指定磁盘")
lines.append("  [color=#66FF66]scan[/color]          重新扫描虚拟磁盘")
lines.append("  [color=#66FF66]unlock[/color]        进入密码认证（或 unlock <密码>）")
lines.append("  [color=#66FF66]eject[/color]         卸载磁盘，返回桌面")
lines.append("  [color=#66FF66]reboot[/color]        重启终端")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := fs.get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := fs.join_path(current_path, item)
var node := fs.get_node_at_path(item_path)
if node == null:
continue
var item_required: int = fs.get_required_clearance(item_path)
var is_locked: bool = not fs.has_clearance(item_path)
if node.type == "folder":
if is_locked:
lines.append("  [color=#FF6666][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
else:
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
if is_locked:
lines.append("  [color=#FF6666][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
else:
var fp_key: String = fs.get_file_password_key(item_path)
if not fp_key.is_empty() and not fs.is_file_password_unlocked(item_path):
lines.append("  [color=#FFB000][FILE] " + item + "  [PASSWORD][/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = fs.get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = fs.join_path(current_path, target)
new_path = fs.normalize_path(new_path)
var node := fs.get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
var required: int = fs.get_required_clearance(new_path)
if not fs.has_clearance(new_path):
var box: String = fs.build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = fs.join_path(current_path, filename)
file_path = fs.normalize_path(file_path)
var node := fs.get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
var required: int = fs.get_required_clearance(file_path)
if not fs.has_clearance(file_path):
var box: String = fs.build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
var fp_key: String = fs.get_file_password_key(file_path)
if not fp_key.is_empty() and not fs.is_file_password_unlocked(file_path):
var fp_info: Dictionary = fs.story_file_passwords[fp_key]
var hint_text: String = fp_info.get("hint", "")
var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
if not hint_text.is_empty():
box_lines.append(["提示: " + hint_text])
box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
var box: String = fs.build_box_sectioned(box_lines, "#FFB000")
append_output(box + "\n", false)
_file_password_mode = true
_file_password_target = file_path
_file_password_filename = filename
input_field.placeholder_text = "输入文件密码..."
return
while tw.is_typing:
await get_tree().process_frame
var content_size: int = node.content.length()
await tw.show_progress_bar(content_size)
await get_tree().create_timer(0.5).timeout
output_text.text = ""
tw.clear_queue()
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
if not read_files.has(file_path):
read_files.append(file_path)
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
var clean_content: String = node.content.strip_edges()
clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
append_output(clean_content, false)
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = fs.get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
tw.clear_queue()
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名: [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]" + str(fs.player_clearance) + "[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
lines.append("  已解锁文件: [color=#66FF66]" + str(fs.unlocked_file_passwords.size()) + "[/color]")
if not story_id.is_empty():
lines.append("  盘ID: [color=#AAAAAA]" + story_id + "[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty() and available_stories.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")
if available_stories.size() > 0:
lines.append("")
lines.append("  已发现 [color=#66FF66]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
var marker: String = ""
if i == current_story_index:
marker = " [color=#33FF33]<< 当前[/color]"
lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]" + marker)
lines.append("     作者: [color=#AAAAAA]" + info.get("author", "未知") + "[/color]")
lines.append("")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 切换磁盘[/color]")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]scan[/color][color=#AAAAAA] 重新扫描目录[/color]")
if story_manifest.has("story"):
lines.append("")
lines.append("[color=#66FF66]─────────── 当前磁盘详情 ───────────[/color]")
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签: [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者:   [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本: [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述: [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数: [color=#66FF66]" + str(fs.file_system.size()) + "[/color]")
lines.append("  磁盘来源: [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态: [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_vdisc_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: vdisc load <编号>[/color]\n[color=#AAAAAA]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
if index == current_story_index:
append_output("[color=#AAAAAA]该磁盘已经是当前加载的磁盘。[/color]\n", false)
return
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
append_output("[color=#AAAAAA]正在卸载当前磁盘...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.3).timeout
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
read_files.clear()
unlocked_passwords.clear()
await tw.show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
if _load_story_by_index(index):
var title: String = available_stories[index].get("title", "未知")
var box: String = fs.build_box_sectioned([
["DISC LOADED", "磁盘加载完成"],
[title]
], "#33FF33")
append_output(box + "\n", false)
_update_status_bar()
append_output("[color=#AAAAAA]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
append_output("[color=#AAAAAA]当前路径: " + current_path + "  权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
fs.init_test_file_system()
_update_status_bar()
func _cmd_unlock(args: Array) -> void:
if not args.is_empty():
_verify_password(args[0])
return
_enter_password_mode()
func _enter_password_mode(target_path: String = "") -> void:
_password_mode = true
_password_target_path = target_path
var box: String = fs.build_box_sectioned([
["SECURITY AUTHENTICATION", "安全认证系统"],
["请输入访问密码:", "(输入 cancel 取消)"]
], "#FFB000")
append_output(box + "\n", false)
input_field.placeholder_text = "输入密码..."
func _verify_password(password: String) -> void:
if not story_manifest.has("passwords"):
append_output("[color=#FF6666][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
return
var passwords: Dictionary = story_manifest["passwords"]
if passwords.has(password):
var pwd_info: Dictionary = passwords[password]
var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
if unlocked_passwords.has(password):
append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
return
if grant_level <= fs.player_clearance:
append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。当前: " + str(fs.player_clearance) + "[/color]\n", false)
return
unlocked_passwords.append(password)
var old_level: int = fs.player_clearance
fs.player_clearance = grant_level
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
var box: String = fs.build_box_sectioned([
["ACCESS GRANTED", "权限认证通过"],
["权限等级: " + str(old_level) + " -> " + str(fs.player_clearance)]
], "#33FF33")
append_output(box + "\n", false)
if pwd_info.has("message"):
append_output("[color=#AAAAAA]" + str(pwd_info["message"]) + "[/color]\n", false)
else:
var box: String = fs.build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _verify_file_password(input_password: String) -> void:
var fp_key: String = fs.get_file_password_key(_file_password_target)
if fp_key.is_empty():
append_output("[color=#FF6666][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
return
var fp_info: Dictionary = fs.story_file_passwords[fp_key]
var correct_password: String = str(fp_info.get("password", ""))
if input_password == correct_password:
fs.unlocked_file_passwords.append(_file_password_target)
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
var box: String = fs.build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], "#33FF33")
append_output(box + "\n", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
await _cmd_open([_file_password_filename])
else:
var box: String = fs.build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _cmd_scan() -> void:
append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await tw.show_progress_bar(500)
await get_tree().create_timer(0.3).timeout
var old_story_path: String = current_story_path
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
read_files.clear()
unlocked_passwords.clear()
available_stories.clear()
current_story_index = -1
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
if _desktop_mode:
if available_stories.is_empty():
append_output("[color=#FFB000][WARN] 未找到虚拟磁盘文件。[/color]", false)
append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
else:
var scan_lines: Array[String] = []
scan_lines.append("[color=#33FF33][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
scan_lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
scan_lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]")
scan_lines.append("")
scan_lines.append("[color=#AAAAAA]输入 [/color][color=#66FF66]load <编号>[/color][color=#AAAAAA] 加载磁盘。[/color]")
append_output("\n".join(scan_lines) + "\n", false)
_update_status_bar()
else:
if available_stories.is_empty():
_desktop_mode = true
fs.init_test_file_system()
current_path = "/"
_update_status_bar()
append_output("[color=#FFB000][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
elif _load_story_by_index(0):
var title: String = "未知"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]", false)
append_output("[color=#AAAAAA]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
else:
current_path = "/"
_update_status_bar()
else:
append_output("[color=#FF6666][ERROR] 重新加载失败。[/color]\n", false)
func _cmd_reboot() -> void:
append_output("[color=#AAAAAA]正在重启终端...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
output_text.text = ""
tw.clear_queue()
command_history.clear()
history_index = -1
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
has_new_mail = false
read_files.clear()
unlocked_passwords.clear()
available_stories.clear()
current_story_index = -1
save_mgr.ensure_stories_dir()
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
output_text.append_text("[color=#AAAAAA]...[/color]\n")
await get_tree().create_timer(0.3).timeout
output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
await get_tree().create_timer(0.5).timeout
output_text.text = ""
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
input_field.grab_focus()
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
if parts.size() == 1:
if current_text.ends_with(" "):
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := fs.get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := fs.join_path(current_path, child)
var node := fs.get_node_at_path(child_path)
if node == null:
continue
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
tw._do_scroll()
else:
var partial_cmd: String = parts[0].to_lower()
var commands: Array
if _desktop_mode:
commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
else:
commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
"scan", "reboot", "restart", "unlock", "eject"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
tw._do_scroll()
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := fs.get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := fs.join_path(current_path, child)
var node := fs.get_node_at_path(child_path)
if node == null:
continue
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
tw._do_scroll()
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具（转发到打字机模块）
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
tw.append(text, extra_newline)
# ============================================================
# 每帧处理（滚动）
# ============================================================
func _process(_delta: float) -> void:
tw.process_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
if _desktop_mode:
path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
mail_icon.text = "[Mail]"
return
var disc_name: String = ""
if current_story_index >= 0 and current_story_index < available_stories.size():
disc_name = available_stories[current_story_index].get("title", "")
if disc_name.is_empty():
path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance)
else:
path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance) + "  DISC:" + disc_name
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
var box: String = fs.build_box([title, subtitle] as Array[String], "#66FF66")
output_text.append_text(box + "\n\n")
if available_stories.is_empty():
output_text.append_text("[color=#FFB000]未检测到虚拟磁盘。[/color]\n")
output_text.append_text("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
else:
output_text.append_text("[color=#66FF66]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
output_text.append_text("  [color=#FFB000]" + str(i + 1) + ".[/color] [color=#66FF66]" + info.get("title", "未知") + "[/color]\n")
output_text.append_text("     [color=#AAAAAA]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
output_text.append_text("\n")
output_text.append_text("[color=#AAAAAA]可用命令:[/color]\n")
output_text.append_text("  [color=#66FF66]load <编号>[/color]   加载指定磁盘\n")
output_text.append_text("  [color=#66FF66]scan[/color]   重新扫描磁盘目录\n")
output_text.append_text("  [color=#66FF66]clear[/color] 清空屏幕\n")
output_text.append_text("  [color=#66FF66]exit[/color]   退出终端\n")
func _cmd_desktop_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: load <编号>[/color]", false)
if available_stories.size() > 0:
append_output("[color=#AAAAAA]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
append_output("[color=#AAAAAA]正在加载虚拟磁盘...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await tw.show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
if _load_story_by_index(index):
_desktop_mode = false
var title: String = available_stories[index].get("title", "未知")
output_text.text = ""
tw.clear_queue()
_update_status_bar()
_show_welcome_message()
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
func _cmd_eject() -> void:
if _desktop_mode:
append_output("[color=#AAAAAA]当前已在桌面模式。[/color]\n", false)
return
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
append_output("[color=#AAAAAA]正在卸载磁盘...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
read_files.clear()
unlocked_passwords.clear()
current_story_index = -1
_desktop_mode = true
output_text.text = ""
tw.clear_queue()
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
var title_display_len: int = fs.display_width(title)
var subtitle_display_len: int = fs.display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# ============================================================
# 剧本加载系统
# ============================================================
func _try_load_story() -> bool:
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
print("[StoryLoader] 搜索目录: " + vdisc_dir)
_scan_available_stories(vdisc_dir)
return not available_stories.is_empty()
func _scan_available_stories(vdisc_dir: String) -> void:
available_stories.clear()
if not DirAccess.dir_exists_absolute(vdisc_dir):
return
var dir := DirAccess.open(vdisc_dir)
if dir == null:
return
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = vdisc_dir + file_name
var info: Dictionary = _peek_story_info(full_path)
info["path"] = full_path
info["filename"] = file_name
available_stories.append(info)
print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
file_name = dir.get_next()
print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")
func _peek_story_info(path: String) -> Dictionary:
var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}
var reader := ZIPReader.new()
if reader.open(path) != OK:
return info
var files := reader.get_files()
for file_path in files:
var filename: String = file_path.get_file()
if filename == "manifest.json":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
var json := JSON.new()
if json.parse(content) == OK and json.data is Dictionary:
var data: Dictionary = json.data
if data.has("story"):
var story_info: Dictionary = data["story"]
info["title"] = story_info.get("title", "未知剧本")
info["id"] = story_info.get("id", "")
info["author"] = story_info.get("author", "未知")
break
elif filename == "manifest.cfg":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
for line in content.split("\n"):
line = line.strip_edges()
if line.begins_with("title="):
info["title"] = line.substr(6).strip_edges()
elif line.begins_with("id="):
info["id"] = line.substr(3).strip_edges()
elif line.begins_with("author="):
info["author"] = line.substr(7).strip_edges()
break
reader.close()
return info
func _load_story_by_index(index: int) -> bool:
if index < 0 or index >= available_stories.size():
return false
var story_info: Dictionary = available_stories[index]
var path: String = story_info["path"]
if _load_story_file(path):
current_story_index = index
return true
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据到 fs 模块
fs.file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 读取盘ID
if story_manifest.has("story") and story_manifest["story"].has("id"):
story_id = story_manifest["story"]["id"]
else:
story_id = str(path.get_file().hash())
# 读取权限表
fs.story_permissions.clear()
if story_manifest.has("permissions"):
var perms: Dictionary = story_manifest["permissions"]
for perm_path in perms.keys():
fs.story_permissions[perm_path] = int(perms[perm_path])
print("[StoryLoader] 权限表已加载，共 " + str(fs.story_permissions.size()) + " 条规则")
else:
print("[StoryLoader] 警告: manifest中未找到permissions字段")
if story_manifest.has("passwords"):
print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
else:
print("[StoryLoader] 警告: manifest中未找到passwords字段")
# 读取文件密码表
fs.story_file_passwords.clear()
if story_manifest.has("file_passwords"):
var fps: Dictionary = story_manifest["file_passwords"]
for fp_path in fps.keys():
fs.story_file_passwords[fp_path] = fps[fp_path]
print("[StoryLoader] 文件密码表已加载，共 " + str(fs.story_file_passwords.size()) + " 条")
else:
print("[StoryLoader] 未配置文件密码表（file_passwords）")
# 应用 manifest 中的设置
var start_clearance: int = 0
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
tw.base_speed = settings["typing_speed"].to_float()
if settings.has("start_clearance"):
start_clearance = int(settings["start_clearance"])
# 尝试加载该剧本的存档
var save_data = save_mgr.load_save(story_id)
if save_data != null:
fs.player_clearance = int(save_data.get("player_clearance", 0))
read_files.clear()
if save_data.has("read_files"):
for f in save_data["read_files"]:
read_files.append(str(f))
unlocked_passwords.clear()
if save_data.has("unlocked_passwords"):
for p in save_data["unlocked_passwords"]:
unlocked_passwords.append(str(p))
fs.unlocked_file_passwords.clear()
if save_data.has("unlocked_file_passwords"):
for p in save_data["unlocked_file_passwords"]:
fs.unlocked_file_passwords.append(str(p))
if save_data.has("current_path"):
var saved_path: String = save_data["current_path"]
if fs.has_clearance(saved_path):
current_path = saved_path
else:
current_path = "/"
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
print("[Save] 权限等级: " + str(fs.player_clearance))
else:
# 没有存档，用初始权限
fs.player_clearance = start_clearance
read_files.clear()
unlocked_passwords.clear()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 盘ID: " + story_id)
print("[StoryLoader] 文件数量: " + str(fs.file_system.size()))
print("[StoryLoader] 权限等级: " + str(fs.player_clearance))
print("[StoryLoader] story_permissions 内容: " + str(fs.story_permissions))
print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
return true

### ASSISTANT
问题的根本原因是：`input_field.grab_focus()` 会让 `RichTextLabel` 立即失去焦点，导致它无法开始拖选操作。即使事件传递下去了，焦点已经被抢走了。

需要修改的是 `_input` 函数中 `MOUSE_BUTTON_LEFT` 的处理逻辑——**判断鼠标是否点击在输出区域内，如果是则不抢焦点**。

只需修改 `_input` 函数，替换整个函数为以下代码：

```gdscript
func _input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		match event.button_index:
			MOUSE_BUTTON_WHEEL_UP:
				scroll_container.scroll_vertical -= 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_WHEEL_DOWN:
				scroll_container.scroll_vertical += 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_LEFT:
				# 判断鼠标是否点击在输出区域内
				var mouse_pos: Vector2 = event.position
				var output_rect: Rect2 = output_text.get_global_rect()
				if output_rect.has_point(mouse_pos):
					# 点击在输出区域内，不抢焦点，让 RichTextLabel 处理选中
					return
				# 点击在输出区域外，聚焦输入框
				input_field.grab_focus()
				return

	# 鼠标释放时，如果不在输出区，重新聚焦输入框
	if event is InputEventMouseButton and not event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			var mouse_pos: Vector2 = event.position
			var output_rect: Rect2 = output_text.get_global_rect()
			if not output_rect.has_point(mouse_pos):
				input_field.grab_focus()
			return

	if not event is InputEventKey or not event.pressed:
		return

	if not input_field.has_focus():
		input_field.grab_focus()

	if tw.is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
		tw.skip()
		get_viewport().set_input_as_handled()
		return

	match event.keycode:
		KEY_ENTER, KEY_KP_ENTER:
			if tw.is_typing:
				get_viewport().set_input_as_handled()
			else:
				var command_text: String = input_field.text
				input_field.clear()
				_on_command_submitted(command_text)
				get_viewport().set_input_as_handled()
		KEY_UP:
			_history_previous()
			get_viewport().set_input_as_handled()
		KEY_DOWN:
			_history_next()
			get_viewport().set_input_as_handled()
		KEY_PAGEUP:
			scroll_container.scroll_vertical -= 100
			get_viewport().set_input_as_handled()
		KEY_PAGEDOWN:
			scroll_container.scroll_vertical += 100
			get_viewport().set_input_as_handled()
		KEY_TAB:
			_auto_complete()
			get_viewport().set_input_as_handled()
```

核心改动点：

1. **鼠标左键按

### USER
我已经修改了_input函数，但还是没有选中效果，你再仔细思考一下问题原因。

### ASSISTANT
# RichTextLabel 无法选中文字的深入分析

根据你的代码，`selection_enabled = true` 已经设置了 [1]，`_input` 函数中也已经对输出区域做了点击判断不抢焦点。但仍然无法选中，让我深入分析可能的原因：

---

## 最可能的原因：ScrollContainer 拦截了鼠标事件

你的节点结构是 [1]：
```
ScrollContainer ($MainContent/OutputArea)
  └── RichTextLabel (OutputText)
```

**ScrollContainer 默认会拦截所有鼠标事件**（用于处理滚动），导致里面的 `RichTextLabel` 根本收不到鼠标按下和拖动事件，所以无法选中文字。

---

## 解决方案

在 `_ready()` 函数中（或者在 `UIManager.setup_output_text()` 中），添加以下设置：

```gdscript
# 让 ScrollContainer 不拦截鼠标事件，透传给 RichTextLabel
scroll_container.get_v_scroll_bar().mouse_filter = Control.MOUSE_FILTER_PASS

# 关键：ScrollContainer 本身也需要设置为 PASS 而不是 STOP
scroll_container.mouse_filter = Control.MOUSE_FILTER_PASS
```

如果上面的方法还不行，还可以尝试更彻底的方案——**禁用 ScrollContainer 自带的滚动处理**，因为你已经在 `_input` 中手动处理了滚轮：

```gdscript
# 在 _ready() 中添加
scroll_container.mouse_filter = Control.MOUSE_FILTER_IGNORE
output_text.mouse_filter = Control.MOUSE_FILTER_STOP
```

这样鼠标事件会穿过 `ScrollContainer`，直接到达 `RichTextLabel`。而滚动功能由你在 `_input` 中的 `MOUSE_BUTTON_WHEEL_UP/DOWN` 处理来保证。

---

## 另一个容易忽略的点

`RichTextLabel` 需要**获得焦点**才能进行文本选中操作。确保 `output_text` 的 `focus_mode` 不是 `NONE`：

```gdscript
output_text.focus_mode = Control.FOCUS_CLICK
```

---

## 总结：在 `_ready()` 中添加这三行

```gdscript
scroll_container.mouse_filter = Control.MOUSE_FILTER_IGNORE
output_text.mouse_filter = Control.MOUSE_FILTER_STOP
output_text.focus_mode = Control.FOCUS_CLICK
```

这三行的作用：
1. **ScrollContainer 忽略鼠标** → 事件穿透到子节点
2. **RichTextLabel 接收鼠标** → 处理选中拖拽
3. **允许点击获取焦点** → 选中操作需要焦点支持

滚轮滚动不受影响，因为你已经在 `_input` 中用代码手动处理了 [1]。

### USER
还是没有解决，你再仔细思考一下，我把ui_manager.gd全部发你，你再找找可能的原因。
# ============================================================
# ui_manager.gd - UI 初始化与背景管理
# 负责：背景图加载、Shader应用、各UI组件样式初始化
# ============================================================
class_name UIManager
extends RefCounted
# ============================================================
# 背景初始化
# ============================================================
static func setup_background(parent: Control, game_root_dir: String) -> TextureRect:
var background := TextureRect.new()
background.name = "Background"
parent.add_child(background)
parent.move_child(background, 0)
background.set_anchors_preset(Control.PRESET_FULL_RECT)
background.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
background.mouse_filter = Control.MOUSE_FILTER_IGNORE
var bg_path: String = game_root_dir + "background.png"
var tex: Texture2D = null
if FileAccess.file_exists(bg_path):
var image := Image.new()
var err := image.load(bg_path)
if err == OK:
tex = ImageTexture.create_from_image(image)
print("[UI] 已加载外部背景图: " + bg_path)
else:
print("[UI] 背景图加载失败: " + str(err))
if tex == null:
var image := Image.create(4, 4, false, Image.FORMAT_RGB8)
image.fill(Color(0.02, 0.04, 0.02, 1.0))
tex = ImageTexture.create_from_image(image)
print("[UI] 使用默认深色背景")
background.texture = tex
var shader_path: String = "res://background_vignette.gdshader"
if ResourceLoader.exists(shader_path):
var shader: Shader = load(shader_path)
var mat := ShaderMaterial.new()
mat.shader = shader
mat.set_shader_parameter("vignette_strength", 0.8)
mat.set_shader_parameter("vignette_radius", 0.9)
mat.set_shader_parameter("glow_strength", 0.08)
mat.set_shader_parameter("glow_radius", 0.4)
mat.set_shader_parameter("brightness", 0.7)
mat.set_shader_parameter("tint_color", Color(0.1, 0.3, 0.1, 0.15))
background.material = mat
print("[UI] 背景Shader已应用")
else:
print("[UI] 未找到背景Shader文件: " + shader_path)
return background
# ============================================================
# 主内容区透明化（让背景图透出来）
# ============================================================
static func setup_main_content(parent: Control, main_content: Control) -> void:
if main_content == null:
return
parent.move_child(main_content, parent.get_child_count() - 1)
if main_content is Control:
var transparent_style := StyleBoxFlat.new()
transparent_style.bg_color = Color(0, 0, 0, 0)
transparent_style.set_border_width_all(0)
main_content.add_theme_stylebox_override("panel", transparent_style)
# ============================================================
# 状态栏样式
# ============================================================
static func setup_status_frame(status_frame: PanelContainer) -> void:
var style := StyleBoxFlat.new()
style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
style.border_color = Color(0.2, 0.6, 0.2, 0.4)
style.set_border_width_all(1)
style.content_margin_left = 4
style.content_margin_right = 4
style.content_margin_top = 3
style.content_margin_bottom = 3
status_frame.add_theme_stylebox_override("panel", style)
# ============================================================
# 路径标签样式（透明无边框）
# ============================================================
static func setup_path_label(path_label: Label) -> void:
var style := StyleBoxFlat.new()
style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
style.border_color = Color(0.0, 0.0, 0.0, 0.0)
style.set_border_width_all(0)
style.content_margin_left = 6
style.content_margin_right = 6
style.content_margin_top = 2
style.content_margin_bottom = 2
path_label.add_theme_stylebox_override("normal", style)
# ============================================================
# 邮件图标样式
# ============================================================
static func setup_mail_icon(mail_icon: Label) -> void:
var style := StyleBoxFlat.new()
style.bg_color = Color(0.0, 0.03, 0.0, 0.6)
style.border_color = Color(0.2, 0.6, 0.2, 0.35)
style.set_border_width_all(1)
style.content_margin_left = 8
style.content_margin_right = 8
style.content_margin_top = 2
style.content_margin_bottom = 2
mail_icon.add_theme_stylebox_override("normal", style)
# ============================================================
# 输入区外框样式
# ============================================================
static func setup_input_frame(input_frame: PanelContainer) -> void:
var style := StyleBoxFlat.new()
style.bg_color = Color(0.0, 0.04, 0.0, 0.9)
style.border_color = Color(0.2, 0.6, 0.2, 0.4)
style.set_border_width_all(1)
style.content_margin_left = 4
style.content_margin_right = 4
style.content_margin_top = 3
style.content_margin_bottom = 3
input_frame.add_theme_stylebox_override("panel", style)
# ============================================================
# 输入框样式（透明无边框，靠外层 InputFrame 提供边框）
# ============================================================
static func setup_input_field(input_field: LineEdit) -> void:
var style := StyleBoxFlat.new()
style.bg_color = Color(0.0, 0.0, 0.0, 0.0)
style.border_color = Color(0.0, 0.0, 0.0, 0.0)
style.set_border_width_all(0)
style.content_margin_left = 6
style.content_margin_right = 6
style.content_margin_top = 2
style.content_margin_bottom = 2
input_field.add_theme_stylebox_override("normal", style)
input_field.add_theme_stylebox_override("focus", style.duplicate())
# ============================================================
# 输出文本框初始化
# ============================================================
static func setup_output_text(output_text: RichTextLabel) -> void:
output_text.text = ""
output_text.bbcode_enabled = true
output_text.selection_enabled = true
output_text.meta_underlined = true
output_text.mouse_filter = Control.MOUSE_FILTER_PASS  # 确保能接收鼠标事件
# ============================================================
# 一次性初始化所有 UI 样式
# ============================================================
static func setup_all_styles(
status_frame: PanelContainer,
path_label: Label,
mail_icon: Label,
input_frame: PanelContainer,
input_field: LineEdit,
output_text: RichTextLabel
) -> void:
setup_status_frame(status_frame)
setup_path_label(path_label)
setup_mail_icon(mail_icon)
setup_input_frame(input_frame)
setup_input_field(input_field)
setup_output_text(output_text)

### ASSISTANT
我仔细分析了所有代码后，找到了多个叠加的原因：

## 问题分析

**问题1**：`output_text.mouse_filter` 设置为 `MOUSE_FILTER_PASS` 是错误的。`PASS` 的意思是"接收事件后继续向父节点传递"，但实际上 `RichTextLabel` 的文本选中需要 `STOP` 来完全捕获鼠标拖拽事件。

**问题2**：`ScrollContainer`（即 `scroll_container`）默认 `mouse_filter` 是 `STOP`，它会在鼠标事件到达 `RichTextLabel` 之前就拦截掉。你在 `_input()` 中已经手动处理了滚轮，所以 `ScrollContainer` 不需要再拦截鼠标。

**问题3**：`RichTextLabel` 的 `focus_mode` 默认是 `FOCUS_NONE`，没有焦点就无法进行选中操作。

## 修改方案

### 修改 `ui_manager.gd` 中的 `setup_output_text` 函数

```gdscript
static func setup_output_text(output_text: RichTextLabel) -> void:
	output_text.text = ""
	output_text.bbcode_enabled = true
	output_text.selection_enabled = true
	output_text.meta_underlined = true
	output_text.mouse_filter = Control.MOUSE_FILTER_STOP
	output_text.focus_mode = Control.FOCUS_CLICK
```

### 在 `ui_manager.gd` 中新增一个函数

```gdscript
# ============================================================
# ScrollContainer 设置（让鼠标事件能穿透到 RichTextLabel）
# ============================================================
static func setup_scroll_container(scroll_container: ScrollContainer) -> void:
	scroll_container.mouse_filter = Control.MOUSE_FILTER_IGNORE
```

### 修改 `ui_manager.gd` 中的 `setup_all_styles` 函数签名和内容

```gdscript
static func setup_all_styles(
	status_frame: PanelContainer,
	path_label: Label,
	mail_icon: Label,
	input_frame: PanelContainer,
	input_field: LineEdit,
	output_text: RichTextLabel,
	scroll_container: ScrollContainer = null
) -> void:
	setup_status_frame(status_frame)
	setup_path_label(path_label)
	setup_mail_icon(mail_icon)
	setup_input_frame(input_frame)
	setup_input_field(input_field)
	setup_output_text(output_text)
	if scroll_container != null:
		setup_scroll_container(scroll_container)
```

### 修改 `main.gd` 中 `_ready()` 的调用

找到这一行：
```gdscript
UIManager.setup_all_styles(status_frame, path_label, mail_icon, input_frame, input_field, output_text)
```

替换为：
```gdscript
UIManager.setup_all_styles(status_frame, path_label, mail_icon, input_frame, input_field, output_text, scroll_container)
```

## 总结

三个改动配合工作：
- `ScrollContainer.mouse_filter = IGNORE` → 鼠标事件穿透，不被滚动容器拦截
- `RichTextLabel.mouse_filter = STOP` → 完全捕获鼠标事件用于文本选中
- `RichTextLabel.focus_mode = FOCUS_CLICK` → 点击时获取焦点，选中操作才能生效
- 滚轮功能不受影响，因为已经在 `_input()` 中手动处理 [1]

### USER
还是没有修复，你再仔细从头反思一下有哪些可能的问题。我觉得我在场景树中也有错误设置，你把这方面也检查一下，我会附上场景树和脚本文件的截图。

### ASSISTANT


### USER
还是没有修复，你再仔细从头反思一下有哪些可能的问题。我觉得我在场景树中也有错误设置，你把这方面也检查一下，我会附上场景树和脚本文件的截图。

### ASSISTANT
# 从头深入分析 RichTextLabel 无法选中文字的问题

## 发现关键问题！

从场景树截图中我看到了一个被忽略的节点：

```
Main
  ├── Background
  ├── MainContent
  │     ├── StatusFrame
  │     ├── OutputArea (ScrollContainer)
  │     │     └── OutputText (RichTextLabel)
  │     └── InputFrame
  └── CRTEffect        ← ← ← 这个！
        └── CRTShader
```

**`CRTEffect` 节点在 `MainContent` 的上层（后面渲染 = 在最上面），它很可能是一个全屏覆盖的 `ColorRect` 或 `TextureRect`，用于做CRT显示器效果。这个节点会拦截所有鼠标事件，导致底下的 `RichTextLabel` 根本收不到任何鼠标操作！**

这才是根本原因。之前所有的 `mouse_filter`、`focus_mode` 修改都没用，因为事件在到达 `OutputText` 之前就被最顶层的 `CRTEffect` 吞掉了。

---

## 修复方案

### 方案1：在场景树中修改（推荐）

在 Godot 编辑器中选中 `CRTEffect`（以及 `CRTShader`）节点，在检查器中将它们的 **Mouse Filter** 设置为 **Ignore**：

- 选中 `CRTEffect` → Inspector → Mouse → Filter → 改为 `Ignore`
- 选中 `CRTShader` → Inspector → Mouse → Filter → 改为 `Ignore`

### 方案2：在代码中修改

在 `main.gd` 的 `_ready()` 中添加：

```gdscript
# CRT效果层不拦截鼠标事件
var crt_effect = $CRTEffect
if crt_effect:
    crt_effect.mouse_filter = Control.MOUSE_FILTER_IGNORE
    for child in crt_effect.get_children():
        if child is Control:
            child.mouse_filter = Control.MOUSE_FILTER_IGNORE
```

或者如果你知道具体节点类型，直接写：

```gdscript
$CRTEffect.mouse_filter = Control.MOUSE_FILTER_IGNORE
$CRTEffect/CRTShader.mouse_filter = Control.MOUSE_FILTER_IGNORE
```

### 方案3：加到 UIManager 中（更规范）

在 `ui_manager.gd` 中新增：

```gdscript
static func setup_crt_effect(crt_node: Control) -> void:
    if crt_node == null:
        return
    crt_node.mouse_filter = Control.MOUSE_FILTER_IGNORE
    for child in crt_node.get_children():
        if child is Control:
            child.mouse_filter = Control.MOUSE_FILTER_IGNORE
```

然后在 `main.gd` 的 `_ready()` 中调用：

```gdscript
UIManager.setup_crt_effect($CRTEffect)
```

---

## 同时确认之前的设置也要保留

```gdscript
# ui_manager.gd 中的 setup_output_text
static func setup_output_text(output_text: RichTextLabel) -> void:
    output_text.text = ""
    output_text.bbcode_enabled = true
    output_text.selection_enabled = true
    output_text.meta_underlined = true
    output_text.mouse_filter = Control.MOUSE_FILTER_STOP
    output_text.focus_mode = Control.FOCUS_CLICK
```

---

## 总结

| 层级 | 节点 | mouse_filter 应设为 |
|------|------|-------------------|
| 最顶层 | CRTEffect | **IGNORE** |
| 最顶层 | CRTShader | **IGNORE** |
| 中间层 | ScrollContainer (OutputArea) | **IGNORE** |
| 目标层 | RichTextLabel (OutputText) | **STOP** |

核心原理：Godot 的鼠标事件是从**最上层的可见 Control 节点**开始向下传递的。`CRTEffect` 在场景树中排在 `MainContent` 后面，意味着它**渲染在最上面**，如果 `mouse_filter` 不是 `IGNORE`，所有鼠标事件都会被它拦截，底下的节点永远收不到。

### USER
CRTEffect是CanvalsLayer，没有Mouse Filter，CRTShader的我修改了，现在已经能正常选中了。
但是颜色主题不太搭配，修改成浅绿色的，且需要方便之后如果有修改主题色的功能时一并修改。
然后是鼠标样式，现在是windows原生鼠标，换一个更符合老式的鼠标风格，且看起来要像是在这个crt屏幕内的。

### ASSISTANT
好的！文字选中的问题解决了。现在来处理两个新需求：

1. **统一颜色主题系统**（浅绿色，便于将来切换主题）
2. **CRT 风格自定义鼠标光标**

---

## 第一步：新建 `scripts/theme_manager.gd` — 颜色主题系统

```gdscript
# ============================================================
# theme_manager.gd - 全局颜色主题管理
# 所有颜色集中定义，方便一键切换主题
# ============================================================
class_name ThemeManager
extends RefCounted

# ============================================================
# 主题配置结构
# ============================================================
class ThemeColors:
	# 主色调（用于标题、边框、高亮文字）
	var primary: Color
	# 次要色调（用于普通文字、提示）
	var secondary: Color
	# 暗色调（用于背景、不活跃元素）
	var dim: Color
	# 成功色
	var success: Color
	# 警告色
	var warning: Color
	# 错误色
	var error: Color
	# 信息色（目录等）
	var info: Color
	# 灰色/注释色
	var muted: Color
	# 背景色
	var bg: Color
	# 背景色（半透明，用于面板）
	var bg_panel: Color
	# 边框色
	var border: Color
	# 输入框文字色
	var input_text: Color
	# 选中高亮背景色
	var selection_bg: Color

	# BBCode 颜色字符串（缓存，避免重复转换）
	var primary_hex: String
	var secondary_hex: String
	var dim_hex: String
	var success_hex: String
	var warning_hex: String
	var error_hex: String
	var info_hex: String
	var muted_hex: String

	func update_hex() -> void:
		primary_hex = "#" + primary.to_html(false)
		secondary_hex = "#" + secondary.to_html(false)
		dim_hex = "#" + dim.to_html(false)
		success_hex = "#" + success.to_html(false)
		warning_hex = "#" + warning.to_html(false)
		error_hex = "#" + error.to_html(false)
		info_hex = "#" + info.to_html(false)
		muted_hex = "#" + muted.to_html(false)

# ============================================================
# 当前激活的主题
# ============================================================
static var current: ThemeColors = null
static var current_theme_name: String = ""

# ============================================================
# 初始化（默认加载 phosphor_green 主题）
# ============================================================
static func init(theme_name: String = "phosphor_green") -> void:
	load_theme(theme_name)

# ============================================================
# 加载指定主题
# ============================================================
static func load_theme(theme_name: String) -> void:
	current_theme_name = theme_name
	match theme_name:
		"phosphor_green":
			current = _theme_phosphor_green()
		"amber":
			current = _theme_amber()
		"cool_blue":
			current = _theme_cool_blue()
		"white":
			current = _theme_white()
		_:
			current = _theme_phosphor_green()
	current.update_hex()
	print("[Theme] 已加载主题: " + theme_name)

# ============================================================
# 便捷方法：用 BBCode 包裹文字
# ============================================================
static func c_primary(text: String) -> String:
	return "[color=" + current.primary_hex + "]" + text + "[/color]"

static func c_secondary(text: String) -> String:
	return "[color=" + current.secondary_hex + "]" + text + "[/color]"

static func c_dim(text: String) -> String:
	return "[color=" + current.dim_hex + "]" + text + "[/color]"

static func c_success(text: String) -> String:
	return "[color=" + current.success_hex + "]" + text + "[/color]"

static func c_warning(text: String) -> String:
	return "[color=" + current.warning_hex + "]" + text + "[/color]"

static func c_error(text: String) -> String:
	return "[color=" + current.error_hex + "]" + text + "[/color]"

static func c_info(text: String) -> String:
	return "[color=" + current.info_hex + "]" + text + "[/color]"

static func c_muted(text: String) -> String:
	return "[color=" + current.muted_hex + "]" + text + "[/color]"

# ============================================================
# 主题定义：磷光绿（经典CRT终端）
# ============================================================
static func _theme_phosphor_green() -> ThemeColors:
	var t := ThemeColors.new()
	t.primary = Color(0.6, 1.0, 0.6, 1.0)       # #99FF99 浅绿
	t.secondary = Color(0.4, 0.9, 0.4, 1.0)      # #66E566 中绿
	t.dim = Color(0.25, 0.6, 0.25, 1.0)           # #409940 暗绿
	t.success = Color(0.5, 1.0, 0.5, 1.0)         # #80FF80 亮绿
	t.warning = Color(1.0, 0.85, 0.4, 1.0)        # #FFD966 琥珀黄
	t.error = Color(1.0, 0.45, 0.45, 1.0)         # #FF7373 柔红
	t.info = Color(0.5, 0.75, 1.0, 1.0)           # #80BFFF 淡蓝
	t.muted = Color(0.55, 0.75, 0.55, 1.0)        # #8CBF8C 灰绿
	t.bg = Color(0.01, 0.03, 0.01, 1.0)           # 近黑绿
	t.bg_panel = Color(0.0, 0.04, 0.0, 0.9)       # 面板背景
	t.border = Color(0.3, 0.7, 0.3, 0.4)          # 边框绿
	t.input_text = Color(0.6, 1.0, 0.6, 1.0)      # 输入文字浅绿
	t.selection_bg = Color(0.3, 0.6, 0.3, 0.5)    # 选中背景
	return t

# ============================================================
# 主题定义：琥珀色（复古琥珀显示器）
# ============================================================
static func _theme_amber() -> ThemeColors:
	var t := ThemeColors.new()
	t.primary = Color(1.0, 0.85, 0.4, 1.0)
	t.secondary = Color(0.9, 0.75, 0.3, 1.0)
	t.dim = Color(0.6, 0.5, 0.2, 1.0)
	t.success = Color(0.6, 1.0, 0.4, 1.0)
	t.warning = Color(1.0, 0.95, 0.5, 1.0)
	t.error = Color(1.0, 0.4, 0.3, 1.0)
	t.info = Color(1.0, 0.9, 0.6, 1.0)
	t.muted = Color(0.7, 0.6, 0.35, 1.0)
	t.bg = Color(0.03, 0.02, 0.0, 1.0)
	t.bg_panel = Color(0.04, 0.03, 0.0, 0.9)
	t.border = Color(0.7, 0.55, 0.2, 0.4)
	t.input_text = Color(1.0, 0.85, 0.4, 1.0)
	t.selection_bg = Color(0.5, 0.4, 0.15, 0.5)
	return t

# ============================================================
# 主题定义：冷蓝（现代终端）
# ============================================================
static func _theme_cool_blue() -> ThemeColors:
	var t := ThemeColors.new()
	t.primary = Color(0.5, 0.8, 1.0, 1.0)
	t.secondary = Color(0.4, 0.7, 0.95, 1.0)
	t.dim = Color(0.25, 0.45, 0.65, 1.0)
	t.success = Color(0.4, 1.0, 0.7, 1.0)
	t.warning = Color(1.0, 0.85, 0.4, 1.0)
	t.error = Color(1.0, 0.45, 0.45, 1.0)
	t.info = Color(0.6, 0.85, 1.0, 1.0)
	t.muted = Color(0.5, 0.65, 0.8, 1.0)
	t.bg = Color(0.01, 0.02, 0.04, 1.0)
	t.bg_panel = Color(0.0, 0.02, 0.05, 0.9)
	t.border = Color(0.3, 0.5, 0.8, 0.4)
	t.input_text = Color(0.5, 0.8, 1.0, 1.0)
	t.selection_bg = Color(0.2, 0.4, 0.6, 0.5)
	return t

# ============================================================
# 主题定义：纯白（高对比）
# ============================================================
static func _theme_white() -> ThemeColors:
	var t := ThemeColors.new()
	t.primary = Color(0.95, 0.95, 0.95, 1.0)
	t.secondary = Color(0.8, 0.8, 0.8, 1.0)
	t.dim = Color(0.5, 0.5, 0.5, 1.0)
	t.success = Color(0.4, 1.0, 0.4, 1.0)
	t.warning = Color(1.0, 0.85, 0.3, 1.0)
	t.error = Color(1.0, 0.4, 0.4, 1.0)
	t.info = Color(0.5, 0.75, 1.0, 1.0)
	t.muted = Color(0.6, 0.6, 0.6, 1.0)
	t.bg = Color(0.02, 0.02, 0.02, 1.0)
	t.bg_panel = Color(0.03, 0.03, 0.03, 0.9)
	t.border = Color(0.5, 0.5, 0.5, 0.4)
	t.input_text = Color(0.95, 0.95, 0.95, 1.0)
	t.selection_bg = Color(0.4, 0.4, 0.4, 0.5)
	return t

# ============================================================
# 获取所有可用主题名称
# ============================================================
static func get_available_themes() -> Array[String]:
	return ["phosphor_green", "amber", "cool_blue", "white"]
```

---

## 第二步：修改 `ui_manager.gd` — 使用主题色 + 鼠标光标

完整替换整个文件：

```gdscript
# ============================================================
# ui_manager.gd - UI 初始化与背景管理
# 负责：背景图加载、Shader应用、各UI组件样式初始化、鼠标光标
# ============================================================
class_name UIManager
extends RefCounted

# ============================================================
# 背景初始化
# ============================================================
static func setup_background(parent: Control, game_root_dir: String) -> TextureRect:
	var background := TextureRect.new()
	background.name = "Background"
	parent.add_child(background)
	parent.move_child(background, 0)

	background.set_anchors_preset(Control.PRESET_FULL_RECT)
	background.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_COVERED
	background.mouse_filter = Control.MOUSE_FILTER_IGNORE

	var bg_path: String = game_root_dir + "background.png"
	var tex: Texture2D = null

	if FileAccess.file_exists(bg_path):
		var image := Image.new()
		var err := image.load(bg_path)
		if err == OK:
			tex = ImageTexture.create_from_image(image)
			print("[UI] 已加载外部背景图: " + bg_path)
		else:
			print("[UI] 背景图加载失败: " + str(err))

	if tex == null:
		var t := ThemeManager.current
		var image := Image.create(4, 4, false, Image.FORMAT_RGBA8)
		image.fill(t.bg if t != null else Color(0.02, 0.04, 0.02, 1.0))
		tex = ImageTexture.create_from_image(image)
		print("[UI] 使用默认深色背景")

	background.texture = tex

	var shader_path: String = "res://shaders/background_vignette.gdshader"
	if not ResourceLoader.exists(shader_path):
		shader_path = "res://background_vignette.gdshader"
	if ResourceLoader.exists(shader_path):
		var shader: Shader = load(shader_path)
		var mat := ShaderMaterial.new()
		mat.shader = shader
		var t := ThemeManager.current
		mat.set_shader_parameter("vignette_strength", 0.8)
		mat.set_shader_parameter("vignette_radius", 0.9)
		mat.set_shader_parameter("glow_strength", 0.08)
		mat.set_shader_parameter("glow_radius", 0.4)
		mat.set_shader_parameter("brightness", 0.7)
		if t != null:
			mat.set_shader_parameter("tint_color", Color(t.primary.r * 0.15, t.primary.g * 0.15, t.primary.b * 0.15, 0.15))
		else:
			mat.set_shader_parameter("tint_color", Color(0.1, 0.3, 0.1, 0.15))
		background.material = mat
		print("[UI] 背景Shader已应用")
	else:
		print("[UI] 未找到背景Shader文件")

	return background

# ============================================================
# 主内容区透明化
# ============================================================
static func setup_main_content(parent: Control, main_content: Control) -> void:
	if main_content == null:
		return
	parent.move_child(main_content, parent.get_child_count() - 1)
	if main_content is Control:
		var transparent_style := StyleBoxFlat.new()
		transparent_style.bg_color = Color(0, 0, 0, 0)
		transparent_style.set_border_width_all(0)
		main_content.add_theme_stylebox_override("panel", transparent_style)

# ============================================================
# 状态栏样式
# ============================================================
static func setup_status_frame(status_frame: PanelContainer) -> void:
	var t := ThemeManager.current
	var style := StyleBoxFlat.new()
	style.bg_color = t.bg_panel if t != null else Color(0.0, 0.04, 0.0, 0.9)
	style.border_color = t.border if t != null else Color(0.2, 0.6, 0.2, 0.4)
	style.set_border_width_all(1)
	style.content_margin_left = 4
	style.content_margin_right = 4
	style.content_margin_top = 3
	style.content_margin_bottom = 3
	status_frame.add_theme_stylebox_override("panel", style)

# ============================================================
# 路径标签样式
# ============================================================
static func setup_path_label(path_label: Label) -> void:
	var t := ThemeManager.current
	var style := StyleBoxFlat.new()
	style.bg_color = Color(0, 0, 0, 0)
	style.border_color = Color(0, 0, 0, 0)
	style.set_border_width_all(0)
	style.content_margin_left = 6
	style.content_margin_right = 6
	style.content_margin_top = 2
	style.content_margin_bottom = 2
	path_label.add_theme_stylebox_override("normal", style)
	if t != null:
		path_label.add_theme_color_override("font_color", t.primary)

# ============================================================
# 邮件图标样式
# ============================================================
static func setup_mail_icon(mail_icon: Label) -> void:
	var t := ThemeManager.current
	var style := StyleBoxFlat.new()
	style.bg_color = Color(t.bg.r, t.bg.g, t.bg.b, 0.6) if t != null else Color(0.0, 0.03, 0.0, 0.6)
	style.border_color = Color(t.border.r, t.border.g, t.border.b, 0.35) if t != null else Color(0.2, 0.6, 0.2, 0.35)
	style.set_border_width_all(1)
	style.content_margin_left = 8
	style.content_margin_right = 8
	style.content_margin_top = 2
	style.content_margin_bottom = 2
	mail_icon.add_theme_stylebox_override("normal", style)
	if t != null:
		mail_icon.add_theme_color_override("font_color", t.primary)

# ============================================================
# 输入区外框样式
# ============================================================
static func setup_input_frame(input_frame: PanelContainer) -> void:
	var t := ThemeManager.current
	var style := StyleBoxFlat.new()
	style.bg_color = t.bg_panel if t != null else Color(0.0, 0.04, 0.0, 0.9)
	style.border_color = t.border if t != null else Color(0.2, 0.6, 0.2, 0.4)
	style.set_border_width_all(1)
	style.content_margin_left = 4
	style.content_margin_right = 4
	style.content_margin_top = 3
	style.content_margin_bottom = 3
	input_frame.add_theme_stylebox_override("panel", style)

# ============================================================
# 输入框样式
# ============================================================
static func setup_input_field(input_field: LineEdit) -> void:
	var t := ThemeManager.current
	var style := StyleBoxFlat.new()
	style.bg_color = Color(0, 0, 0, 0)
	style.border_color = Color(0, 0, 0, 0)
	style.set_border_width_all(0)
	style.content_margin_left = 6
	style.content_margin_right = 6
	style.content_margin_top = 2
	style.content_margin_bottom = 2
	input_field.add_theme_stylebox_override("normal", style)
	input_field.add_theme_stylebox_override("focus", style.duplicate())
	if t != null:
		input_field.add_theme_color_override("font_color", t.input_text)
		input_field.add_theme_color_override("font_placeholder_color", t.dim)
		input_field.add_theme_color_override("caret_color", t.primary)
		input_field.add_theme_color_override("selection_color", t.selection_bg)

# ============================================================
# 输出文本框初始化
# ============================================================
static func setup_output_text(output_text: RichTextLabel) -> void:
	var t := ThemeManager.current
	output_text.text = ""
	output_text.bbcode_enabled = true
	output_text.selection_enabled = true
	output_text.meta_underlined = true
	output_text.mouse_filter = Control.MOUSE_FILTER_STOP
	output_text.focus_mode = Control.FOCUS_CLICK
	if t != null:
		output_text.add_theme_color_override("default_color", t.secondary)
		output_text.add_theme_color_override("selection_color", t.selection_bg)

# ============================================================
# ScrollContainer 设置
# ============================================================
static func setup_scroll_container(scroll_container: ScrollContainer) -> void:
	scroll_container.mouse_filter = Control.MOUSE_FILTER_IGNORE

# ============================================================
# CRT 效果层设置
# ============================================================
static func setup_crt_effect(crt_node: Node) -> void:
	if crt_node == null:
		return
	for child in crt_node.get_children():
		if child is Control:
			child.mouse_filter = Control.MOUSE_FILTER_IGNORE

# ============================================================
# 自定义鼠标光标（CRT风格像素光标）
# ============================================================
static func setup_custom_cursor(parent: Control) -> void:
	# 生成像素风格的箭头光标
	var cursor_image := _generate_crt_cursor()
	var cursor_texture := ImageTexture.create_from_image(cursor_image)
	Input.set_custom_mouse_cursor(cursor_texture, Input.CURSOR_ARROW, Vector2(0, 0))

	# 生成像素风格的 I-beam 光标（用于文字选中）
	var ibeam_image := _generate_crt_ibeam()
	var ibeam_texture := ImageTexture.create_from_image(ibeam_image)
	Input.set_custom_mouse_cursor(ibeam_texture, Input.CURSOR_IBEAM, Vector2(8, 10))

	# 生成像素风格的手指光标（用于超链接）
	var hand_image := _generate_crt_hand()
	var hand_texture := ImageTexture.create_from_image(hand_image)
	Input.set_custom_mouse_cursor(hand_texture, Input.CURSOR_POINTING_HAND, Vector2(6, 2))

	print("[UI] CRT风格鼠标光标已应用")

# ============================================================
# 生成 CRT 风格箭头光标 (16x20)
# ============================================================
static func _generate_crt_cursor() -> Image:
	var t := ThemeManager.current
	var fg: Color = t.primary if t != null else Color(0.6, 1.0, 0.6, 1.0)
	var outline: Color = Color(0, 0, 0, 0.9)
	var glow: Color = Color(fg.r, fg.g, fg.b, 0.3)

	var w: int = 16
	var h: int = 20
	var img := Image.create(w, h, false, Image.FORMAT_RGBA8)
	img.fill(Color(0, 0, 0, 0))

	# 箭头像素图案（1=填充, 2=轮廓, 3=发光）
	var pattern: Array = [
		[3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[3,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[3,1,2,3,0,0,0,0,0,0,0,0,0,0,0,0],
		[3,1,1,2,3,0,0,0,0,0,0,0,0,0,0,0],
		[3,1,1,1,2,3,0,0,0,0,0,0,0,0,0,0],
		[3,1,1,1,1,2,3,0,0,0,0,0,0,0,0,0],
		[3,1,1,1,1,1,2,3,0,0,0,0,0,0,0,0],
		[3,1,1,1,1,1,1,2,3,0,0,0,0,0,0,0],
		[3,1,1,1,1,1,1,1,2,3,0,0,0,0,0,0],
		[3,1,1,1,1,1,1,1,1,2,3,0,0,0,0,0],
		[3,1,1,1,1,1,1,1,1,1,2,3,0,0,0,0],
		[3,1,1,1,1,1,1,2,2,2,2,2,0,0,0,0],
		[3,1,1,1,2,1,1,2,3,0,0,0,0,0,0,0],
		[3,1,1,2,3,2,1,1,2,3,0,0,0,0,0,0],
		[3,1,2,3,0,3,2,1,1,2,3,0,0,0,0,0],
		[3,2,3,0,0,0,3,2,1,1,2,3,0,0,0,0],
		[3,3,0,0,0,0,3,2,1,1,2,3,0,0,0,0],
		[0,0,0,0,0,0,0,3,2,1,2,3,0,0,0,0],
		[0,0,0,0,0,0,0,0,3,2,3,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0],
	]

	for y in range(h):
		for x in range(w):
			if y < pattern.size() and x < pattern[y].size():
				match pattern[y][x]:
					1:
						img.set_pixel(x, y, fg)
					2:
						img.set_pixel(x, y, outline)
					3:
						img.set_pixel(x, y, glow)

	return img

# ============================================================
# 生成 CRT 风格 I-beam 文字光标 (16x20)
# ============================================================
static func _generate_crt_ibeam() -> Image:
	var t := ThemeManager.current
	var fg: Color = t.primary if t != null else Color(0.6, 1.0, 0.6, 1.0)
	var outline: Color = Color(0, 0, 0, 0.9)
	var glow: Color = Color(fg.r, fg.g, fg.b, 0.3)

	var w: int = 16
	var h: int = 20
	var img := Image.create(w, h, false, Image.FORMAT_RGBA8)
	img.fill(Color(0, 0, 0, 0))

	# I-beam 像素图案
	# 顶部横杠
	for x in range(4, 12):
		img.set_pixel(x, 0, glow)
		img.set_pixel(x, 1, fg)
		img.set_pixel(x, 2, glow)
	# 竖线
	for y in range(2, 18):
		img.set_pixel(7, y, outline)
		img.set_pixel(8, y, fg)
		img.set_pixel(9, y, outline)
	# 底部横杠
	for x in range(4, 12):
		img.set_pixel(x, 17, glow)
		img.set_pixel(x, 18, fg)
		img.set_pixel(x, 19, glow)

	return img

# ============================================================
# 生成 CRT 风格手指光标 (16x20)
# ============================================================
static func _generate_crt_hand() -> Image:
	var t := ThemeManager.current
	var fg: Color = t.primary if t != null else Color(0.6, 1.0, 0.6, 1.0)
	var outline: Color = Color(0, 0, 0, 0.9)
	var glow: Color = Color(fg.r, fg.g, fg.b, 0.3)

	var w: int = 16
	var h: int = 20
	var img := Image.create(w, h, false, Image.FORMAT_RGBA8)
	img.fill(Color(0, 0, 0, 0))

	# 手指光标像素图案
	var pattern: Array = [
		[0,0,0,0,0,3,2,3,0,0,0,0,0,0,0,0],
		[0,0,0,0,3,2,1,2,3,0,0,0,0,0,0,0],
		[0,0,0,0,3,2,1,2,3,0,0,0,0,0,0,0],
		[0,0,0,0,3,2,1,2,3,0,0,0,0,0,0,0],
		[0,0,0,0,3,2,1,2,3,2,3,0,0,0,0,0],
		[0,0,0,0,3,2,1,2,1,2,3,2,3,0,0,0],
		[0,0,0,0,3,2,1,2,1,2,1,2,3,2,0,0],
		[0,3,2,3,3,2,1,1,1,2,1,2,1,2,3,0],
		[3,2,1,2,3,1,1,1,1,1,1,1,1,2,3,0],
		[3,2,1,1,2,1,1,1,1,1,1,1,1,2,3,0],
		[0,3,2,1,1,1,1,1,1,1,1,1,1,2,3,0],
		[0,0,3,2,1,1,1,1,1,1,1,1,2,3,0,0],
		[0,0,3,2,1,1,1,1,1,1,1,1,2,3,0,0],
		[0,0,0,3,2,1,1,1,1,1,1,2,3,0,0,0],
		[0,0,0,3,2,1,1,1,1,1,1,2,3,0,0,0],
		[0,0,0,0,3,2,1,1,1,1,2,3,0,0,0,0],
		[0,0,0,0,3,2,1,1,1,1,2,3,0,0,0,0],
		[0,0,0,0,0,3,2,1,1,2,3,0,0,0,0,0],
		[0,0,0,0,0,3,2,1,1,2,3,0,0,0,0,0],
		[0,0,0,0,0,0,3,2,2,3,0,0,0,0,0,0],
	]

	for y in range(h):
		for x in range(w):
			if y < pattern.size() and x < pattern[y].size():
				match pattern[y][x]:
					1:
						img.set_pixel(x, y, fg)
					2:
						img.set_pixel(x, y, outline)
					3:
						img.set_pixel(x, y, glow)

	return img

# ============================================================
# 一次性初始化所有 UI 样式
# ============================================================
static func setup_all_styles(
	status_frame: PanelContainer,
	path_label: Label,
	mail_icon: Label,
	input_frame: PanelContainer,
	input_field: LineEdit,
	output_text: RichTextLabel,
	scroll_container: ScrollContainer = null
) -> void:
	setup_status_frame(status_frame)
	setup_path_label(path_label)
	setup_mail_icon(mail_icon)
	setup_input_frame(input_frame)
	setup_input_field(input_field)
	setup_output_text(output_text)
	if scroll_container != null:
		setup_scroll_container(scroll_container)
```

---

## 第三步：修改 `main.gd` 中的 `_ready()` 函数

只需修改 `_ready()` 函数，在最前面初始化主题，最后设置鼠标和CRT层：

```gdscript
func _ready() -> void:
	# 初始化主题系统（必须最先调用）
	ThemeManager.init("phosphor_green")

	# 初始化打字机模块
	tw = Typewriter.new()
	tw.name = "Typewriter"
	add_child(tw)

	save_mgr.ensure_stories_dir()
	save_mgr.ensure_saves_dir()

	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	# === UI 初始化（全部委托给 UIManager） ===
	background = UIManager.setup_background(self, save_mgr.get_game_root_dir())
	UIManager.setup_main_content(self, $MainContent)
	UIManager.setup_all_styles(status_frame, path_label, mail_icon, input_frame, input_field, output_text, scroll_container)

	# CRT效果层鼠标穿透
	UIManager.setup_crt_effect($CRTEffect)

	# 自定义CRT风格鼠标光标
	UIManager.setup_custom_cursor(self)

	# 连接超链接信号
	output_text.meta_clicked.connect(_on_meta_clicked)

	# 初始化打字机引用
	tw.setup(output_text, scroll_container)

	# 输入框设置
	input_field.focus_mode = Control.FOCUS_ALL
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
	input_field.grab_focus()

	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()
```

---

## 第四步：将 `main.gd` 中所有硬编码颜色替换为主题色

这是改动量最大的部分。以下是 `main.gd` 中**所有需要替换颜色的函数**，我列出需要替换的对照表，以及需要替换的完整函数：

### 颜色对照表

| 旧的硬编码 | 替换为 | 含义 |
|-----------|--------|------|
| `[color=#66FF66]` | `ThemeManager.c_primary(...)` 或 `T.primary_hex` | 主色/标题 |
| `[color=#33FF33]` | `ThemeManager.c_success(...)` 或 `T.success_hex` | 成功 |
| `[color=#FFB000]` | `ThemeManager.c_warning(...)` 或 `T.warning_hex` | 警告/编号 |
| `[color=#FF6666]` | `ThemeManager.c_error(...)` 或 `T.error_hex` | 错误 |
| `[color=#6699FF]` | `ThemeManager.c_info(...)` 或 `T.info_hex` | 信息/目录 |
| `[color=#AAAAAA]` | `ThemeManager.c_muted(...)` 或 `T.muted_hex` | 灰色注释 |

由于函数很多，我给你一个**高效的批量替换方案**。在 `main.gd` 顶部添加一个快捷变量引用，然后用编辑器的查找替换功能：

在 `main.gd` 的变量声明区域（模块实例下方）添加：

```gdscript
# 主题色快捷引用（在 _ready 中初始化）
var T: ThemeManager.ThemeColors = null
```

在 `_ready()` 中 `ThemeManager.init()` 之后添加：

```gdscript
	T = ThemeManager.current
```

然后在编辑器中使用**查找替换**（Ctrl+H），按顺序执行：

| 查找 | 替换为 |
|------|--------|
| `[color=#66FF66]` | `[color=` + T.primary_hex + `]` |

**等等——这样不行**，因为 BBCode 字符串是在运行时拼接的。正确的做法是直接替换十六进制字符串常量。

更实际的方案是：**在每个函数中用变量引用**。以下给出改动最多的几个关键函数的完整替换版本：

### `_cmd_desktop_help`

```gdscript
func _cmd_desktop_help() -> void:
	var p: String = T.primary_hex
	var m: String = T.muted_hex
	var lines: Array[String] = []
	lines.append("[color=" + p + "]═══════════════ 桌面命令 ═══════════════[/color]")
	lines.append("  [color=" + p + "]load <编号>[/color]   加载指定虚拟磁盘")
	lines.append("  [color=" + p + "]scan[/color]   重新扫描vdisc目录")
	lines.append("  [color=" + p + "]vdisc[/color] 查看磁盘列表详情")
	lines.append("  [color=" + p + "]clear[/color] 清空屏幕")
	lines.append("  [color=" + p + "]reboot[/color] 重启终端")
	lines.append("  [color=" + p + "]exit[/color]   退出终端")
	lines.append("[color=" + p + "]═══════════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)
```

### `_cmd_help`

```gdscript
func _cmd_help() -> void:
	var p: String = T.primary_hex
	var m: String = T.muted_hex
	var lines: Array[String] = []
	lines.append("[color=" + p + "]═══════════════════ 可用命令 ═══════════════════[/color]")
	lines.append("  [color=" + p + "]help[/color]          显示本帮助信息")
	lines.append("  [color=" + p + "]ls[/color]            列出当前目录下的文件和文件夹")
	lines.append("  [color=" + p + "]cd <路径>[/color]     切换到指定目录")
	lines.append("  [color=" + p + "]back[/color]          返回上一级目录")
	lines.append("  [color=" + p + "]open <文件>[/color]   打开并显示文件内容")
	lines.append("  [color=" + p + "]clear[/color]         清空屏幕")
	lines.append("  [color=" + p + "]status[/color]        查看当前用户状态")
	lines.append("  [color=" + p + "]mail[/color]          查看收件箱")
	lines.append("  [color=" + p + "]whoami[/color]        查看当前用户信息")
	lines.append("  [color=" + p + "]vdisc[/color]         查看虚拟磁盘列表和信息")
	lines.append("  [color=" + p + "]vdisc load <编号>[/color] 切换加载指定磁盘")
	lines.append("  [color=" + p + "]scan[/color]          重新扫描虚拟磁盘")
	lines.append("  [color=" + p + "]unlock[/color]        进入密码认证（或 unlock <密码>）")
	lines.append("  [color=" + p + "]eject[/color]         卸载磁盘，返回桌面")
	lines.append("  [color=" + p + "]reboot[/color]        重启终端")
	lines.append("  [color=" + p + "]exit[/color]          退出终端")
	lines.append("[color=" + p + "]═══════════════════════════════════════════════[/color]")
	lines.append("[color=" + m + "]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
	append_output("\n".join(lines) + "\n", false)
```

### `_cmd_ls`

```gdscript
func _cmd_ls() -> void:
	var items := fs.get_children_at_path(current_path)
	if items.is_empty():
		append_output("[color=" + T.muted_hex + "]该目录为空。[/color]")
		return
	var lines: Array[String] = []
	lines.append("[color=" + T.primary_hex + "]目录: " + current_path + "[/color]")
	lines.append("")
	for item in items:
		var item_path := fs.join_path(current_path, item)
		var node := fs.get_node_at_path(item_path)
		if node == null:
			continue
		var item_required: int = fs.get_required_clearance(item_path)
		var is_locked: bool = not fs.has_clearance(item_path)
		if node.type == "folder":
			if is_locked:
				lines.append("  [color=" + T.error_hex + "][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
			else:
				lines.append("  [color=" + T.info_hex + "][DIR]  " + item + "/[/color]")
		else:
			if is_locked:
				lines.append("  [color=" + T.error_hex + "][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
			else:
				var fp_key: String = fs.get_file_password_key(item_path)
				if not fp_key.is_empty() and not fs.is_file_password_unlocked(item_path):
					lines.append("  [color=" + T.warning_hex + "][FILE] " + item + "  [PASSWORD][/color]")
				else:
					lines.append("  [color=" + T.success_hex + "][FILE] " + item + "[/color]")
	lines.append("")
	append_output("\n".join(lines) + "\n", false)
```

### 剩余函数的快速替换规则

对于 `main.gd` 中其他所有函数，用编辑器的**查找替换**按以下顺序执行（注意这是**字面替换**）：

```
查找: [color=#33FF33]    替换为: [color=" + T.success_hex + "]
查找: [color=#66FF66]    替换为: [color=" + T.primary_hex + "]
查找: [color=#FFB000]    替换为: [color=" + T.warning_hex + "]
查找: [color=#FF6666]    替换为: [color=" + T.error_hex + "]
查找: [color=#6699FF]    替换为: [color=" + T.info_hex + "]
查找: [color=#AAAAAA]    替换为: [color=" + T.muted_hex + "]
```

**⚠️ 注意**：替换后字符串的引号拼接要正确。替换前的字符串类似：

```gdscript
"  [color=#66FF66]help[/color]"
```

替换后变成：

```gdscript
"  [color=" + T.primary_hex + "]help[/color]"
```

这在 GDScript 的字符串拼接中是合法的。

同时 `file_system.gd` 中的 `build_box` 和 `build_box_sectioned` 函数接收颜色参数，调用处也需要更新，例如：

```gdscript
# 旧的
var box: String = fs.build_box_sectioned([...], "#FF6666")
# 新的
var box: String = fs.build_box_sectioned([...], T.error_hex)

# 旧的
var box: String = fs.build_box_sectioned([...], "#33FF33")
# 新的
var box: String = fs.build_box_sectioned([...], T.success_hex)

# 旧的
var box: String = fs.build_box_sectioned([...], "#FFB000")
# 新的
var box: String = fs.build_box_sectioned([...], T.warning_hex)
```

---

完成以上修改后，将来如果要切换主题，只需要在 `_ready()` 中改一行：

```gdscript
ThemeManager.init("amber")  # 或 "cool_blue"、"white"
```

所有 UI 颜色、鼠标光标颜色都会自动跟随变化。

### USER
我给你目前版本的main.gd，你给我修改完成后的代码。
extends Control
# ============================================================
# 节点引用
# ============================================================
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
var background: TextureRect = null  # 由 UIManager 创建
# 模块实例
var save_mgr: SaveManager = SaveManager.new()
var fs: FileSystem = FileSystem.new()
var tw: Typewriter = null
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
# 桌面/终端模式
var _desktop_mode: bool = true
# ============================================================
# 剧本系统
# ============================================================
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []
var current_story_index: int = -1
var story_id: String = ""
var read_files: Array[String] = []
var unlocked_passwords: Array[String] = []
# 密码输入弹窗状态
var _password_mode: bool = false
var _password_target_path: String = ""
# 文件密码系统
var _file_password_mode: bool = false
var _file_password_target: String = ""
var _file_password_filename: String = ""
# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
# 初始化主题系统（必须最先调用）
ThemeManager.init("phosphor_green")
# 初始化打字机模块
tw = Typewriter.new()
tw.name = "Typewriter"
add_child(tw)
save_mgr.ensure_stories_dir()
save_mgr.ensure_saves_dir()
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# === UI 初始化（全部委托给 UIManager） ===
background = UIManager.setup_background(self, save_mgr.get_game_root_dir())
UIManager.setup_main_content(self, $MainContent)
UIManager.setup_all_styles(status_frame, path_label, mail_icon, input_frame, input_field, output_text, scroll_container)
# CRT效果层鼠标穿透
UIManager.setup_crt_effect($CRTEffect)
# 自定义CRT风格鼠标光标
UIManager.setup_custom_cursor(self)
# 连接超链接信号
output_text.meta_clicked.connect(_on_meta_clicked)
# 初始化打字机引用
tw.setup(output_text, scroll_container)
# 输入框设置
input_field.focus_mode = Control.FOCUS_ALL
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
input_field.grab_focus()
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 输入处理
# ============================================================
func _input(event: InputEvent) -> void:
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
# 判断鼠标是否点击在输出区域内
var mouse_pos: Vector2 = event.position
var output_rect: Rect2 = output_text.get_global_rect()
if output_rect.has_point(mouse_pos):
# 点击在输出区域内，不抢焦点，让 RichTextLabel 处理选中
return
# 点击在输出区域外，聚焦输入框
input_field.grab_focus()
return
# 鼠标释放时，如果不在输出区，重新聚焦输入框
if event is InputEventMouseButton and not event.pressed:
if event.button_index == MOUSE_BUTTON_LEFT:
var mouse_pos: Vector2 = event.position
var output_rect: Rect2 = output_text.get_global_rect()
if not output_rect.has_point(mouse_pos):
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
if not input_field.has_focus():
input_field.grab_focus()
if tw.is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
tw.skip()
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
if tw.is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
if _file_password_mode:
_file_password_mode = false
input_field.placeholder_text = "> 输入命令..."
while tw.is_typing:
await get_tree().process_frame
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消文件密码输入。[/color]\n", false)
_file_password_target = ""
_file_password_filename = ""
return
await _verify_file_password(raw_input)
return
if _password_mode:
_password_mode = false
input_field.placeholder_text = "> 输入命令..."
while tw.is_typing:
await get_tree().process_frame
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=#AAAAAA]已取消密码输入。[/color]\n", false)
return
_verify_password(raw_input)
return
command_history.append(raw_input)
history_index = -1
while tw.is_typing:
await get_tree().process_frame
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
tw.instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
if _desktop_mode:
match command:
"load":
await _cmd_desktop_load(args)
"scan":
await _cmd_scan()
"clear", "cls":
_cmd_clear()
"exit", "quit":
await _cmd_exit()
"help", "?":
_cmd_desktop_help()
"vdisc", "disc", "disk":
_cmd_story_info()
"reboot", "restart":
await _cmd_reboot()
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n[color=#AAAAAA]输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n", false)
return
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
if args.size() >= 1 and args[0].to_lower() == "load":
await _cmd_vdisc_load(args.slice(1))
else:
_cmd_story_info()
"unlock":
_cmd_unlock(args)
"scan":
await _cmd_scan()
"reboot", "restart":
await _cmd_reboot()
"eject":
await _cmd_eject()
"load":
append_output("[color=#AAAAAA]磁盘已加载。使用 [/color][color=#66FF66]eject[/color][color=#AAAAAA] 返回桌面后再切换磁盘，或使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 直接切换。[/color]\n", false)
_:
append_output("[color=#FF6666][ERROR] 未知指令: " + command + "[/color]\n输入 [color=#66FF66]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_desktop_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 桌面命令 ═══════════════[/color]")
lines.append("  [color=#66FF66]load <编号>[/color]   加载指定虚拟磁盘")
lines.append("  [color=#66FF66]scan[/color]   重新扫描vdisc目录")
lines.append("  [color=#66FF66]vdisc[/color] 查看磁盘列表详情")
lines.append("  [color=#66FF66]clear[/color] 清空屏幕")
lines.append("  [color=#66FF66]reboot[/color] 重启终端")
lines.append("  [color=#66FF66]exit[/color]   退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_help() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=#66FF66]help[/color]          显示本帮助信息")
lines.append("  [color=#66FF66]ls[/color]            列出当前目录下的文件和文件夹")
lines.append("  [color=#66FF66]cd <路径>[/color]     切换到指定目录")
lines.append("  [color=#66FF66]back[/color]          返回上一级目录")
lines.append("  [color=#66FF66]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=#66FF66]clear[/color]         清空屏幕")
lines.append("  [color=#66FF66]status[/color]        查看当前用户状态")
lines.append("  [color=#66FF66]mail[/color]          查看收件箱")
lines.append("  [color=#66FF66]whoami[/color]        查看当前用户信息")
lines.append("  [color=#66FF66]vdisc[/color]         查看虚拟磁盘列表和信息")
lines.append("  [color=#66FF66]vdisc load <编号>[/color] 切换加载指定磁盘")
lines.append("  [color=#66FF66]scan[/color]          重新扫描虚拟磁盘")
lines.append("  [color=#66FF66]unlock[/color]        进入密码认证（或 unlock <密码>）")
lines.append("  [color=#66FF66]eject[/color]         卸载磁盘，返回桌面")
lines.append("  [color=#66FF66]reboot[/color]        重启终端")
lines.append("  [color=#66FF66]exit[/color]          退出终端")
lines.append("[color=#66FF66]═══════════════════════════════════════════════[/color]")
lines.append("[color=#AAAAAA]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := fs.get_children_at_path(current_path)
if items.is_empty():
append_output("[color=#AAAAAA]该目录为空。[/color]")
return
var lines: Array[String] = []
lines.append("[color=#66FF66]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := fs.join_path(current_path, item)
var node := fs.get_node_at_path(item_path)
if node == null:
continue
var item_required: int = fs.get_required_clearance(item_path)
var is_locked: bool = not fs.has_clearance(item_path)
if node.type == "folder":
if is_locked:
lines.append("  [color=#FF6666][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
else:
lines.append("  [color=#6699FF][DIR]  " + item + "/[/color]")
else:
if is_locked:
lines.append("  [color=#FF6666][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
else:
var fp_key: String = fs.get_file_password_key(item_path)
if not fp_key.is_empty() and not fs.is_file_password_unlocked(item_path):
lines.append("  [color=#FFB000][FILE] " + item + "  [PASSWORD][/color]")
else:
lines.append("  [color=#33FF33][FILE] " + item + "[/color]")
lines.append("")
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = fs.get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = fs.join_path(current_path, target)
new_path = fs.normalize_path(new_path)
var node := fs.get_node_at_path(new_path)
if node == null:
append_output("[color=#FF6666][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
append_output("[color=#FF6666][ERROR] " + target + " 不是一个目录。[/color]")
return
var required: int = fs.get_required_clearance(new_path)
if not fs.has_clearance(new_path):
var box: String = fs.build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = fs.join_path(current_path, filename)
file_path = fs.normalize_path(file_path)
var node := fs.get_node_at_path(file_path)
if node == null:
append_output("[color=#FF6666][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
append_output("[color=#FF6666][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
var required: int = fs.get_required_clearance(file_path)
if not fs.has_clearance(file_path):
var box: String = fs.build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
["输入 unlock 尝试密码认证"]
], "#FF6666")
append_output(box + "\n", false)
return
var fp_key: String = fs.get_file_password_key(file_path)
if not fp_key.is_empty() and not fs.is_file_password_unlocked(file_path):
var fp_info: Dictionary = fs.story_file_passwords[fp_key]
var hint_text: String = fp_info.get("hint", "")
var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
if not hint_text.is_empty():
box_lines.append(["提示: " + hint_text])
box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
var box: String = fs.build_box_sectioned(box_lines, "#FFB000")
append_output(box + "\n", false)
_file_password_mode = true
_file_password_target = file_path
_file_password_filename = filename
input_field.placeholder_text = "输入文件密码..."
return
while tw.is_typing:
await get_tree().process_frame
var content_size: int = node.content.length()
await tw.show_progress_bar(content_size)
await get_tree().create_timer(0.5).timeout
output_text.text = ""
tw.clear_queue()
var header: String = "[color=#66FF66]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
if not read_files.has(file_path):
read_files.append(file_path)
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
var clean_content: String = node.content.strip_edges()
clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
append_output(clean_content, false)
append_output("\n[color=#66FF66]══════════ 文件结束 ══════════[/color]\n[color=#AAAAAA]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=#AAAAAA]已经在根目录了。[/color]")
return
current_path = fs.get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
tw.clear_queue()
func _cmd_status() -> void:
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名: [color=#66FF66]未登录[/color]")
lines.append("  权限等级:   [color=#FFB000]" + str(fs.player_clearance) + "[/color]")
lines.append("  当前路径:   [color=#66FF66]" + current_path + "[/color]")
lines.append("  已读文件:   [color=#66FF66]" + str(read_files.size()) + "[/color]")
lines.append("  已获取密码: [color=#66FF66]" + str(unlocked_passwords.size()) + "[/color]")
lines.append("  已解锁文件: [color=#66FF66]" + str(fs.unlocked_file_passwords.size()) + "[/color]")
if not story_id.is_empty():
lines.append("  盘ID: [color=#AAAAAA]" + story_id + "[/color]")
lines.append("[color=#66FF66]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=#AAAAAA]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=#AAAAAA]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=#66FF66]未登录用户[/color]\n[color=#AAAAAA](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
if story_manifest.is_empty() and available_stories.is_empty():
append_output("[color=#AAAAAA]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=#66FF66]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")
if available_stories.size() > 0:
lines.append("")
lines.append("  已发现 [color=#66FF66]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
var marker: String = ""
if i == current_story_index:
marker = " [color=#33FF33]<< 当前[/color]"
lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]" + marker)
lines.append("     作者: [color=#AAAAAA]" + info.get("author", "未知") + "[/color]")
lines.append("")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]vdisc load <编号>[/color][color=#AAAAAA] 切换磁盘[/color]")
lines.append("[color=#AAAAAA]  使用 [/color][color=#66FF66]scan[/color][color=#AAAAAA] 重新扫描目录[/color]")
if story_manifest.has("story"):
lines.append("")
lines.append("[color=#66FF66]─────────── 当前磁盘详情 ───────────[/color]")
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签: [color=#66FF66]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者:   [color=#66FF66]" + info.get("author", "未知") + "[/color]")
lines.append("  版本: [color=#66FF66]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述: [color=#AAAAAA]" + info["description"] + "[/color]")
lines.append("  文件总数: [color=#66FF66]" + str(fs.file_system.size()) + "[/color]")
lines.append("  磁盘来源: [color=#AAAAAA]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态: [color=#33FF33]已挂载[/color]")
lines.append("[color=#66FF66]═══════════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_vdisc_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: vdisc load <编号>[/color]\n[color=#AAAAAA]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
if index == current_story_index:
append_output("[color=#AAAAAA]该磁盘已经是当前加载的磁盘。[/color]\n", false)
return
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
append_output("[color=#AAAAAA]正在卸载当前磁盘...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.3).timeout
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
read_files.clear()
unlocked_passwords.clear()
await tw.show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
if _load_story_by_index(index):
var title: String = available_stories[index].get("title", "未知")
var box: String = fs.build_box_sectioned([
["DISC LOADED", "磁盘加载完成"],
[title]
], "#33FF33")
append_output(box + "\n", false)
_update_status_bar()
append_output("[color=#AAAAAA]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
append_output("[color=#AAAAAA]当前路径: " + current_path + "  权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
fs.init_test_file_system()
_update_status_bar()
func _cmd_unlock(args: Array) -> void:
if not args.is_empty():
_verify_password(args[0])
return
_enter_password_mode()
func _enter_password_mode(target_path: String = "") -> void:
_password_mode = true
_password_target_path = target_path
var box: String = fs.build_box_sectioned([
["SECURITY AUTHENTICATION", "安全认证系统"],
["请输入访问密码:", "(输入 cancel 取消)"]
], "#FFB000")
append_output(box + "\n", false)
input_field.placeholder_text = "输入密码..."
func _verify_password(password: String) -> void:
if not story_manifest.has("passwords"):
append_output("[color=#FF6666][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
return
var passwords: Dictionary = story_manifest["passwords"]
if passwords.has(password):
var pwd_info: Dictionary = passwords[password]
var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
if unlocked_passwords.has(password):
append_output("[color=#AAAAAA]该密码已使用过。当前权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
return
if grant_level <= fs.player_clearance:
append_output("[color=#AAAAAA]该密码对应的权限等级不高于当前等级。当前: " + str(fs.player_clearance) + "[/color]\n", false)
return
unlocked_passwords.append(password)
var old_level: int = fs.player_clearance
fs.player_clearance = grant_level
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
var box: String = fs.build_box_sectioned([
["ACCESS GRANTED", "权限认证通过"],
["权限等级: " + str(old_level) + " -> " + str(fs.player_clearance)]
], "#33FF33")
append_output(box + "\n", false)
if pwd_info.has("message"):
append_output("[color=#AAAAAA]" + str(pwd_info["message"]) + "[/color]\n", false)
else:
var box: String = fs.build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _verify_file_password(input_password: String) -> void:
var fp_key: String = fs.get_file_password_key(_file_password_target)
if fp_key.is_empty():
append_output("[color=#FF6666][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
return
var fp_info: Dictionary = fs.story_file_passwords[fp_key]
var correct_password: String = str(fp_info.get("password", ""))
if input_password == correct_password:
fs.unlocked_file_passwords.append(_file_password_target)
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
var box: String = fs.build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], "#33FF33")
append_output(box + "\n", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
await _cmd_open([_file_password_filename])
else:
var box: String = fs.build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], "#FF6666")
append_output(box + "\n", false)
func _cmd_scan() -> void:
append_output("[color=#AAAAAA]正在扫描vdisc目录...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await tw.show_progress_bar(500)
await get_tree().create_timer(0.3).timeout
var old_story_path: String = current_story_path
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
read_files.clear()
unlocked_passwords.clear()
available_stories.clear()
current_story_index = -1
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
if _desktop_mode:
if available_stories.is_empty():
append_output("[color=#FFB000][WARN] 未找到虚拟磁盘文件。[/color]", false)
append_output("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
else:
var scan_lines: Array[String] = []
scan_lines.append("[color=#33FF33][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
scan_lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
scan_lines.append("  [color=#FFB000]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=#AAAAAA](" + info.get("filename", "") + ")[/color]")
scan_lines.append("")
scan_lines.append("[color=#AAAAAA]输入 [/color][color=#66FF66]load <编号>[/color][color=#AAAAAA] 加载磁盘。[/color]")
append_output("\n".join(scan_lines) + "\n", false)
_update_status_bar()
else:
if available_stories.is_empty():
_desktop_mode = true
fs.init_test_file_system()
current_path = "/"
_update_status_bar()
append_output("[color=#FFB000][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
elif _load_story_by_index(0):
var title: String = "未知"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
append_output("[color=#33FF33][OK] 已重新加载剧本: " + title + "[/color]", false)
append_output("[color=#AAAAAA]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
else:
current_path = "/"
_update_status_bar()
else:
append_output("[color=#FF6666][ERROR] 重新加载失败。[/color]\n", false)
func _cmd_reboot() -> void:
append_output("[color=#AAAAAA]正在重启终端...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
output_text.text = ""
tw.clear_queue()
command_history.clear()
history_index = -1
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
has_new_mail = false
read_files.clear()
unlocked_passwords.clear()
available_stories.clear()
current_story_index = -1
save_mgr.ensure_stories_dir()
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
output_text.append_text("[color=#AAAAAA]...[/color]\n")
await get_tree().create_timer(0.3).timeout
output_text.append_text("[color=#AAAAAA]终端系统重新初始化中...[/color]\n")
await get_tree().create_timer(0.5).timeout
output_text.text = ""
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
input_field.grab_focus()
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
if parts.size() == 1:
if current_text.ends_with(" "):
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := fs.get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := fs.join_path(current_path, child)
var node := fs.get_node_at_path(child_path)
if node == null:
continue
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(display) + "[/color]")
tw._do_scroll()
else:
var partial_cmd: String = parts[0].to_lower()
var commands: Array
if _desktop_mode:
commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
else:
commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
"scan", "reboot", "restart", "unlock", "eject"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=#AAAAAA]可选命令: " + " | ".join(matches) + "[/color]")
tw._do_scroll()
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := fs.get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := fs.join_path(current_path, child)
var node := fs.get_node_at_path(child_path)
if node == null:
continue
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=#AAAAAA]可选项: " + " | ".join(matches) + "[/color]")
tw._do_scroll()
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具（转发到打字机模块）
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
tw.append(text, extra_newline)
# ============================================================
# 每帧处理（滚动）
# ============================================================
func _process(_delta: float) -> void:
tw.process_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
if _desktop_mode:
path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
mail_icon.text = "[Mail]"
return
var disc_name: String = ""
if current_story_index >= 0 and current_story_index < available_stories.size():
disc_name = available_stories[current_story_index].get("title", "")
if disc_name.is_empty():
path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance)
else:
path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance) + "  DISC:" + disc_name
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
var box: String = fs.build_box([title, subtitle] as Array[String], "#66FF66")
output_text.append_text(box + "\n\n")
if available_stories.is_empty():
output_text.append_text("[color=#FFB000]未检测到虚拟磁盘。[/color]\n")
output_text.append_text("[color=#AAAAAA]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
else:
output_text.append_text("[color=#66FF66]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
output_text.append_text("  [color=#FFB000]" + str(i + 1) + ".[/color] [color=#66FF66]" + info.get("title", "未知") + "[/color]\n")
output_text.append_text("     [color=#AAAAAA]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
output_text.append_text("\n")
output_text.append_text("[color=#AAAAAA]可用命令:[/color]\n")
output_text.append_text("  [color=#66FF66]load <编号>[/color]   加载指定磁盘\n")
output_text.append_text("  [color=#66FF66]scan[/color]   重新扫描磁盘目录\n")
output_text.append_text("  [color=#66FF66]clear[/color] 清空屏幕\n")
output_text.append_text("  [color=#66FF66]exit[/color]   退出终端\n")
func _cmd_desktop_load(args: Array) -> void:
if args.is_empty():
append_output("[color=#FF6666][ERROR] 用法: load <编号>[/color]", false)
if available_stories.size() > 0:
append_output("[color=#AAAAAA]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=#FF6666][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1
if index < 0 or index >= available_stories.size():
append_output("[color=#FF6666][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
append_output("[color=#AAAAAA]正在加载虚拟磁盘...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await tw.show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
if _load_story_by_index(index):
_desktop_mode = false
var title: String = available_stories[index].get("title", "未知")
output_text.text = ""
tw.clear_queue()
_update_status_bar()
_show_welcome_message()
else:
append_output("[color=#FF6666][ERROR] 磁盘加载失败。[/color]\n", false)
func _cmd_eject() -> void:
if _desktop_mode:
append_output("[color=#AAAAAA]当前已在桌面模式。[/color]\n", false)
return
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
append_output("[color=#AAAAAA]正在卸载磁盘...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
read_files.clear()
unlocked_passwords.clear()
current_story_index = -1
_desktop_mode = true
output_text.text = ""
tw.clear_queue()
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
var title_display_len: int = fs.display_width(title)
var subtitle_display_len: int = fs.display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=#66FF66]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=#AAAAAA]终端系统已启动。\n"
welcome += "输入 [/color][color=#66FF66]help[/color][color=#AAAAAA] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# ============================================================
# 剧本加载系统
# ============================================================
func _try_load_story() -> bool:
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
print("[StoryLoader] 搜索目录: " + vdisc_dir)
_scan_available_stories(vdisc_dir)
return not available_stories.is_empty()
func _scan_available_stories(vdisc_dir: String) -> void:
available_stories.clear()
if not DirAccess.dir_exists_absolute(vdisc_dir):
return
var dir := DirAccess.open(vdisc_dir)
if dir == null:
return
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = vdisc_dir + file_name
var info: Dictionary = _peek_story_info(full_path)
info["path"] = full_path
info["filename"] = file_name
available_stories.append(info)
print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
file_name = dir.get_next()
print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")
func _peek_story_info(path: String) -> Dictionary:
var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}
var reader := ZIPReader.new()
if reader.open(path) != OK:
return info
var files := reader.get_files()
for file_path in files:
var filename: String = file_path.get_file()
if filename == "manifest.json":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
var json := JSON.new()
if json.parse(content) == OK and json.data is Dictionary:
var data: Dictionary = json.data
if data.has("story"):
var story_info: Dictionary = data["story"]
info["title"] = story_info.get("title", "未知剧本")
info["id"] = story_info.get("id", "")
info["author"] = story_info.get("author", "未知")
break
elif filename == "manifest.cfg":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
for line in content.split("\n"):
line = line.strip_edges()
if line.begins_with("title="):
info["title"] = line.substr(6).strip_edges()
elif line.begins_with("id="):
info["id"] = line.substr(3).strip_edges()
elif line.begins_with("author="):
info["author"] = line.substr(7).strip_edges()
break
reader.close()
return info
func _load_story_by_index(index: int) -> bool:
if index < 0 or index >= available_stories.size():
return false
var story_info: Dictionary = available_stories[index]
var path: String = story_info["path"]
if _load_story_file(path):
current_story_index = index
return true
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
# 应用加载的数据到 fs 模块
fs.file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
# 读取盘ID
if story_manifest.has("story") and story_manifest["story"].has("id"):
story_id = story_manifest["story"]["id"]
else:
story_id = str(path.get_file().hash())
# 读取权限表
fs.story_permissions.clear()
if story_manifest.has("permissions"):
var perms: Dictionary = story_manifest["permissions"]
for perm_path in perms.keys():
fs.story_permissions[perm_path] = int(perms[perm_path])
print("[StoryLoader] 权限表已加载，共 " + str(fs.story_permissions.size()) + " 条规则")
else:
print("[StoryLoader] 警告: manifest中未找到permissions字段")
if story_manifest.has("passwords"):
print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
else:
print("[StoryLoader] 警告: manifest中未找到passwords字段")
# 读取文件密码表
fs.story_file_passwords.clear()
if story_manifest.has("file_passwords"):
var fps: Dictionary = story_manifest["file_passwords"]
for fp_path in fps.keys():
fs.story_file_passwords[fp_path] = fps[fp_path]
print("[StoryLoader] 文件密码表已加载，共 " + str(fs.story_file_passwords.size()) + " 条")
else:
print("[StoryLoader] 未配置文件密码表（file_passwords）")
# 应用 manifest 中的设置
var start_clearance: int = 0
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
tw.base_speed = settings["typing_speed"].to_float()
if settings.has("start_clearance"):
start_clearance = int(settings["start_clearance"])
# 尝试加载该剧本的存档
var save_data = save_mgr.load_save(story_id)
if save_data != null:
fs.player_clearance = int(save_data.get("player_clearance", 0))
read_files.clear()
if save_data.has("read_files"):
for f in save_data["read_files"]:
read_files.append(str(f))
unlocked_passwords.clear()
if save_data.has("unlocked_passwords"):
for p in save_data["unlocked_passwords"]:
unlocked_passwords.append(str(p))
fs.unlocked_file_passwords.clear()
if save_data.has("unlocked_file_passwords"):
for p in save_data["unlocked_file_passwords"]:
fs.unlocked_file_passwords.append(str(p))
if save_data.has("current_path"):
var saved_path: String = save_data["current_path"]
if fs.has_clearance(saved_path):
current_path = saved_path
else:
current_path = "/"
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
print("[Save] 权限等级: " + str(fs.player_clearance))
else:
# 没有存档，用初始权限
fs.player_clearance = start_clearance
read_files.clear()
unlocked_passwords.clear()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 盘ID: " + story_id)
print("[StoryLoader] 文件数量: " + str(fs.file_system.size()))
print("[StoryLoader] 权限等级: " + str(fs.player_clearance))
print("[StoryLoader] story_permissions 内容: " + str(fs.story_permissions))
print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
return true

### ASSISTANT
以下是修改完成后的 `main.gd`，所有硬编码颜色已替换为 `ThemeManager` 主题色引用：

```gdscript
extends Control
# ============================================================
# 节点引用
# ============================================================
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
var background: TextureRect = null  # 由 UIManager 创建

# 模块实例
var save_mgr: SaveManager = SaveManager.new()
var fs: FileSystem = FileSystem.new()
var tw: Typewriter = null

# 主题色快捷引用（在 _ready 中初始化）
var T: ThemeManager.ThemeColors = null

# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""

# 桌面/终端模式
var _desktop_mode: bool = true

# ============================================================
# 剧本系统
# ============================================================
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []
var current_story_index: int = -1
var story_id: String = ""
var read_files: Array[String] = []
var unlocked_passwords: Array[String] = []

# 密码输入弹窗状态
var _password_mode: bool = false
var _password_target_path: String = ""

# 文件密码系统
var _file_password_mode: bool = false
var _file_password_target: String = ""
var _file_password_filename: String = ""

# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
	# 初始化主题系统（必须最先调用）
	ThemeManager.init("phosphor_green")
	T = ThemeManager.current

	# 初始化打字机模块
	tw = Typewriter.new()
	tw.name = "Typewriter"
	add_child(tw)

	save_mgr.ensure_stories_dir()
	save_mgr.ensure_saves_dir()

	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	# === UI 初始化（全部委托给 UIManager） ===
	background = UIManager.setup_background(self, save_mgr.get_game_root_dir())
	UIManager.setup_main_content(self, $MainContent)
	UIManager.setup_all_styles(status_frame, path_label, mail_icon, input_frame, input_field, output_text, scroll_container)

	# CRT效果层鼠标穿透
	UIManager.setup_crt_effect($CRTEffect)

	# 自定义CRT风格鼠标光标
	UIManager.setup_custom_cursor(self)

	# 连接超链接信号
	output_text.meta_clicked.connect(_on_meta_clicked)

	# 初始化打字机引用
	tw.setup(output_text, scroll_container)

	# 输入框设置
	input_field.focus_mode = Control.FOCUS_ALL
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
	input_field.grab_focus()

	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()

# ============================================================
# 输入处理
# ============================================================
func _input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		match event.button_index:
			MOUSE_BUTTON_WHEEL_UP:
				scroll_container.scroll_vertical -= 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_WHEEL_DOWN:
				scroll_container.scroll_vertical += 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_LEFT:
				var mouse_pos: Vector2 = event.position
				var output_rect: Rect2 = output_text.get_global_rect()
				if output_rect.has_point(mouse_pos):
					return
				input_field.grab_focus()
				return

	if event is InputEventMouseButton and not event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			var mouse_pos: Vector2 = event.position
			var output_rect: Rect2 = output_text.get_global_rect()
			if not output_rect.has_point(mouse_pos):
				input_field.grab_focus()
			return

	if not event is InputEventKey or not event.pressed:
		return

	if not input_field.has_focus():
		input_field.grab_focus()

	if tw.is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
		tw.skip()
		get_viewport().set_input_as_handled()
		return

	match event.keycode:
		KEY_ENTER, KEY_KP_ENTER:
			if tw.is_typing:
				get_viewport().set_input_as_handled()
			else:
				var command_text: String = input_field.text
				input_field.clear()
				_on_command_submitted(command_text)
				get_viewport().set_input_as_handled()
		KEY_UP:
			_history_previous()
			get_viewport().set_input_as_handled()
		KEY_DOWN:
			_history_next()
			get_viewport().set_input_as_handled()
		KEY_PAGEUP:
			scroll_container.scroll_vertical -= 100
			get_viewport().set_input_as_handled()
		KEY_PAGEDOWN:
			scroll_container.scroll_vertical += 100
			get_viewport().set_input_as_handled()
		KEY_TAB:
			_auto_complete()
			get_viewport().set_input_as_handled()

# ============================================================
# 命令提交处理
# ============================================================
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	input_field.clear()

	if raw_input.is_empty():
		return

	if _file_password_mode:
		_file_password_mode = false
		input_field.placeholder_text = "> 输入命令..."
		while tw.is_typing:
			await get_tree().process_frame
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
		if raw_input.to_lower() == "cancel":
			append_output("[color=" + T.muted_hex + "]已取消文件密码输入。[/color]\n", false)
			_file_password_target = ""
			_file_password_filename = ""
			return
		await _verify_file_password(raw_input)
		return

	if _password_mode:
		_password_mode = false
		input_field.placeholder_text = "> 输入命令..."
		while tw.is_typing:
			await get_tree().process_frame
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
		if raw_input.to_lower() == "cancel":
			append_output("[color=" + T.muted_hex + "]已取消密码输入。[/color]\n", false)
			return
		_verify_password(raw_input)
		return

	command_history.append(raw_input)
	history_index = -1

	while tw.is_typing:
		await get_tree().process_frame

	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text("> " + raw_input + "\n")

	await _execute_command(raw_input)

# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
	tw.instant = false
	var parts := raw_input.split(" ", false)
	if parts.is_empty():
		return

	var command: String = parts[0].to_lower()
	var args := parts.slice(1)

	if _desktop_mode:
		match command:
			"load":
				await _cmd_desktop_load(args)
			"scan":
				await _cmd_scan()
			"clear", "cls":
				_cmd_clear()
			"exit", "quit":
				await _cmd_exit()
			"help", "?":
				_cmd_desktop_help()
			"vdisc", "disc", "disk":
				_cmd_story_info()
			"reboot", "restart":
				await _cmd_reboot()
			_:
				append_output("[color=" + T.error_hex + "][ERROR] 未知指令: " + command + "[/color]\n[color=" + T.muted_hex + "]输入 [/color][color=" + T.primary_hex + "]help[/color][color=" + T.muted_hex + "] 查看可用命令。[/color]\n", false)
		return

	match command:
		"help", "?":
			_cmd_help()
		"ls", "dir":
			_cmd_ls()
		"cd":
			_cmd_cd(args)
		"open", "cat":
			await _cmd_open(args)
		"back":
			_cmd_back()
		"clear", "cls":
			_cmd_clear()
		"status":
			_cmd_status()
		"mail":
			_cmd_mail(args)
		"exit", "quit":
			await _cmd_exit()
		"whoami":
			_cmd_whoami()
		"vdisc", "disc", "disk":
			if args.size() >= 1 and args[0].to_lower() == "load":
				await _cmd_vdisc_load(args.slice(1))
			else:
				_cmd_story_info()
		"unlock":
			_cmd_unlock(args)
		"scan":
			await _cmd_scan()
		"reboot", "restart":
			await _cmd_reboot()
		"eject":
			await _cmd_eject()
		"load":
			append_output("[color=" + T.muted_hex + "]磁盘已加载。使用 [/color][color=" + T.primary_hex + "]eject[/color][color=" + T.muted_hex + "] 返回桌面后再切换磁盘，或使用 [/color][color=" + T.primary_hex + "]vdisc load <编号>[/color][color=" + T.muted_hex + "] 直接切换。[/color]\n", false)
		_:
			append_output("[color=" + T.error_hex + "][ERROR] 未知指令: " + command + "[/color]\n输入 [color=" + T.primary_hex + "]help[/color] 查看可用命令。\n", false)

# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_desktop_help() -> void:
	var p: String = T.primary_hex
	var lines: Array[String] = []
	lines.append("[color=" + p + "]═══════════════ 桌面命令 ═══════════════[/color]")
	lines.append("  [color=" + p + "]load <编号>[/color]   加载指定虚拟磁盘")
	lines.append("  [color=" + p + "]scan[/color]   重新扫描vdisc目录")
	lines.append("  [color=" + p + "]vdisc[/color] 查看磁盘列表详情")
	lines.append("  [color=" + p + "]clear[/color] 清空屏幕")
	lines.append("  [color=" + p + "]reboot[/color] 重启终端")
	lines.append("  [color=" + p + "]exit[/color]   退出终端")
	lines.append("[color=" + p + "]═══════════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_help() -> void:
	var p: String = T.primary_hex
	var m: String = T.muted_hex
	var lines: Array[String] = []
	lines.append("[color=" + p + "]═══════════════════ 可用命令 ═══════════════════[/color]")
	lines.append("  [color=" + p + "]help[/color]          显示本帮助信息")
	lines.append("  [color=" + p + "]ls[/color]            列出当前目录下的文件和文件夹")
	lines.append("  [color=" + p + "]cd <路径>[/color]     切换到指定目录")
	lines.append("  [color=" + p + "]back[/color]          返回上一级目录")
	lines.append("  [color=" + p + "]open <文件>[/color]   打开并显示文件内容")
	lines.append("  [color=" + p + "]clear[/color]         清空屏幕")
	lines.append("  [color=" + p + "]status[/color]        查看当前用户状态")
	lines.append("  [color=" + p + "]mail[/color]          查看收件箱")
	lines.append("  [color=" + p + "]whoami[/color]        查看当前用户信息")
	lines.append("  [color=" + p + "]vdisc[/color]         查看虚拟磁盘列表和信息")
	lines.append("  [color=" + p + "]vdisc load <编号>[/color] 切换加载指定磁盘")
	lines.append("  [color=" + p + "]scan[/color]          重新扫描虚拟磁盘")
	lines.append("  [color=" + p + "]unlock[/color]        进入密码认证（或 unlock <密码>）")
	lines.append("  [color=" + p + "]eject[/color]         卸载磁盘，返回桌面")
	lines.append("  [color=" + p + "]reboot[/color]        重启终端")
	lines.append("  [color=" + p + "]exit[/color]          退出终端")
	lines.append("[color=" + p + "]═══════════════════════════════════════════════[/color]")
	lines.append("[color=" + m + "]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_ls() -> void:
	var items := fs.get_children_at_path(current_path)
	if items.is_empty():
		append_output("[color=" + T.muted_hex + "]该目录为空。[/color]")
		return

	var lines: Array[String] = []
	lines.append("[color=" + T.primary_hex + "]目录: " + current_path + "[/color]")
	lines.append("")

	for item in items:
		var item_path := fs.join_path(current_path, item)
		var node := fs.get_node_at_path(item_path)
		if node == null:
			continue
		var item_required: int = fs.get_required_clearance(item_path)
		var is_locked: bool = not fs.has_clearance(item_path)
		if node.type == "folder":
			if is_locked:
				lines.append("  [color=" + T.error_hex + "][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
			else:
				lines.append("  [color=" + T.info_hex + "][DIR]  " + item + "/[/color]")
		else:
			if is_locked:
				lines.append("  [color=" + T.error_hex + "][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
			else:
				var fp_key: String = fs.get_file_password_key(item_path)
				if not fp_key.is_empty() and not fs.is_file_password_unlocked(item_path):
					lines.append("  [color=" + T.warning_hex + "][FILE] " + item + "  [PASSWORD][/color]")
				else:
					lines.append("  [color=" + T.success_hex + "][FILE] " + item + "[/color]")
	lines.append("")
	append_output("\n".join(lines) + "\n", false)

func _cmd_cd(args: Array) -> void:
	if args.is_empty():
		append_output("[color=" + T.error_hex + "][ERROR] 用法: cd <目录名>[/color]")
		return

	var target: String = args[0]
	var new_path: String
	if target == "/":
		new_path = "/"
	elif target == "..":
		new_path = fs.get_parent_path(current_path)
	elif target.begins_with("/"):
		new_path = target
	else:
		new_path = fs.join_path(current_path, target)
	new_path = fs.normalize_path(new_path)

	var node := fs.get_node_at_path(new_path)
	if node == null:
		append_output("[color=" + T.error_hex + "][ERROR] 目录不存在: " + target + "[/color]")
		return
	if node.type != "folder":
		append_output("[color=" + T.error_hex + "][ERROR] " + target + " 不是一个目录。[/color]")
		return

	var required: int = fs.get_required_clearance(new_path)
	if not fs.has_clearance(new_path):
		var box: String = fs.build_box_sectioned([
			["ACCESS DENIED", "权限不足"],
			["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
			["输入 unlock 尝试密码认证"]
		], T.error_hex)
		append_output(box + "\n", false)
		return

	current_path = new_path
	_update_status_bar()
	append_output("已切换到: " + current_path + "\n", false)

func _cmd_open(args: Array) -> void:
	if args.is_empty():
		append_output("[color=" + T.error_hex + "][ERROR] 用法: open <文件名>[/color]")
		return

	var filename: String = args[0]
	var file_path: String
	if filename.begins_with("/"):
		file_path = filename
	else:
		file_path = fs.join_path(current_path, filename)
	file_path = fs.normalize_path(file_path)

	var node := fs.get_node_at_path(file_path)
	if node == null:
		append_output("[color=" + T.error_hex + "][ERROR] 文件不存在: " + filename + "[/color]")
		return
	if node.type != "file":
		append_output("[color=" + T.error_hex + "][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
		return

	var required: int = fs.get_required_clearance(file_path)
	if not fs.has_clearance(file_path):
		var box: String = fs.build_box_sectioned([
			["ACCESS DENIED", "权限不足"],
			["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
			["输入 unlock 尝试密码认证"]
		], T.error_hex)
		append_output(box + "\n", false)
		return

	var fp_key: String = fs.get_file_password_key(file_path)
	if not fp_key.is_empty() and not fs.is_file_password_unlocked(file_path):
		var fp_info: Dictionary = fs.story_file_passwords[fp_key]
		var hint_text: String = fp_info.get("hint", "")
		var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
		if not hint_text.is_empty():
			box_lines.append(["提示: " + hint_text])
		box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
		var box: String = fs.build_box_sectioned(box_lines, T.warning_hex)
		append_output(box + "\n", false)
		_file_password_mode = true
		_file_password_target = file_path
		_file_password_filename = filename
		input_field.placeholder_text = "输入文件密码..."
		return

	while tw.is_typing:
		await get_tree().process_frame

	var content_size: int = node.content.length()
	await tw.show_progress_bar(content_size)
	await get_tree().create_timer(0.5).timeout

	output_text.text = ""
	tw.clear_queue()
	var header: String = "[color=" + T.primary_hex + "]══════════ " + filename + " ══════════[/color]"
	output_text.append_text(header + "\n\n")

	if not read_files.has(file_path):
		read_files.append(file_path)
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

	var clean_content: String = node.content.strip_edges()
	clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
	append_output(clean_content, false)
	append_output("\n[color=" + T.primary_hex + "]══════════ 文件结束 ══════════[/color]\n[color=" + T.muted_hex + "]输入任意命令返回终端。[/color]\n", false)

func _cmd_back() -> void:
	if current_path == "/":
		append_output("[color=" + T.muted_hex + "]已经在根目录了。[/color]")
		return
	current_path = fs.get_parent_path(current_path)
	_update_status_bar()
	append_output("已返回: " + current_path + "\n", false)

func _cmd_clear() -> void:
	output_text.text = ""
	tw.clear_queue()

func _cmd_status() -> void:
	var p: String = T.primary_hex
	var w: String = T.warning_hex
	var m: String = T.muted_hex
	var lines: Array[String] = []
	lines.append("[color=" + p + "]═══════════ 用户状态 ═══════════[/color]")
	lines.append("  用户名: [color=" + p + "]未登录[/color]")
	lines.append("  权限等级:   [color=" + w + "]" + str(fs.player_clearance) + "[/color]")
	lines.append("  当前路径:   [color=" + p + "]" + current_path + "[/color]")
	lines.append("  已读文件:   [color=" + p + "]" + str(read_files.size()) + "[/color]")
	lines.append("  已获取密码: [color=" + p + "]" + str(unlocked_passwords.size()) + "[/color]")
	lines.append("  已解锁文件: [color=" + p + "]" + str(fs.unlocked_file_passwords.size()) + "[/color]")
	if not story_id.is_empty():
		lines.append("  盘ID: [color=" + m + "]" + story_id + "[/color]")
	lines.append("[color=" + p + "]════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_mail(args: Array) -> void:
	append_output("[color=" + T.muted_hex + "]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)

func _cmd_exit() -> void:
	append_output("[color=" + T.muted_hex + "]正在断开连接...[/color]")
	await get_tree().create_timer(1.0).timeout
	get_tree().quit()

func _cmd_whoami() -> void:
	append_output("[color=" + T.primary_hex + "]未登录用户[/color]\n[color=" + T.muted_hex + "](用户系统将在后续版本中实现)[/color]\n", false)

func _cmd_story_info() -> void:
	var p: String = T.primary_hex
	var s: String = T.success_hex
	var w: String = T.warning_hex
	var m: String = T.muted_hex

	if story_manifest.is_empty() and available_stories.is_empty():
		append_output("[color=" + m + "]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
		return

	var lines: Array[String] = []
	lines.append("[color=" + p + "]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")

	if available_stories.size() > 0:
		lines.append("")
		lines.append("  已发现 [color=" + p + "]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
		lines.append("")
		for i in range(available_stories.size()):
			var info: Dictionary = available_stories[i]
			var marker: String = ""
			if i == current_story_index:
				marker = " [color=" + s + "]<< 当前[/color]"
			lines.append("  [color=" + w + "]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=" + m + "](" + info.get("filename", "") + ")[/color]" + marker)
			lines.append("     作者: [color=" + m + "]" + info.get("author", "未知") + "[/color]")
		lines.append("")
		lines.append("[color=" + m + "]  使用 [/color][color=" + p + "]vdisc load <编号>[/color][color=" + m + "] 切换磁盘[/color]")
		lines.append("[color=" + m + "]  使用 [/color][color=" + p + "]scan[/color][color=" + m + "] 重新扫描目录[/color]")

	if story_manifest.has("story"):
		lines.append("")
		lines.append("[color=" + p + "]─────────── 当前磁盘详情 ───────────[/color]")
		var info: Dictionary = story_manifest["story"]
		lines.append("  磁盘标签: [color=" + p + "]" + info.get("title", "未知") + "[/color]")
		lines.append("  制作者:   [color=" + p + "]" + info.get("author", "未知") + "[/color]")
		lines.append("  版本: [color=" + p + "]" + info.get("version", "未知") + "[/color]")
		if info.has("description"):
			lines.append("  描述: [color=" + m + "]" + info["description"] + "[/color]")
		lines.append("  文件总数: [color=" + p + "]" + str(fs.file_system.size()) + "[/color]")
		lines.append("  磁盘来源: [color=" + m + "]" + current_story_path.get_file() + "[/color]")
		lines.append("  磁盘状态: [color=" + s + "]已挂载[/color]")

	lines.append("[color=" + p + "]═══════════════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_vdisc_load(args: Array) -> void:
	if args.is_empty():
		append_output("[color=" + T.error_hex + "][ERROR] 用法: vdisc load <编号>[/color]\n[color=" + T.muted_hex + "]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
		return

	var index_str: String = args[0]
	if not index_str.is_valid_int():
		append_output("[color=" + T.error_hex + "][ERROR] 请输入有效的编号数字。[/color]\n", false)
		return

	var index: int = index_str.to_int() - 1
	if index < 0 or index >= available_stories.size():
		append_output("[color=" + T.error_hex + "][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return

	if index == current_story_index:
		append_output("[color=" + T.muted_hex + "]该磁盘已经是当前加载的磁盘。[/color]\n", false)
		return

	save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

	append_output("[color=" + T.muted_hex + "]正在卸载当前磁盘...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.3).timeout

	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	read_files.clear()
	unlocked_passwords.clear()

	await tw.show_progress_bar(800)
	await get_tree().create_timer(0.3).timeout

	if _load_story_by_index(index):
		var title: String = available_stories[index].get("title", "未知")
		var box: String = fs.build_box_sectioned([
			["DISC LOADED", "磁盘加载完成"],
			[title]
		], T.success_hex)
		append_output(box + "\n", false)
		_update_status_bar()
		append_output("[color=" + T.muted_hex + "]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
		append_output("[color=" + T.muted_hex + "]当前路径: " + current_path + "  权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
	else:
		append_output("[color=" + T.error_hex + "][ERROR] 磁盘加载失败。[/color]\n", false)
		fs.init_test_file_system()
		_update_status_bar()

func _cmd_unlock(args: Array) -> void:
	if not args.is_empty():
		_verify_password(args[0])
		return
	_enter_password_mode()

func _enter_password_mode(target_path: String = "") -> void:
	_password_mode = true
	_password_target_path = target_path
	var box: String = fs.build_box_sectioned([
		["SECURITY AUTHENTICATION", "安全认证系统"],
		["请输入访问密码:", "(输入 cancel 取消)"]
	], T.warning_hex)
	append_output(box + "\n", false)
	input_field.placeholder_text = "输入密码..."

func _verify_password(password: String) -> void:
	if not story_manifest.has("passwords"):
		append_output("[color=" + T.error_hex + "][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
		return

	var passwords: Dictionary = story_manifest["passwords"]
	if passwords.has(password):
		var pwd_info: Dictionary = passwords[password]
		var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))

		if unlocked_passwords.has(password):
			append_output("[color=" + T.muted_hex + "]该密码已使用过。当前权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
			return

		if grant_level <= fs.player_clearance:
			append_output("[color=" + T.muted_hex + "]该密码对应的权限等级不高于当前等级。当前: " + str(fs.player_clearance) + "[/color]\n", false)
			return

		unlocked_passwords.append(password)
		var old_level: int = fs.player_clearance
		fs.player_clearance = grant_level
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

		var box: String = fs.build_box_sectioned([
			["ACCESS GRANTED", "权限认证通过"],
			["权限等级: " + str(old_level) + " -> " + str(fs.player_clearance)]
		], T.success_hex)
		append_output(box + "\n", false)

		if pwd_info.has("message"):
			append_output("[color=" + T.muted_hex + "]" + str(pwd_info["message"]) + "[/color]\n", false)
	else:
		var box: String = fs.build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], T.error_hex)
		append_output(box + "\n", false)

func _verify_file_password(input_password: String) -> void:
	var fp_key: String = fs.get_file_password_key(_file_password_target)
	if fp_key.is_empty():
		append_output("[color=" + T.error_hex + "][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
		return

	var fp_info: Dictionary = fs.story_file_passwords[fp_key]
	var correct_password: String = str(fp_info.get("password", ""))

	if input_password == correct_password:
		fs.unlocked_file_passwords.append(_file_password_target)
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

		var box: String = fs.build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], T.success_hex)
		append_output(box + "\n", false)
		while tw.is_typing:
			await get_tree().process_frame
		await get_tree().create_timer(0.5).timeout
		await _cmd_open([_file_password_filename])
	else:
		var box: String = fs.build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], T.error_hex)
		append_output(box + "\n", false)

func _cmd_scan() -> void:
	append_output("[color=" + T.muted_hex + "]正在扫描vdisc目录...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await tw.show_progress_bar(500)
	await get_tree().create_timer(0.3).timeout

	var old_story_path: String = current_story_path
	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	read_files.clear()
	unlocked_passwords.clear()
	available_stories.clear()
	current_story_index = -1

	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	if _desktop_mode:
		if available_stories.is_empty():
			append_output("[color=" + T.warning_hex + "][WARN] 未找到虚拟磁盘文件。[/color]", false)
			append_output("[color=" + T.muted_hex + "]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
		else:
			var scan_lines: Array[String] = []
			scan_lines.append("[color=" + T.success_hex + "][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
			scan_lines.append("")
			for i in range(available_stories.size()):
				var info: Dictionary = available_stories[i]
				scan_lines.append("  [color=" + T.warning_hex + "]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=" + T.muted_hex + "](" + info.get("filename", "") + ")[/color]")
			scan_lines.append("")
			scan_lines.append("[color=" + T.muted_hex + "]输入 [/color][color=" + T.primary_hex + "]load <编号>[/color][color=" + T.muted_hex + "] 加载磁盘。[/color]")
			append_output("\n".join(scan_lines) + "\n", false)
		_update_status_bar()
	else:
		if available_stories.is_empty():
			_desktop_mode = true
			fs.init_test_file_system()
			current_path = "/"
			_update_status_bar()
			append_output("[color=" + T.warning_hex + "][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
		elif _load_story_by_index(0):
			var title: String = "未知"
			if story_manifest.has("story") and story_manifest["story"].has("title"):
				title = story_manifest["story"]["title"]
			append_output("[color=" + T.success_hex + "][OK] 已重新加载剧本: " + title + "[/color]", false)
			append_output("[color=" + T.muted_hex + "]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
			if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
				current_path = story_manifest["settings"]["start_path"]
			else:
				current_path = "/"
			_update_status_bar()
		else:
			append_output("[color=" + T.error_hex + "][ERROR] 重新加载失败。[/color]\n", false)

func _cmd_reboot() -> void:
	append_output("[color=" + T.muted_hex + "]正在重启终端...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.5).timeout

	output_text.text = ""
	tw.clear_queue()
	command_history.clear()
	history_index = -1

	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	has_new_mail = false
	read_files.clear()
	unlocked_passwords.clear()
	available_stories.clear()
	current_story_index = -1

	save_mgr.ensure_stories_dir()
	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	output_text.append_text("[color=" + T.muted_hex + "]...[/color]\n")
	await get_tree().create_timer(0.3).timeout
	output_text.append_text("[color=" + T.muted_hex + "]终端系统重新初始化中...[/color]\n")
	await get_tree().create_timer(0.5).timeout

	output_text.text = ""
	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()
	input_field.grab_focus()

# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
	if command_history.is_empty():
		return
	if history_index == -1:
		current_input_backup = input_field.text
		history_index = command_history.size() - 1
	elif history_index > 0:
		history_index -= 1
	input_field.text = command_history[history_index]
	input_field.caret_column = input_field.text.length()

func _history_next() -> void:
	if command_history.is_empty() or history_index == -1:
		return
	if history_index < command_history.size() - 1:
		history_index += 1
		input_field.text = command_history[history_index]
	else:
		history_index = -1
		input_field.text = current_input_backup
	input_field.caret_column = input_field.text.length()

# ============================================================
# 自动补全
# ============================================================
func _auto_complete() -> void:
	var current_text: String = input_field.text
	if current_text.strip_edges().is_empty():
		return

	var parts := current_text.split(" ", false)

	if parts.size() == 1:
		if current_text.ends_with(" "):
			var cmd: String = parts[0].to_lower()
			if cmd in ["cd", "open", "cat"]:
				var children := fs.get_children_at_path(current_path)
				if children.size() > 0:
					var display: Array[String] = []
					for child in children:
						var child_path := fs.join_path(current_path, child)
						var node := fs.get_node_at_path(child_path)
						if node == null:
							continue
						if cmd == "cd" and node.type == "folder":
							display.append(child + "/")
						elif cmd in ["open", "cat"] and node.type == "file":
							display.append(child)
						elif cmd not in ["cd"]:
							display.append(child)
					if display.size() > 0:
						output_text.append_text("\n[color=" + T.muted_hex + "]可选项: " + " | ".join(display) + "[/color]")
						tw._do_scroll()
		else:
			var partial_cmd: String = parts[0].to_lower()
			var commands: Array
			if _desktop_mode:
				commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
			else:
				commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
					"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
					"scan", "reboot", "restart", "unlock", "eject"]
			var matches: Array[String] = []
			for cmd in commands:
				if cmd.begins_with(partial_cmd):
					matches.append(cmd)
			if matches.size() == 1:
				input_field.text = matches[0] + " "
				input_field.caret_column = input_field.text.length()
			elif matches.size() > 1:
				output_text.append_text("\n[color=" + T.muted_hex + "]可选命令: " + " | ".join(matches) + "[/color]")
				tw._do_scroll()

	elif parts.size() == 2:
		var cmd: String = parts[0].to_lower()
		var partial_name: String = parts[1]
		if cmd in ["cd", "open", "cat"]:
			var children := fs.get_children_at_path(current_path)
			var matches: Array[String] = []
			for child in children:
				if child.to_lower().begins_with(partial_name.to_lower()):
					var child_path := fs.join_path(current_path, child)
					var node := fs.get_node_at_path(child_path)
					if node == null:
						continue
					if cmd == "cd" and node.type == "folder":
						matches.append(child)
					elif cmd in ["open", "cat"] and node.type == "file":
						matches.append(child)
			if matches.size() == 1:
				input_field.text = cmd + " " + matches[0]
				input_field.caret_column = input_field.text.length()
			elif matches.size() > 1:
				var common: String = _find_common_prefix(matches)
				if common.length() > partial_name.length():
					input_field.text = cmd + " " + common
					input_field.caret_column = input_field.text.length()
				output_text.append_text("\n[color=" + T.muted_hex + "]可选项: " + " | ".join(matches) + "[/color]")
				tw._do_scroll()

func _find_common_prefix(strings: Array[String]) -> String:
	if strings.is_empty():
		return ""
	if strings.size() == 1:
		return strings[0]
	var prefix: String = strings[0]
	for i in range(1, strings.size()):
		while not strings[i].to_lower().begins_with(prefix.to_lower()):
			prefix = prefix.substr(0, prefix.length() - 1)
			if prefix.is_empty():
				return ""
	return prefix

# ============================================================
# 输出工具（转发到打字机模块）
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
	tw.append(text, extra_newline)

# ============================================================
# 每帧处理（滚动）
# ============================================================
func _process(_delta: float) -> void:
	tw.process_scroll()

# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
	if _desktop_mode:
		path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
		mail_icon.text = "[Mail]"
		return

	var disc_name: String = ""
	if current_story_index >= 0 and current_story_index < available_stories.size():
		disc_name = available_stories[current_story_index].get("title", "")

	if disc_name.is_empty():
		path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance)
	else:
		path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance) + "  DISC:" + disc_name

	if has_new_mail:
		mail_icon.text = "[Mail NEW]"
	else:
		mail_icon.text = "[Mail]"

# ============================================================
# 超链接处理
# ============================================================
func _on_meta_clicked(meta: Variant) -> void:
	var meta_str: String = str(meta)

	if meta_str.begins_with("cmd://"):
		var cmd: String = meta_str.substr(6)
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + cmd)
		output_text.append_text("\n")
		_execute_command(cmd)
		return

	if meta_str.begins_with("file://"):
		var file_path: String = meta_str.substr(7)
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> open " + file_path)
		output_text.append_text("\n")
		await _cmd_open([file_path])
		return

	print("[Terminal] 未知链接: " + meta_str)

# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
	var p: String = T.primary_hex
	var w: String = T.warning_hex
	var m: String = T.muted_hex

	var title: String = "SCP FOUNDATION TERMINAL v0.1"
	var subtitle: String = "SECURE - CONTAIN - PROTECT"
	var box: String = fs.build_box([title, subtitle] as Array[String], p)
	output_text.append_text(box + "\n\n")

	if available_stories.is_empty():
		output_text.append_text("[color=" + w + "]未检测到虚拟磁盘。[/color]\n")
		output_text.append_text("[color=" + m + "]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
	else:
		output_text.append_text("[color=" + p + "]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
		for i in range(available_stories.size()):
			var info: Dictionary = available_stories[i]
			output_text.append_text("  [color=" + w + "]" + str(i + 1) + ".[/color] [color=" + p + "]" + info.get("title", "未知") + "[/color]\n")
			output_text.append_text("     [color=" + m + "]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
		output_text.append_text("\n")

	output_text.append_text("[color=" + m + "]可用命令:[/color]\n")
	output_text.append_text("  [color=" + p + "]load <编号>[/color]   加载指定磁盘\n")
	output_text.append_text("  [color=" + p + "]scan[/color]   重新扫描磁盘目录\n")
	output_text.append_text("  [color=" + p + "]clear[/color] 清空屏幕\n")
	output_text.append_text("  [color=" + p + "]exit[/color]   退出终端\n")

func _cmd_desktop_load(args: Array) -> void:
	if args.is_empty():
		append_output("[color=" + T.error_hex + "][ERROR] 用法: load <编号>[/color]", false)
		if available_stories.size() > 0:
			append_output("[color=" + T.muted_hex + "]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return

	var index_str: String = args[0]
	if not index_str.is_valid_int():
		append_output("[color=" + T.error_hex + "][ERROR] 请输入有效的编号数字。[/color]\n", false)
		return

	var index: int = index_str.to_int() - 1
	if index < 0 or index >= available_stories.size():
		append_output("[color=" + T.error_hex + "][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return

	append_output("[color=" + T.muted_hex + "]正在加载虚拟磁盘...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await tw.show_progress_bar(800)
	await get_tree().create_timer(0.3).timeout

	if _load_story_by_index(index):
		_desktop_mode = false
		var title: String = available_stories[index].get("title", "未知")
		output_text.text = ""
		tw.clear_queue()
		_update_status_bar()
		_show_welcome_message()
	else:
		append_output("[color=" + T.error_hex + "][ERROR] 磁盘加载失败。[/color]\n", false)

func _cmd_eject() -> void:
	if _desktop_mode:
		append_output("[color=" + T.muted_hex + "]当前已在桌面模式。[/color]\n", false)
		return

	save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
	append_output("[color=" + T.muted_hex + "]正在卸载磁盘...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.5).timeout

	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	read_files.clear()
	unlocked_passwords.clear()
	current_story_index = -1

	_desktop_mode = true
	output_text.text = ""
	tw.clear_queue()
	_update_status_bar()
	_show_desktop_welcome()

# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
	var p: String = T.primary_hex
	var m: String = T.muted_hex

	var title: String = "SCP FOUNDATION TERMINAL v0.1"
	var subtitle: String = "SECURE - CONTAIN - PROTECT"
	if story_manifest.has("story"):
		var story_info: Dictionary = story_manifest["story"]
		if story_info.has("title"):
			subtitle = story_info["title"]

	var title_display_len: int = fs.display_width(title)
	var subtitle_display_len: int = fs.display_width(subtitle)
	var inner_width: int = max(title_display_len, subtitle_display_len) + 6

	var title_pad_total: int = inner_width - title_display_len
	var title_pad_left: int = title_pad_total / 2
	var title_pad_right: int = title_pad_total - title_pad_left

	var subtitle_pad_total: int = inner_width - subtitle_display_len
	var subtitle_pad_left: int = subtitle_pad_total / 2
	var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left

	var border_h: String = "═".repeat(inner_width)

	var welcome: String = ""
	welcome += "[color=" + p + "]╔" + border_h + "╗\n"
	welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
	welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
	welcome += "╚" + border_h + "╝[/color]\n"
	welcome += "\n"
	welcome += "[color=" + m + "]终端系统已启动。\n"
	welcome += "输入 [/color][color=" + p + "]help[/color][color=" + m + "] 查看可用命令。[/color]\n"
	output_text.append_text(welcome)

# ============================================================
# 剧本加载系统
# ============================================================
func _try_load_story() -> bool:
	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	print("[StoryLoader] 搜索目录: " + vdisc_dir)
	_scan_available_stories(vdisc_dir)
	return not available_stories.is_empty()

func _scan_available_stories(vdisc_dir: String) -> void:
	available_stories.clear()
	if not DirAccess.dir_exists_absolute(vdisc_dir):
		return

	var dir := DirAccess.open(vdisc_dir)
	if dir == null:
		return

	dir.list_dir_begin()
	var file_name := dir.get_next()
	while file_name != "":
		if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
			var full_path: String = vdisc_dir + file_name
			var info: Dictionary = _peek_story_info(full_path)
			info["path"] = full_path
			info["filename"] = file_name
			available_stories.append(info)
			print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
		file_name = dir.get_next()
	print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")

func _peek_story_info(path: String) -> Dictionary:
	var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}
	var reader := ZIPReader.new()
	if reader.open(path) != OK:
		return info

	var files := reader.get_files()
	for file_path in files:
		var filename: String = file_path.get_file()
		if filename == "manifest.json":
			var content_bytes := reader.read_file(file_path)
			if content_bytes != null:
				var content: String = content_bytes.get_string_from_utf8()
				var json := JSON.new()
				if json.parse(content) == OK and json.data is Dictionary:
					var data: Dictionary = json.data
					if data.has("story"):
						var story_info: Dictionary = data["story"]
						info["title"] = story_info.get("title", "未知剧本")
						info["id"] = story_info.get("id", "")
						info["author"] = story_info.get("author", "未知")
			break
		elif filename == "manifest.cfg":
			var content_bytes := reader.read_file(file_path)
			if content_bytes != null:
				var content: String = content_bytes.get_string_from_utf8()
				for line in content.split("\n"):
					line = line.strip_edges()
					if line.begins_with("title="):
						info["title"] = line.substr(6).strip_edges()
					elif line.begins_with("id="):
						info["id"] = line.substr(3).strip_edges()
					elif line.begins_with("author="):
						info["author"] = line.substr(7).strip_edges()
			break

	reader.close()
	return info

func _load_story_by_index(index: int) -> bool:
	if index < 0 or index >= available_stories.size():
		return false
	var story_info: Dictionary = available_stories[index]
	var path: String = story_info["path"]
	if _load_story_file(path):
		current_story_index = index
		return true
	return false

func _load_story_file(path: String) -> bool:
	story_loader = StoryLoader.new()
	if not story_loader.load_story(path):
		print("[StoryLoader] 加载失败: " + story_loader.error_message)
		return false

	fs.file_system = story_loader.file_system
	story_manifest = story_loader.manifest
	current_story_path = path

	if story_manifest.has("story") and story_manifest["story"].has("id"):
		story_id = story_manifest["story"]["id"]
	else:
		story_id = str(path.get_file().hash())

	fs.story_permissions.clear()
	if story_manifest.has("permissions"):
		var perms: Dictionary = story_manifest["permissions"]
		for perm_path in perms.keys():
			fs.story_permissions[perm_path] = int(perms[perm_path])
		print("[StoryLoader] 权限表已加载，共 " + str(fs.story_permissions.size()) + " 条规则")
	else:
		print("[StoryLoader] 警告: manifest中未找到permissions字段")

	if story_manifest.has

### USER
继续完成代码

### ASSISTANT
根据上下文中提供的代码片段 [1] [2]，我可以看到这是之前对话中 `main.gd` 的 `_load_story_file` 函数在最后被截断了。以下是继续完成的代码：

```gdscript
func _load_story_file(path: String) -> bool:
	story_loader = StoryLoader.new()
	if not story_loader.load_story(path):
		print("[StoryLoader] 加载失败: " + story_loader.error_message)
		return false

	fs.file_system = story_loader.file_system
	story_manifest = story_loader.manifest
	current_story_path = path

	if story_manifest.has("story") and story_manifest["story"].has("id"):
		story_id = story_manifest["story"]["id"]
	else:
		story_id = str(path.get_file().hash())

	fs.story_permissions.clear()
	if story_manifest.has("permissions"):
		var perms: Dictionary = story_manifest["permissions"]
		for perm_path in perms.keys():
			fs.story_permissions[perm_path] = int(perms[perm_path])
		print("[StoryLoader] 权限表已加载，共 " + str(fs.story_permissions.size()) + " 条规则")
	else:
		print("[StoryLoader] 警告: manifest中未找到permissions字段")

	if story_manifest.has("passwords"):
		print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
	else:
		print("[StoryLoader] 警告: manifest中未找到passwords字段")

	# 读取文件密码表
	fs.story_file_passwords.clear()
	if story_manifest.has("file_passwords"):
		var fps: Dictionary = story_manifest["file_passwords"]
		for fp_path in fps.keys():
			fs.story_file_passwords[fp_path] = fps[fp_path]
		print("[StoryLoader] 文件密码表已加载，共 " + str(fs.story_file_passwords.size()) + " 条")
	else:
		print("[StoryLoader] 未配置文件密码表（file_passwords）")

	# 应用 manifest 中的设置
	var start_clearance: int = 0
	if story_manifest.has("settings"):
		var settings: Dictionary = story_manifest["settings"]
		if settings.has("start_path"):
			current_path = settings["start_path"]
		if settings.has("typing_speed"):
			tw.base_speed = settings["typing_speed"].to_float()
		if settings.has("start_clearance"):
			start_clearance = int(settings["start_clearance"])

	# 尝试加载该剧本的存档
	var save_data = save_mgr.load_save(story_id)
	if save_data != null:
		fs.player_clearance = int(save_data.get("player_clearance", 0))
		read_files.clear()
		if save_data.has("read_files"):
			for f in save_data["read_files"]:
				read_files.append(str(f))
		unlocked_passwords.clear()
		if save_data.has("unlocked_passwords"):
			for p in save_data["unlocked_passwords"]:
				unlocked_passwords.append(str(p))
		fs.unlocked_file_passwords.clear()
		if save_data.has("unlocked_file_passwords"):
			for p in save_data["unlocked_file_passwords"]:
				fs.unlocked_file_passwords.append(str(p))
		if save_data.has("current_path"):
			var saved_path: String = save_data["current_path"]
			if fs.has_clearance(saved_path):
				current_path = saved_path
			else:
				current_path = "/"
				if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
					current_path = story_manifest["settings"]["start_path"]
		print("[Save] 权限等级: " + str(fs.player_clearance))
	else:
		# 没有存档，用初始权限
		fs.player_clearance = start_clearance
		read_files.clear()
		unlocked_passwords.clear()

	var title: String = "未知剧本"
	if story_manifest.has("story") and story_manifest["story"].has("title"):
		title = story_manifest["story"]["title"]

	print("[StoryLoader] 成功加载: " + title)
	print("[StoryLoader] 盘ID: " + story_id)
	print("[StoryLoader] 文件数量: " + str(fs.file_system.size()))
	print("[StoryLoader] 权限等级: " + str(fs.player_clearance))
	print("[StoryLoader] story_permissions 内容: " + str(fs.story_permissions))
	print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
	return true
```

这就是 `_load_story_file` 函数的完整结尾部分。它处理了以下关键逻辑：

1. **文件密码表加载** — 从 manifest 中读取 `file_passwords` 字段 [2]
2. **设置应用** — 包括起始路径、打字速度、初始权限等级
3. **存档恢复** — 如果存在存档，恢复权限等级、已读文件、已解锁密码等状态
4. **调试日志** — 输出加载结果的详细信息

这是 `main.gd` 文件的最后一个函数，至此整个文件完整结束。

### USER
目前可以选中了，但是没办法进行复制出来，请想办法解决。

### ASSISTANT
# RichTextLabel 选中文字后无法复制的解决方案

## 问题分析

在 Godot 中，`RichTextLabel` 虽然支持 `selection_enabled = true` 来选中文字，但它**默认不处理 Ctrl+C 复制操作**。需要手动实现复制功能。

另外根据之前的代码，`_input` 函数中拦截了所有键盘事件，Ctrl+C 可能被吞掉了，没有机会触发复制逻辑。

---

## 解决方案

### 修改 `main.gd` 中的 `_input` 函数

在键盘事件处理部分的**最前面**，添加 Ctrl+C 复制逻辑：

```gdscript
func _input(event: InputEvent) -> void:
	# --- 鼠标事件处理（保持不变）---
	if event is InputEventMouseButton and event.pressed:
		match event.button_index:
			MOUSE_BUTTON_WHEEL_UP:
				scroll_container.scroll_vertical -= 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_WHEEL_DOWN:
				scroll_container.scroll_vertical += 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_LEFT:
				var mouse_pos: Vector2 = event.position
				var output_rect: Rect2 = output_text.get_global_rect()
				if output_rect.has_point(mouse_pos):
					return
				input_field.grab_focus()
				return

	if event is InputEventMouseButton and not event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			var mouse_pos: Vector2 = event.position
			var output_rect: Rect2 = output_text.get_global_rect()
			if not output_rect.has_point(mouse_pos):
				input_field.grab_focus()
			return

	if not event is InputEventKey or not event.pressed:
		return

	# ============================================================
	# Ctrl+C 复制选中文字（必须在其他键盘处理之前）
	# ============================================================
	if event.ctrl_pressed and event.keycode == KEY_C:
		var selected_text: String = output_text.get_selected_text()
		if not selected_text.is_empty():
			DisplayServer.clipboard_set(selected_text)
			# 复制成功后，取消选中并重新聚焦输入框
			output_text.deselect()
			input_field.grab_focus()
			get_viewport().set_input_as_handled()
			return
		# 如果没有选中文字，让 Ctrl+C 正常传递（比如输入框中的复制）
		return

	# ============================================================
	# Ctrl+A 全选输出文字
	# ============================================================
	if event.ctrl_pressed and event.keycode == KEY_A:
		if output_text.has_focus():
			output_text.select_all()
			get_viewport().set_input_as_handled()
			return

	# --- 以下是原有的键盘处理逻辑 ---
	if not input_field.has_focus():
		input_field.grab_focus()

	if tw.is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
		tw.skip()
		get_viewport().set_input_as_handled()
		return

	match event.keycode:
		KEY_ENTER, KEY_KP_ENTER:
			if tw.is_typing:
				get_viewport().set_input_as_handled()
			else:
				var command_text: String = input_field.text
				input_field.clear()
				_on_command_submitted(command_text)
				get_viewport().set_input_as_handled()
		KEY_UP:
			_history_previous()
			get_viewport().set_input_as_handled()
		KEY_DOWN:
			_history_next()
			get_viewport().set_input_as_handled()
		KEY_PAGEUP:
			scroll_container.scroll_vertical -= 100
			get_viewport().set_input_as_handled()
		KEY_PAGEDOWN:
			scroll_container.scroll_vertical += 100
			get_viewport().set_input_as_handled()
		KEY_TAB:
			_auto_complete()
			get_viewport().set_input_as_handled()
```

---

## 核心改动说明

| 功能 | 按键 | 实现方式 |
|------|------|----------|
| 复制选中文字 | Ctrl+C | `output_text.get_selected_text()` + `DisplayServer.clipboard_set()` |
| 全选输出内容 | Ctrl+A | `output_text.select_all()`（仅当输出框有焦点时）|

关键点：
1. **`Ctrl+C` 必须放在 `input_field.grab_focus()` 之前**，否则焦点被抢走后，`output_text` 的选中状态就丢失了
2. 使用 `DisplayServer.clipboard_set()` 而不是依赖控件自带的复制功能，因为 `RichTextLabel` 默认没有内置 Ctrl+C 处理 [1]
3. 复制完成后自动取消选中并回到输入框，保持操作流畅

### USER
不要用ctrl+c复制了，直接单击鼠标右键复制就行。

### ASSISTANT
# 右键点击复制选中文字

## 修改 `main.gd` 中的 `_input` 函数

在鼠标事件处理部分，添加右键点击复制逻辑：

```gdscript
func _input(event: InputEvent) -> void:
	# --- 鼠标事件处理 ---
	if event is InputEventMouseButton and event.pressed:
		match event.button_index:
			MOUSE_BUTTON_WHEEL_UP:
				scroll_container.scroll_vertical -= 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_WHEEL_DOWN:
				scroll_container.scroll_vertical += 60
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_RIGHT:
				# 右键点击：如果有选中文字则复制到剪贴板
				var selected_text: String = output_text.get_selected_text()
				if not selected_text.is_empty():
					DisplayServer.clipboard_set(selected_text)
					output_text.deselect()
					input_field.grab_focus()
					# 可选：给用户一个复制成功的提示
					_show_copy_toast()
				get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_LEFT:
				var mouse_pos: Vector2 = event.position
				var output_rect: Rect2 = output_text.get_global_rect()
				if output_rect.has_point(mouse_pos):
					return
				input_field.grab_focus()
				return

	if event is InputEventMouseButton and not event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			var mouse_pos: Vector2 = event.position
			var output_rect: Rect2 = output_text.get_global_rect()
			if not output_rect.has_point(mouse_pos):
				input_field.grab_focus()
			return

	if not event is InputEventKey or not event.pressed:
		return

	if not input_field.has_focus():
		input_field.grab_focus()

	if tw.is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
		tw.skip()
		get_viewport().set_input_as_handled()
		return

	match event.keycode:
		KEY_ENTER, KEY_KP_ENTER:
			if tw.is_typing:
				get_viewport().set_input_as_handled()
			else:
				var command_text: String = input_field.text
				input_field.clear()
				_on_command_submitted(command_text)
				get_viewport().set_input_as_handled()
		KEY_UP:
			_history_previous()
			get_viewport().set_input_as_handled()
		KEY_DOWN:
			_history_next()
			get_viewport().set_input_as_handled()
		KEY_PAGEUP:
			scroll_container.scroll_vertical -= 100
			get_viewport().set_input_as_handled()
		KEY_PAGEDOWN:
			scroll_container.scroll_vertical += 100
			get_viewport().set_input_as_handled()
		KEY_TAB:
			_auto_complete()
			get_viewport().set_input_as_handled()
```

---

## 添加复制成功提示函数

在 `main.gd` 中添加一个简单的提示函数，让用户知道复制成功了：

```gdscript
# ============================================================
# 复制成功提示（短暂显示后自动消失）
# ============================================================
func _show_copy_toast() -> void:
	var p: String = T.primary_hex
	var m: String = T.muted_hex
	# 在输出区底部临时显示提示
	output_text.append_text("\n[color=" + m + "][已复制到剪贴板][/color]")
	# 1.5秒后移除提示（可选）
	await get_tree().create_timer(1.5).timeout
	# 获取当前文本，移除最后的提示行
	var current_bbcode: String = output_text.text
	var toast_tag: String = "[color=" + m + "][已复制到剪贴板][/color]"
	if current_bbcode.ends_with(toast_tag):
		output_text.text = current_bbcode.substr(0, current_bbcode.length() - toast_tag.length()).rstrip("\n")
```

---

## 操作方式

| 操作 | 效果 |
|------|------|
| **左键拖拽** | 选中输出区文字 [1] |
| **右键单击** | 复制选中内容到剪贴板，并自动取消选中 |
| 无选中时右键 | 无操作（不会弹出系统菜单） |

这样不需要键盘操作，鼠标**选中 → 右键**即可完成复制，非常符合终端的操作习惯。

### USER
完成了，效果很好，总结一下该阶段剩余工作，然后开始拆分下一个脚本。

### ASSISTANT
# 阶段总结与下一步规划

---

## 本阶段已完成的工作

| 完成项 | 说明 |
|--------|------|
| ✅ 文字选中 | `RichTextLabel` 支持鼠标拖拽选中 |
| ✅ 右键复制 | 右键点击自动复制选中内容到剪贴板 |
| ✅ 主题色系统 | `ThemeManager` 统一管理所有颜色，支持一键切换主题 |
| ✅ 颜色替换 | `main.gd` 中所有硬编码颜色已替换为主题变量引用 |
| ✅ CRT鼠标光标 | 像素风格的自定义光标（箭头、I-beam、手指） |
| ✅ CRT层鼠标穿透 | `CRTShader` 的 `mouse_filter` 设为 `IGNORE` |
| ✅ UI样式主题化 | 状态栏、输入框、输出区等样式跟随主题色 |

---

## 本阶段剩余工作

| 待完成项 | 优先级 | 说明 |
|----------|--------|------|
| `file_system.gd` 中的 `build_box` / `build_box_sectioned` 颜色检查 | 中 | 确认这些函数接收的颜色参数已全部使用 `T.xxx_hex` 传入 |
| `typewriter.gd` 中的进度条颜色 | 中 | `show_progress_bar` 如果有硬编码颜色也需要替换 |
| `_show_copy_toast` 自动消失的稳定性 | 低 | BBCode 尾部匹配删除可能不够稳定，可考虑简化或去掉自动消失 |
| 主题切换命令 | 低 | 可以添加 `theme <名称>` 命令让玩家在终端内切换主题 |

---

## 下一步：拆分 `main.gd`

当前 `main.gd` 职责过重，包含了：

1. **输入处理**（键盘、鼠标、历史记录、自动补全）
2. **命令解析与执行**（所有命令实现）
3. **UI更新**（状态栏、欢迎信息）
4. **剧本加载系统**（扫描、加载、存档恢复）
5. **密码系统**（权限认证、文件密码）

### 建议拆分方案

| 新脚本 | 职责 | 从 main.gd 中提取的函数 |
|--------|------|------------------------|
| `input_handler.gd` | 输入事件处理 | `_input()`、`_history_previous/next()`、`_auto_complete()`、`_find_common_prefix()`、右键复制逻辑 |
| `command_processor.gd` | 命令解析与执行 | `_execute_command()`、`_on_command_submitted()`、所有 `_cmd_xxx()` 函数 |
| `story_system.gd` | 剧本管理 | `_scan_available_stories()`、`_peek_story_info()`、`_load_story_by_index()`、`_load_story_file()`、`_try_load_story()` |

### 建议从 `input_handler.gd` 开始

这是最独立的模块，基本不涉及命令逻辑，只负责：
- 鼠标滚轮、左键聚焦、右键复制 [1]
- 键盘快捷键分发（回车、上下箭头、PageUp/Down、Tab）[1]
- 命令历史导航
- 自动补全

---

要我现在开始拆分 `input_handler.gd` 吗？

### USER
开始拆分input_handler.gd

### ASSISTANT
[An error occurred. Reference: 46df4572-322b-412f-89e3-fea014c0e61b at 2026-02-13T08:04:25.025Z]

### USER
开始拆分input_handler.gd

### ASSISTANT


### USER
下面是main.gd的代码，按你昨天的规划开始下一步拆分
extends Control
# ============================================================
# 节点引用
# ============================================================
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
var background: TextureRect = null  # 由 UIManager 创建
# 模块实例
var save_mgr: SaveManager = SaveManager.new()
var fs: FileSystem = FileSystem.new()
var tw: Typewriter = null
# 主题色快捷引用（在 _ready 中初始化）
var T: ThemeManager.ThemeColors = null
# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""
# 桌面/终端模式
var _desktop_mode: bool = true
# ============================================================
# 剧本系统
# ============================================================
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []
var current_story_index: int = -1
var story_id: String = ""
var read_files: Array[String] = []
var unlocked_passwords: Array[String] = []
# 密码输入弹窗状态
var _password_mode: bool = false
var _password_target_path: String = ""
# 文件密码系统
var _file_password_mode: bool = false
var _file_password_target: String = ""
var _file_password_filename: String = ""
# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
# 初始化主题系统（必须最先调用）
ThemeManager.init("phosphor_green")
T = ThemeManager.current
# 初始化打字机模块
tw = Typewriter.new()
tw.name = "Typewriter"
add_child(tw)
save_mgr.ensure_stories_dir()
save_mgr.ensure_saves_dir()
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
# === UI 初始化（全部委托给 UIManager） ===
background = UIManager.setup_background(self, save_mgr.get_game_root_dir())
UIManager.setup_main_content(self, $MainContent)
UIManager.setup_all_styles(status_frame, path_label, mail_icon, input_frame, input_field, output_text, scroll_container)
# CRT效果层鼠标穿透
UIManager.setup_crt_effect($CRTEffect)
# 自定义CRT风格鼠标光标
UIManager.setup_custom_cursor(self)
# 连接超链接信号
output_text.meta_clicked.connect(_on_meta_clicked)
# 初始化打字机引用
tw.setup(output_text, scroll_container)
# 输入框设置
input_field.focus_mode = Control.FOCUS_ALL
input_field.focus_next = input_field.get_path()
input_field.focus_previous = input_field.get_path()
input_field.grab_focus()
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 复制成功提示（短暂显示后自动消失）
# ============================================================
func _show_copy_toast() -> void:
var p: String = T.primary_hex
var m: String = T.muted_hex
# 在输出区底部临时显示提示
output_text.append_text("\n[color=" + m + "][已复制到剪贴板][/color]")
# 1.5秒后移除提示（可选）
await get_tree().create_timer(1.5).timeout
# 获取当前文本，移除最后的提示行
var current_bbcode: String = output_text.text
var toast_tag: String = "[color=" + m + "][已复制到剪贴板][/color]"
if current_bbcode.ends_with(toast_tag):
output_text.text = current_bbcode.substr(0, current_bbcode.length() - toast_tag.length()).rstrip("\n")
# ============================================================
# 输入处理
# ============================================================
func _input(event: InputEvent) -> void:
# --- 鼠标事件处理 ---
if event is InputEventMouseButton and event.pressed:
match event.button_index:
MOUSE_BUTTON_WHEEL_UP:
scroll_container.scroll_vertical -= 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_WHEEL_DOWN:
scroll_container.scroll_vertical += 60
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_RIGHT:
# 右键点击：如果有选中文字则复制到剪贴板
var selected_text: String = output_text.get_selected_text()
if not selected_text.is_empty():
DisplayServer.clipboard_set(selected_text)
output_text.deselect()
input_field.grab_focus()
# 可选：给用户一个复制成功的提示
_show_copy_toast()
get_viewport().set_input_as_handled()
return
MOUSE_BUTTON_LEFT:
var mouse_pos: Vector2 = event.position
var output_rect: Rect2 = output_text.get_global_rect()
if output_rect.has_point(mouse_pos):
return
input_field.grab_focus()
return
if event is InputEventMouseButton and not event.pressed:
if event.button_index == MOUSE_BUTTON_LEFT:
var mouse_pos: Vector2 = event.position
var output_rect: Rect2 = output_text.get_global_rect()
if not output_rect.has_point(mouse_pos):
input_field.grab_focus()
return
if not event is InputEventKey or not event.pressed:
return
if not input_field.has_focus():
input_field.grab_focus()
if tw.is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
tw.skip()
get_viewport().set_input_as_handled()
return
match event.keycode:
KEY_ENTER, KEY_KP_ENTER:
if tw.is_typing:
get_viewport().set_input_as_handled()
else:
var command_text: String = input_field.text
input_field.clear()
_on_command_submitted(command_text)
get_viewport().set_input_as_handled()
KEY_UP:
_history_previous()
get_viewport().set_input_as_handled()
KEY_DOWN:
_history_next()
get_viewport().set_input_as_handled()
KEY_PAGEUP:
scroll_container.scroll_vertical -= 100
get_viewport().set_input_as_handled()
KEY_PAGEDOWN:
scroll_container.scroll_vertical += 100
get_viewport().set_input_as_handled()
KEY_TAB:
_auto_complete()
get_viewport().set_input_as_handled()
# ============================================================
# 命令提交处理
# ============================================================
func _on_command_submitted(command_text: String) -> void:
var raw_input: String = command_text.strip_edges()
input_field.clear()
if raw_input.is_empty():
return
if _file_password_mode:
_file_password_mode = false
input_field.placeholder_text = "> 输入命令..."
while tw.is_typing:
await get_tree().process_frame
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=" + T.muted_hex + "]已取消文件密码输入。[/color]\n", false)
_file_password_target = ""
_file_password_filename = ""
return
await _verify_file_password(raw_input)
return
if _password_mode:
_password_mode = false
input_field.placeholder_text = "> 输入命令..."
while tw.is_typing:
await get_tree().process_frame
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
if raw_input.to_lower() == "cancel":
append_output("[color=" + T.muted_hex + "]已取消密码输入。[/color]\n", false)
return
_verify_password(raw_input)
return
command_history.append(raw_input)
history_index = -1
while tw.is_typing:
await get_tree().process_frame
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + raw_input + "\n")
await _execute_command(raw_input)
# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
tw.instant = false
var parts := raw_input.split(" ", false)
if parts.is_empty():
return
var command: String = parts[0].to_lower()
var args := parts.slice(1)
if _desktop_mode:
match command:
"load":
await _cmd_desktop_load(args)
"scan":
await _cmd_scan()
"clear", "cls":
_cmd_clear()
"exit", "quit":
await _cmd_exit()
"help", "?":
_cmd_desktop_help()
"vdisc", "disc", "disk":
_cmd_story_info()
"reboot", "restart":
await _cmd_reboot()
_:
append_output("[color=" + T.error_hex + "][ERROR] 未知指令: " + command + "[/color]\n[color=" + T.muted_hex + "]输入 [/color][color=" + T.primary_hex + "]help[/color][color=" + T.muted_hex + "] 查看可用命令。[/color]\n", false)
return
match command:
"help", "?":
_cmd_help()
"ls", "dir":
_cmd_ls()
"cd":
_cmd_cd(args)
"open", "cat":
await _cmd_open(args)
"back":
_cmd_back()
"clear", "cls":
_cmd_clear()
"status":
_cmd_status()
"mail":
_cmd_mail(args)
"exit", "quit":
await _cmd_exit()
"whoami":
_cmd_whoami()
"vdisc", "disc", "disk":
if args.size() >= 1 and args[0].to_lower() == "load":
await _cmd_vdisc_load(args.slice(1))
else:
_cmd_story_info()
"unlock":
_cmd_unlock(args)
"scan":
await _cmd_scan()
"reboot", "restart":
await _cmd_reboot()
"eject":
await _cmd_eject()
"load":
append_output("[color=" + T.muted_hex + "]磁盘已加载。使用 [/color][color=" + T.primary_hex + "]eject[/color][color=" + T.muted_hex + "] 返回桌面后再切换磁盘，或使用 [/color][color=" + T.primary_hex + "]vdisc load <编号>[/color][color=" + T.muted_hex + "] 直接切换。[/color]\n", false)
_:
append_output("[color=" + T.error_hex + "][ERROR] 未知指令: " + command + "[/color]\n输入 [color=" + T.primary_hex + "]help[/color] 查看可用命令。\n", false)
# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_desktop_help() -> void:
var p: String = T.primary_hex
var lines: Array[String] = []
lines.append("[color=" + p + "]═══════════════ 桌面命令 ═══════════════[/color]")
lines.append("  [color=" + p + "]load <编号>[/color]   加载指定虚拟磁盘")
lines.append("  [color=" + p + "]scan[/color]   重新扫描vdisc目录")
lines.append("  [color=" + p + "]vdisc[/color] 查看磁盘列表详情")
lines.append("  [color=" + p + "]clear[/color] 清空屏幕")
lines.append("  [color=" + p + "]reboot[/color] 重启终端")
lines.append("  [color=" + p + "]exit[/color]   退出终端")
lines.append("[color=" + p + "]═══════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_help() -> void:
var p: String = T.primary_hex
var m: String = T.muted_hex
var lines: Array[String] = []
lines.append("[color=" + p + "]═══════════════════ 可用命令 ═══════════════════[/color]")
lines.append("  [color=" + p + "]help[/color]   显示本帮助信息")
lines.append("  [color=" + p + "]ls[/color] 列出当前目录下的文件和文件夹")
lines.append("  [color=" + p + "]cd <路径>[/color] 切换到指定目录")
lines.append("  [color=" + p + "]back[/color]   返回上一级目录")
lines.append("  [color=" + p + "]open <文件>[/color]   打开并显示文件内容")
lines.append("  [color=" + p + "]clear[/color] 清空屏幕")
lines.append("  [color=" + p + "]status[/color] 查看当前用户状态")
lines.append("  [color=" + p + "]mail[/color]   查看收件箱")
lines.append("  [color=" + p + "]whoami[/color] 查看当前用户信息")
lines.append("  [color=" + p + "]vdisc[/color] 查看虚拟磁盘列表和信息")
lines.append("  [color=" + p + "]vdisc load <编号>[/color] 切换加载指定磁盘")
lines.append("  [color=" + p + "]scan[/color]   重新扫描虚拟磁盘")
lines.append("  [color=" + p + "]unlock[/color] 进入密码认证（或 unlock <密码>）")
lines.append("  [color=" + p + "]eject[/color] 卸载磁盘，返回桌面")
lines.append("  [color=" + p + "]reboot[/color] 重启终端")
lines.append("  [color=" + p + "]exit[/color]   退出终端")
lines.append("[color=" + p + "]═══════════════════════════════════════════════[/color]")
lines.append("[color=" + m + "]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_ls() -> void:
var items := fs.get_children_at_path(current_path)
if items.is_empty():
append_output("[color=" + T.muted_hex + "]该目录为空。[/color]")
return
var lines: Array[String] = []
lines.append("[color=" + T.primary_hex + "]目录: " + current_path + "[/color]")
lines.append("")
for item in items:
var item_path := fs.join_path(current_path, item)
var node := fs.get_node_at_path(item_path)
if node == null:
continue
var item_required: int = fs.get_required_clearance(item_path)
var is_locked: bool = not fs.has_clearance(item_path)
if node.type == "folder":
if is_locked:
lines.append("  [color=" + T.error_hex + "][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
else:
lines.append("  [color=" + T.info_hex + "][DIR]  " + item + "/[/color]")
else:
if is_locked:
lines.append("  [color=" + T.error_hex + "][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
else:
var fp_key: String = fs.get_file_password_key(item_path)
if not fp_key.is_empty() and not fs.is_file_password_unlocked(item_path):
lines.append("  [color=" + T.warning_hex + "][FILE] " + item + "  [PASSWORD][/color]")
else:
lines.append("  [color=" + T.success_hex + "][FILE] " + item + "[/color]")
lines.append("")
append_output("\n".join(lines) + "\n", false)
func _cmd_cd(args: Array) -> void:
if args.is_empty():
append_output("[color=" + T.error_hex + "][ERROR] 用法: cd <目录名>[/color]")
return
var target: String = args[0]
var new_path: String
if target == "/":
new_path = "/"
elif target == "..":
new_path = fs.get_parent_path(current_path)
elif target.begins_with("/"):
new_path = target
else:
new_path = fs.join_path(current_path, target)
new_path = fs.normalize_path(new_path)
var node := fs.get_node_at_path(new_path)
if node == null:
append_output("[color=" + T.error_hex + "][ERROR] 目录不存在: " + target + "[/color]")
return
if node.type != "folder":
append_output("[color=" + T.error_hex + "][ERROR] " + target + " 不是一个目录。[/color]")
return
var required: int = fs.get_required_clearance(new_path)
if not fs.has_clearance(new_path):
var box: String = fs.build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
["输入 unlock 尝试密码认证"]
], T.error_hex)
append_output(box + "\n", false)
return
current_path = new_path
_update_status_bar()
append_output("已切换到: " + current_path + "\n", false)
func _cmd_open(args: Array) -> void:
if args.is_empty():
append_output("[color=" + T.error_hex + "][ERROR] 用法: open <文件名>[/color]")
return
var filename: String = args[0]
var file_path: String
if filename.begins_with("/"):
file_path = filename
else:
file_path = fs.join_path(current_path, filename)
file_path = fs.normalize_path(file_path)
var node := fs.get_node_at_path(file_path)
if node == null:
append_output("[color=" + T.error_hex + "][ERROR] 文件不存在: " + filename + "[/color]")
return
if node.type != "file":
append_output("[color=" + T.error_hex + "][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
return
var required: int = fs.get_required_clearance(file_path)
if not fs.has_clearance(file_path):
var box: String = fs.build_box_sectioned([
["ACCESS DENIED", "权限不足"],
["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
["输入 unlock 尝试密码认证"]
], T.error_hex)
append_output(box + "\n", false)
return
var fp_key: String = fs.get_file_password_key(file_path)
if not fp_key.is_empty() and not fs.is_file_password_unlocked(file_path):
var fp_info: Dictionary = fs.story_file_passwords[fp_key]
var hint_text: String = fp_info.get("hint", "")
var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
if not hint_text.is_empty():
box_lines.append(["提示: " + hint_text])
box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
var box: String = fs.build_box_sectioned(box_lines, T.warning_hex)
append_output(box + "\n", false)
_file_password_mode = true
_file_password_target = file_path
_file_password_filename = filename
input_field.placeholder_text = "输入文件密码..."
return
while tw.is_typing:
await get_tree().process_frame
var content_size: int = node.content.length()
await tw.show_progress_bar(content_size)
await get_tree().create_timer(0.5).timeout
output_text.text = ""
tw.clear_queue()
var header: String = "[color=" + T.primary_hex + "]══════════ " + filename + " ══════════[/color]"
output_text.append_text(header + "\n\n")
if not read_files.has(file_path):
read_files.append(file_path)
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
var clean_content: String = node.content.strip_edges()
clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
append_output(clean_content, false)
append_output("\n[color=" + T.primary_hex + "]══════════ 文件结束 ══════════[/color]\n[color=" + T.muted_hex + "]输入任意命令返回终端。[/color]\n", false)
func _cmd_back() -> void:
if current_path == "/":
append_output("[color=" + T.muted_hex + "]已经在根目录了。[/color]")
return
current_path = fs.get_parent_path(current_path)
_update_status_bar()
append_output("已返回: " + current_path + "\n", false)
func _cmd_clear() -> void:
output_text.text = ""
tw.clear_queue()
func _cmd_status() -> void:
var p: String = T.primary_hex
var w: String = T.warning_hex
var m: String = T.muted_hex
var lines: Array[String] = []
lines.append("[color=" + p + "]═══════════ 用户状态 ═══════════[/color]")
lines.append("  用户名: [color=" + p + "]未登录[/color]")
lines.append("  权限等级:   [color=" + w + "]" + str(fs.player_clearance) + "[/color]")
lines.append("  当前路径:   [color=" + p + "]" + current_path + "[/color]")
lines.append("  已读文件:   [color=" + p + "]" + str(read_files.size()) + "[/color]")
lines.append("  已获取密码: [color=" + p + "]" + str(unlocked_passwords.size()) + "[/color]")
lines.append("  已解锁文件: [color=" + p + "]" + str(fs.unlocked_file_passwords.size()) + "[/color]")
if not story_id.is_empty():
lines.append("  盘ID: [color=" + m + "]" + story_id + "[/color]")
lines.append("[color=" + p + "]════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_mail(args: Array) -> void:
append_output("[color=" + T.muted_hex + "]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)
func _cmd_exit() -> void:
append_output("[color=" + T.muted_hex + "]正在断开连接...[/color]")
await get_tree().create_timer(1.0).timeout
get_tree().quit()
func _cmd_whoami() -> void:
append_output("[color=" + T.primary_hex + "]未登录用户[/color]\n[color=" + T.muted_hex + "](用户系统将在后续版本中实现)[/color]\n", false)
func _cmd_story_info() -> void:
var p: String = T.primary_hex
var s: String = T.success_hex
var w: String = T.warning_hex
var m: String = T.muted_hex
if story_manifest.is_empty() and available_stories.is_empty():
append_output("[color=" + m + "]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
return
var lines: Array[String] = []
lines.append("[color=" + p + "]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")
if available_stories.size() > 0:
lines.append("")
lines.append("  已发现 [color=" + p + "]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
var marker: String = ""
if i == current_story_index:
marker = " [color=" + s + "]<< 当前[/color]"
lines.append("  [color=" + w + "]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=" + m + "](" + info.get("filename", "") + ")[/color]" + marker)
lines.append(" 作者: [color=" + m + "]" + info.get("author", "未知") + "[/color]")
lines.append("")
lines.append("[color=" + m + "]  使用 [/color][color=" + p + "]vdisc load <编号>[/color][color=" + m + "] 切换磁盘[/color]")
lines.append("[color=" + m + "]  使用 [/color][color=" + p + "]scan[/color][color=" + m + "] 重新扫描目录[/color]")
if story_manifest.has("story"):
lines.append("")
lines.append("[color=" + p + "]─────────── 当前磁盘详情 ───────────[/color]")
var info: Dictionary = story_manifest["story"]
lines.append("  磁盘标签: [color=" + p + "]" + info.get("title", "未知") + "[/color]")
lines.append("  制作者:   [color=" + p + "]" + info.get("author", "未知") + "[/color]")
lines.append("  版本: [color=" + p + "]" + info.get("version", "未知") + "[/color]")
if info.has("description"):
lines.append("  描述: [color=" + m + "]" + info["description"] + "[/color]")
lines.append("  文件总数: [color=" + p + "]" + str(fs.file_system.size()) + "[/color]")
lines.append("  磁盘来源: [color=" + m + "]" + current_story_path.get_file() + "[/color]")
lines.append("  磁盘状态: [color=" + s + "]已挂载[/color]")
lines.append("[color=" + p + "]═══════════════════════════════════════════[/color]")
append_output("\n".join(lines) + "\n", false)
func _cmd_vdisc_load(args: Array) -> void:
if args.is_empty():
append_output("[color=" + T.error_hex + "][ERROR] 用法: vdisc load <编号>[/color]\n[color=" + T.muted_hex + "]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=" + T.error_hex + "][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1
if index < 0 or index >= available_stories.size():
append_output("[color=" + T.error_hex + "][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
if index == current_story_index:
append_output("[color=" + T.muted_hex + "]该磁盘已经是当前加载的磁盘。[/color]\n", false)
return
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
append_output("[color=" + T.muted_hex + "]正在卸载当前磁盘...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.3).timeout
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
read_files.clear()
unlocked_passwords.clear()
await tw.show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
if _load_story_by_index(index):
var title: String = available_stories[index].get("title", "未知")
var box: String = fs.build_box_sectioned([
["DISC LOADED", "磁盘加载完成"],
[title]
], T.success_hex)
append_output(box + "\n", false)
_update_status_bar()
append_output("[color=" + T.muted_hex + "]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
append_output("[color=" + T.muted_hex + "]当前路径: " + current_path + "  权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
else:
append_output("[color=" + T.error_hex + "][ERROR] 磁盘加载失败。[/color]\n", false)
fs.init_test_file_system()
_update_status_bar()
func _cmd_unlock(args: Array) -> void:
if not args.is_empty():
_verify_password(args[0])
return
_enter_password_mode()
func _enter_password_mode(target_path: String = "") -> void:
_password_mode = true
_password_target_path = target_path
var box: String = fs.build_box_sectioned([
["SECURITY AUTHENTICATION", "安全认证系统"],
["请输入访问密码:", "(输入 cancel 取消)"]
], T.warning_hex)
append_output(box + "\n", false)
input_field.placeholder_text = "输入密码..."
func _verify_password(password: String) -> void:
if not story_manifest.has("passwords"):
append_output("[color=" + T.error_hex + "][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
return
var passwords: Dictionary = story_manifest["passwords"]
if passwords.has(password):
var pwd_info: Dictionary = passwords[password]
var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))
if unlocked_passwords.has(password):
append_output("[color=" + T.muted_hex + "]该密码已使用过。当前权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
return
if grant_level <= fs.player_clearance:
append_output("[color=" + T.muted_hex + "]该密码对应的权限等级不高于当前等级。当前: " + str(fs.player_clearance) + "[/color]\n", false)
return
unlocked_passwords.append(password)
var old_level: int = fs.player_clearance
fs.player_clearance = grant_level
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
var box: String = fs.build_box_sectioned([
["ACCESS GRANTED", "权限认证通过"],
["权限等级: " + str(old_level) + " -> " + str(fs.player_clearance)]
], T.success_hex)
append_output(box + "\n", false)
if pwd_info.has("message"):
append_output("[color=" + T.muted_hex + "]" + str(pwd_info["message"]) + "[/color]\n", false)
else:
var box: String = fs.build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], T.error_hex)
append_output(box + "\n", false)
func _verify_file_password(input_password: String) -> void:
var fp_key: String = fs.get_file_password_key(_file_password_target)
if fp_key.is_empty():
append_output("[color=" + T.error_hex + "][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
return
var fp_info: Dictionary = fs.story_file_passwords[fp_key]
var correct_password: String = str(fp_info.get("password", ""))
if input_password == correct_password:
fs.unlocked_file_passwords.append(_file_password_target)
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
var box: String = fs.build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], T.success_hex)
append_output(box + "\n", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
await _cmd_open([_file_password_filename])
else:
var box: String = fs.build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], T.error_hex)
append_output(box + "\n", false)
func _cmd_scan() -> void:
append_output("[color=" + T.muted_hex + "]正在扫描vdisc目录...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await tw.show_progress_bar(500)
await get_tree().create_timer(0.3).timeout
var old_story_path: String = current_story_path
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
read_files.clear()
unlocked_passwords.clear()
available_stories.clear()
current_story_index = -1
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
if _desktop_mode:
if available_stories.is_empty():
append_output("[color=" + T.warning_hex + "][WARN] 未找到虚拟磁盘文件。[/color]", false)
append_output("[color=" + T.muted_hex + "]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
else:
var scan_lines: Array[String] = []
scan_lines.append("[color=" + T.success_hex + "][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
scan_lines.append("")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
scan_lines.append("  [color=" + T.warning_hex + "]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=" + T.muted_hex + "](" + info.get("filename", "") + ")[/color]")
scan_lines.append("")
scan_lines.append("[color=" + T.muted_hex + "]输入 [/color][color=" + T.primary_hex + "]load <编号>[/color][color=" + T.muted_hex + "] 加载磁盘。[/color]")
append_output("\n".join(scan_lines) + "\n", false)
_update_status_bar()
else:
if available_stories.is_empty():
_desktop_mode = true
fs.init_test_file_system()
current_path = "/"
_update_status_bar()
append_output("[color=" + T.warning_hex + "][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
elif _load_story_by_index(0):
var title: String = "未知"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
append_output("[color=" + T.success_hex + "][OK] 已重新加载剧本: " + title + "[/color]", false)
append_output("[color=" + T.muted_hex + "]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
else:
current_path = "/"
_update_status_bar()
else:
append_output("[color=" + T.error_hex + "][ERROR] 重新加载失败。[/color]\n", false)
func _cmd_reboot() -> void:
append_output("[color=" + T.muted_hex + "]正在重启终端...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
output_text.text = ""
tw.clear_queue()
command_history.clear()
history_index = -1
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
has_new_mail = false
read_files.clear()
unlocked_passwords.clear()
available_stories.clear()
current_story_index = -1
save_mgr.ensure_stories_dir()
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
_scan_available_stories(vdisc_dir)
output_text.append_text("[color=" + T.muted_hex + "]...[/color]\n")
await get_tree().create_timer(0.3).timeout
output_text.append_text("[color=" + T.muted_hex + "]终端系统重新初始化中...[/color]\n")
await get_tree().create_timer(0.5).timeout
output_text.text = ""
_desktop_mode = true
_update_status_bar()
_show_desktop_welcome()
input_field.grab_focus()
# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
if command_history.is_empty():
return
if history_index == -1:
current_input_backup = input_field.text
history_index = command_history.size() - 1
elif history_index > 0:
history_index -= 1
input_field.text = command_history[history_index]
input_field.caret_column = input_field.text.length()
func _history_next() -> void:
if command_history.is_empty() or history_index == -1:
return
if history_index < command_history.size() - 1:
history_index += 1
input_field.text = command_history[history_index]
else:
history_index = -1
input_field.text = current_input_backup
input_field.caret_column = input_field.text.length()
# ============================================================
# 自动补全
# ============================================================
func _auto_complete() -> void:
var current_text: String = input_field.text
if current_text.strip_edges().is_empty():
return
var parts := current_text.split(" ", false)
if parts.size() == 1:
if current_text.ends_with(" "):
var cmd: String = parts[0].to_lower()
if cmd in ["cd", "open", "cat"]:
var children := fs.get_children_at_path(current_path)
if children.size() > 0:
var display: Array[String] = []
for child in children:
var child_path := fs.join_path(current_path, child)
var node := fs.get_node_at_path(child_path)
if node == null:
continue
if cmd == "cd" and node.type == "folder":
display.append(child + "/")
elif cmd in ["open", "cat"] and node.type == "file":
display.append(child)
elif cmd not in ["cd"]:
display.append(child)
if display.size() > 0:
output_text.append_text("\n[color=" + T.muted_hex + "]可选项: " + " | ".join(display) + "[/color]")
tw._do_scroll()
else:
var partial_cmd: String = parts[0].to_lower()
var commands: Array
if _desktop_mode:
commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
else:
commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
"scan", "reboot", "restart", "unlock", "eject"]
var matches: Array[String] = []
for cmd in commands:
if cmd.begins_with(partial_cmd):
matches.append(cmd)
if matches.size() == 1:
input_field.text = matches[0] + " "
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
output_text.append_text("\n[color=" + T.muted_hex + "]可选命令: " + " | ".join(matches) + "[/color]")
tw._do_scroll()
elif parts.size() == 2:
var cmd: String = parts[0].to_lower()
var partial_name: String = parts[1]
if cmd in ["cd", "open", "cat"]:
var children := fs.get_children_at_path(current_path)
var matches: Array[String] = []
for child in children:
if child.to_lower().begins_with(partial_name.to_lower()):
var child_path := fs.join_path(current_path, child)
var node := fs.get_node_at_path(child_path)
if node == null:
continue
if cmd == "cd" and node.type == "folder":
matches.append(child)
elif cmd in ["open", "cat"] and node.type == "file":
matches.append(child)
if matches.size() == 1:
input_field.text = cmd + " " + matches[0]
input_field.caret_column = input_field.text.length()
elif matches.size() > 1:
var common: String = _find_common_prefix(matches)
if common.length() > partial_name.length():
input_field.text = cmd + " " + common
input_field.caret_column = input_field.text.length()
output_text.append_text("\n[color=" + T.muted_hex + "]可选项: " + " | ".join(matches) + "[/color]")
tw._do_scroll()
func _find_common_prefix(strings: Array[String]) -> String:
if strings.is_empty():
return ""
if strings.size() == 1:
return strings[0]
var prefix: String = strings[0]
for i in range(1, strings.size()):
while not strings[i].to_lower().begins_with(prefix.to_lower()):
prefix = prefix.substr(0, prefix.length() - 1)
if prefix.is_empty():
return ""
return prefix
# ============================================================
# 输出工具（转发到打字机模块）
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
tw.append(text, extra_newline)
# ============================================================
# 每帧处理（滚动）
# ============================================================
func _process(_delta: float) -> void:
tw.process_scroll()
# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
if _desktop_mode:
path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
mail_icon.text = "[Mail]"
return
var disc_name: String = ""
if current_story_index >= 0 and current_story_index < available_stories.size():
disc_name = available_stories[current_story_index].get("title", "")
if disc_name.is_empty():
path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance)
else:
path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance) + "  DISC:" + disc_name
if has_new_mail:
mail_icon.text = "[Mail NEW]"
else:
mail_icon.text = "[Mail]"
# ============================================================
# 超链接处理
# ============================================================
func _on_meta_clicked(meta: Variant) -> void:
var meta_str: String = str(meta)
if meta_str.begins_with("cmd://"):
var cmd: String = meta_str.substr(6)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> " + cmd)
output_text.append_text("\n")
_execute_command(cmd)
return
if meta_str.begins_with("file://"):
var file_path: String = meta_str.substr(7)
if output_text.get_parsed_text().length() > 0:
output_text.append_text("\n")
output_text.append_text("> open " + file_path)
output_text.append_text("\n")
await _cmd_open([file_path])
return
print("[Terminal] 未知链接: " + meta_str)
# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
var p: String = T.primary_hex
var w: String = T.warning_hex
var m: String = T.muted_hex
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
var box: String = fs.build_box([title, subtitle] as Array[String], p)
output_text.append_text(box + "\n\n")
if available_stories.is_empty():
output_text.append_text("[color=" + w + "]未检测到虚拟磁盘。[/color]\n")
output_text.append_text("[color=" + m + "]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
else:
output_text.append_text("[color=" + p + "]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
for i in range(available_stories.size()):
var info: Dictionary = available_stories[i]
output_text.append_text("  [color=" + w + "]" + str(i + 1) + ".[/color] [color=" + p + "]" + info.get("title", "未知") + "[/color]\n")
output_text.append_text(" [color=" + m + "]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
output_text.append_text("\n")
output_text.append_text("[color=" + m + "]可用命令:[/color]\n")
output_text.append_text("  [color=" + p + "]load <编号>[/color]   加载指定磁盘\n")
output_text.append_text("  [color=" + p + "]scan[/color]   重新扫描磁盘目录\n")
output_text.append_text("  [color=" + p + "]clear[/color] 清空屏幕\n")
output_text.append_text("  [color=" + p + "]exit[/color]   退出终端\n")
func _cmd_desktop_load(args: Array) -> void:
if args.is_empty():
append_output("[color=" + T.error_hex + "][ERROR] 用法: load <编号>[/color]", false)
if available_stories.size() > 0:
append_output("[color=" + T.muted_hex + "]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
var index_str: String = args[0]
if not index_str.is_valid_int():
append_output("[color=" + T.error_hex + "][ERROR] 请输入有效的编号数字。[/color]\n", false)
return
var index: int = index_str.to_int() - 1
if index < 0 or index >= available_stories.size():
append_output("[color=" + T.error_hex + "][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
return
append_output("[color=" + T.muted_hex + "]正在加载虚拟磁盘...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await tw.show_progress_bar(800)
await get_tree().create_timer(0.3).timeout
if _load_story_by_index(index):
_desktop_mode = false
var title: String = available_stories[index].get("title", "未知")
output_text.text = ""
tw.clear_queue()
_update_status_bar()
_show_welcome_message()
else:
append_output("[color=" + T.error_hex + "][ERROR] 磁盘加载失败。[/color]\n", false)
func _cmd_eject() -> void:
if _desktop_mode:
append_output("[color=" + T.muted_hex + "]当前已在桌面模式。[/color]\n", false)
return
save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
append_output("[color=" + T.muted_hex + "]正在卸载磁盘...[/color]", false)
while tw.is_typing:
await get_tree().process_frame
await get_tree().create_timer(0.5).timeout
fs.clear_all()
story_manifest.clear()
current_story_path = ""
story_id = ""
current_path = "/"
read_files.clear()
unlocked_passwords.clear()
current_story_index = -1
_desktop_mode = true
output_text.text = ""
tw.clear_queue()
_update_status_bar()
_show_desktop_welcome()
# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
var p: String = T.primary_hex
var m: String = T.muted_hex
var title: String = "SCP FOUNDATION TERMINAL v0.1"
var subtitle: String = "SECURE - CONTAIN - PROTECT"
if story_manifest.has("story"):
var story_info: Dictionary = story_manifest["story"]
if story_info.has("title"):
subtitle = story_info["title"]
var title_display_len: int = fs.display_width(title)
var subtitle_display_len: int = fs.display_width(subtitle)
var inner_width: int = max(title_display_len, subtitle_display_len) + 6
var title_pad_total: int = inner_width - title_display_len
var title_pad_left: int = title_pad_total / 2
var title_pad_right: int = title_pad_total - title_pad_left
var subtitle_pad_total: int = inner_width - subtitle_display_len
var subtitle_pad_left: int = subtitle_pad_total / 2
var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left
var border_h: String = "═".repeat(inner_width)
var welcome: String = ""
welcome += "[color=" + p + "]╔" + border_h + "╗\n"
welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
welcome += "╚" + border_h + "╝[/color]\n"
welcome += "\n"
welcome += "[color=" + m + "]终端系统已启动。\n"
welcome += "输入 [/color][color=" + p + "]help[/color][color=" + m + "] 查看可用命令。[/color]\n"
output_text.append_text(welcome)
# ============================================================
# 剧本加载系统
# ============================================================
func _try_load_story() -> bool:
var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
print("[StoryLoader] 搜索目录: " + vdisc_dir)
_scan_available_stories(vdisc_dir)
return not available_stories.is_empty()
func _scan_available_stories(vdisc_dir: String) -> void:
available_stories.clear()
if not DirAccess.dir_exists_absolute(vdisc_dir):
return
var dir := DirAccess.open(vdisc_dir)
if dir == null:
return
dir.list_dir_begin()
var file_name := dir.get_next()
while file_name != "":
if file_name.ends_with(".scp") or file_name.ends_with(".zip"):
var full_path: String = vdisc_dir + file_name
var info: Dictionary = _peek_story_info(full_path)
info["path"] = full_path
info["filename"] = file_name
available_stories.append(info)
print("[StoryLoader] 发现剧本: " + file_name + " -> " + info.get("title", "未知"))
file_name = dir.get_next()
print("[StoryLoader] 共发现 " + str(available_stories.size()) + " 个剧本文件")
func _peek_story_info(path: String) -> Dictionary:
var info: Dictionary = {"title": "未知剧本", "id": "", "author": "未知"}
var reader := ZIPReader.new()
if reader.open(path) != OK:
return info
var files := reader.get_files()
for file_path in files:
var filename: String = file_path.get_file()
if filename == "manifest.json":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
var json := JSON.new()
if json.parse(content) == OK and json.data is Dictionary:
var data: Dictionary = json.data
if data.has("story"):
var story_info: Dictionary = data["story"]
info["title"] = story_info.get("title", "未知剧本")
info["id"] = story_info.get("id", "")
info["author"] = story_info.get("author", "未知")
break
elif filename == "manifest.cfg":
var content_bytes := reader.read_file(file_path)
if content_bytes != null:
var content: String = content_bytes.get_string_from_utf8()
for line in content.split("\n"):
line = line.strip_edges()
if line.begins_with("title="):
info["title"] = line.substr(6).strip_edges()
elif line.begins_with("id="):
info["id"] = line.substr(3).strip_edges()
elif line.begins_with("author="):
info["author"] = line.substr(7).strip_edges()
break
reader.close()
return info
func _load_story_by_index(index: int) -> bool:
if index < 0 or index >= available_stories.size():
return false
var story_info: Dictionary = available_stories[index]
var path: String = story_info["path"]
if _load_story_file(path):
current_story_index = index
return true
return false
func _load_story_file(path: String) -> bool:
story_loader = StoryLoader.new()
if not story_loader.load_story(path):
print("[StoryLoader] 加载失败: " + story_loader.error_message)
return false
fs.file_system = story_loader.file_system
story_manifest = story_loader.manifest
current_story_path = path
if story_manifest.has("story") and story_manifest["story"].has("id"):
story_id = story_manifest["story"]["id"]
else:
story_id = str(path.get_file().hash())
fs.story_permissions.clear()
if story_manifest.has("permissions"):
var perms: Dictionary = story_manifest["permissions"]
for perm_path in perms.keys():
fs.story_permissions[perm_path] = int(perms[perm_path])
print("[StoryLoader] 权限表已加载，共 " + str(fs.story_permissions.size()) + " 条规则")
else:
print("[StoryLoader] 警告: manifest中未找到permissions字段")
if story_manifest.has("passwords"):
print("[StoryLoader] 密码表已加载，共 " + str(story_manifest["passwords"].size()) + " 个密码")
else:
print("[StoryLoader] 警告: manifest中未找到passwords字段")
# 读取文件密码表
fs.story_file_passwords.clear()
if story_manifest.has("file_passwords"):
var fps: Dictionary = story_manifest["file_passwords"]
for fp_path in fps.keys():
fs.story_file_passwords[fp_path] = fps[fp_path]
print("[StoryLoader] 文件密码表已加载，共 " + str(fs.story_file_passwords.size()) + " 条")
else:
print("[StoryLoader] 未配置文件密码表（file_passwords）")
# 应用 manifest 中的设置
var start_clearance: int = 0
if story_manifest.has("settings"):
var settings: Dictionary = story_manifest["settings"]
if settings.has("start_path"):
current_path = settings["start_path"]
if settings.has("typing_speed"):
tw.base_speed = settings["typing_speed"].to_float()
if settings.has("start_clearance"):
start_clearance = int(settings["start_clearance"])
# 尝试加载该剧本的存档
var save_data = save_mgr.load_save(story_id)
if save_data != null:
fs.player_clearance = int(save_data.get("player_clearance", 0))
read_files.clear()
if save_data.has("read_files"):
for f in save_data["read_files"]:
read_files.append(str(f))
unlocked_passwords.clear()
if save_data.has("unlocked_passwords"):
for p in save_data["unlocked_passwords"]:
unlocked_passwords.append(str(p))
fs.unlocked_file_passwords.clear()
if save_data.has("unlocked_file_passwords"):
for p in save_data["unlocked_file_passwords"]:
fs.unlocked_file_passwords.append(str(p))
if save_data.has("current_path"):
var saved_path: String = save_data["current_path"]
if fs.has_clearance(saved_path):
current_path = saved_path
else:
current_path = "/"
if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
current_path = story_manifest["settings"]["start_path"]
print("[Save] 权限等级: " + str(fs.player_clearance))
else:
# 没有存档，用初始权限
fs.player_clearance = start_clearance
read_files.clear()
unlocked_passwords.clear()
var title: String = "未知剧本"
if story_manifest.has("story") and story_manifest["story"].has("title"):
title = story_manifest["story"]["title"]
print("[StoryLoader] 成功加载: " + title)
print("[StoryLoader] 盘ID: " + story_id)
print("[StoryLoader] 文件数量: " + str(fs.file_system.size()))
print("[StoryLoader] 权限等级: " + str(fs.player_clearance))
print("[StoryLoader] story_permissions 内容: " + str(fs.story_permissions))
print("[StoryLoader] passwords 存在: " + str(story_manifest.has("passwords")))
return true

### ASSISTANT
好的，按照规划开始拆分 `input_handler.gd`。这个模块负责所有输入事件处理、命令历史导航、自动补全和右键复制。

## 拆分设计

**`InputHandler` 需要访问 `main.gd` 的内容：**
- 节点引用：`output_text`、`input_field`、`scroll_container`
- 模块引用：`tw`（Typewriter）、`fs`（FileSystem）
- 状态变量：`command_history`、`history_index`、`current_input_backup`、`_desktop_mode`、`current_path`
- 回调：提交命令时需要调用 `main._on_command_submitted()`

**采用方案：** `InputHandler` 持有一个指向 `main` 的引用（`terminal`），通过它访问所有需要的数据。

---

### 新文件：`input_handler.gd`

```gdscript
# ============================================================
# input_handler.gd — 输入事件处理模块
# 职责：鼠标事件、键盘快捷键分发、命令历史、自动补全、右键复制
# ============================================================
class_name InputHandler
extends RefCounted

# 对主终端的引用
var terminal: Control = null

# 主题色快捷引用
var T: ThemeManager.ThemeColors = null

# ============================================================
# 初始化
# ============================================================
func setup(term: Control) -> void:
	terminal = term
	T = ThemeManager.current

# ============================================================
# 主输入处理（由 main._input() 调用）
# ============================================================
func handle_input(event: InputEvent) -> void:
	# --- 鼠标事件处理 ---
	if event is InputEventMouseButton and event.pressed:
		match event.button_index:
			MOUSE_BUTTON_WHEEL_UP:
				terminal.scroll_container.scroll_vertical -= 60
				terminal.get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_WHEEL_DOWN:
				terminal.scroll_container.scroll_vertical += 60
				terminal.get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_RIGHT:
				_handle_right_click()
				terminal.get_viewport().set_input_as_handled()
				return
			MOUSE_BUTTON_LEFT:
				var mouse_pos: Vector2 = event.position
				var output_rect: Rect2 = terminal.output_text.get_global_rect()
				if output_rect.has_point(mouse_pos):
					return
				terminal.input_field.grab_focus()
				return

	# 鼠标释放时，如果不在输出区，重新聚焦输入框
	if event is InputEventMouseButton and not event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			var mouse_pos: Vector2 = event.position
			var output_rect: Rect2 = terminal.output_text.get_global_rect()
			if not output_rect.has_point(mouse_pos):
				terminal.input_field.grab_focus()
			return

	# --- 非键盘事件忽略 ---
	if not event is InputEventKey or not event.pressed:
		return

	# 确保输入框有焦点
	if not terminal.input_field.has_focus():
		terminal.input_field.grab_focus()

	# 打字机播放中：空格或ESC跳过
	if terminal.tw.is_typing and event.keycode in [KEY_SPACE, KEY_ESCAPE]:
		terminal.tw.skip()
		terminal.get_viewport().set_input_as_handled()
		return

	# --- 键盘快捷键分发 ---
	match event.keycode:
		KEY_ENTER, KEY_KP_ENTER:
			if terminal.tw.is_typing:
				terminal.get_viewport().set_input_as_handled()
			else:
				var command_text: String = terminal.input_field.text
				terminal.input_field.clear()
				terminal._on_command_submitted(command_text)
				terminal.get_viewport().set_input_as_handled()
		KEY_UP:
			_history_previous()
			terminal.get_viewport().set_input_as_handled()
		KEY_DOWN:
			_history_next()
			terminal.get_viewport().set_input_as_handled()
		KEY_PAGEUP:
			terminal.scroll_container.scroll_vertical -= 100
			terminal.get_viewport().set_input_as_handled()
		KEY_PAGEDOWN:
			terminal.scroll_container.scroll_vertical += 100
			terminal.get_viewport().set_input_as_handled()
		KEY_TAB:
			_auto_complete()
			terminal.get_viewport().set_input_as_handled()

# ============================================================
# 右键复制
# ============================================================
func _handle_right_click() -> void:
	var selected_text: String = terminal.output_text.get_selected_text()
	if not selected_text.is_empty():
		DisplayServer.clipboard_set(selected_text)
		terminal.output_text.deselect()
		terminal.input_field.grab_focus()
		_show_copy_toast()

# ============================================================
# 复制成功提示（短暂显示后自动消失）
# ============================================================
func _show_copy_toast() -> void:
	var m: String = T.muted_hex
	var toast_tag: String = "[color=" + m + "][已复制到剪贴板][/color]"
	terminal.output_text.append_text("\n" + toast_tag)
	# 1.5秒后移除提示
	await terminal.get_tree().create_timer(1.5).timeout
	var current_bbcode: String = terminal.output_text.text
	if current_bbcode.ends_with(toast_tag):
		terminal.output_text.text = current_bbcode.substr(0, current_bbcode.length() - toast_tag.length()).rstrip("\n")

# ============================================================
# 命令历史导航
# ============================================================
func _history_previous() -> void:
	if terminal.command_history.is_empty():
		return
	if terminal.history_index == -1:
		terminal.current_input_backup = terminal.input_field.text
		terminal.history_index = terminal.command_history.size() - 1
	elif terminal.history_index > 0:
		terminal.history_index -= 1
	terminal.input_field.text = terminal.command_history[terminal.history_index]
	terminal.input_field.caret_column = terminal.input_field.text.length()

func _history_next() -> void:
	if terminal.command_history.is_empty() or terminal.history_index == -1:
		return
	if terminal.history_index < terminal.command_history.size() - 1:
		terminal.history_index += 1
		terminal.input_field.text = terminal.command_history[terminal.history_index]
	else:
		terminal.history_index = -1
		terminal.input_field.text = terminal.current_input_backup
	terminal.input_field.caret_column = terminal.input_field.text.length()

# ============================================================
# 自动补全
# ============================================================
func _auto_complete() -> void:
	var current_text: String = terminal.input_field.text
	if current_text.strip_edges().is_empty():
		return

	var parts := current_text.split(" ", false)

	if parts.size() == 1:
		if current_text.ends_with(" "):
			_complete_file_args(parts[0].to_lower())
		else:
			_complete_command(parts[0].to_lower())
	elif parts.size() == 2:
		_complete_file_name(parts[0].to_lower(), parts[1])

# ---- 命令名补全 ----
func _complete_command(partial_cmd: String) -> void:
	var commands: Array
	if terminal._desktop_mode:
		commands = ["help", "load", "scan", "vdisc", "clear", "cls", "exit", "quit", "reboot", "restart"]
	else:
		commands = ["help", "ls", "dir", "cd", "open", "cat", "back",
			"clear", "cls", "status", "mail", "whoami", "exit", "quit", "vdisc",
			"scan", "reboot", "restart", "unlock", "eject"]

	var matches: Array[String] = []
	for cmd in commands:
		if cmd.begins_with(partial_cmd):
			matches.append(cmd)

	if matches.size() == 1:
		terminal.input_field.text = matches[0] + " "
		terminal.input_field.caret_column = terminal.input_field.text.length()
	elif matches.size() > 1:
		terminal.output_text.append_text("\n[color=" + T.muted_hex + "]可选命令: " + " | ".join(matches) + "[/color]")
		terminal.tw._do_scroll()

# ---- 文件/目录参数列表（命令后面按空格时） ----
func _complete_file_args(cmd: String) -> void:
	if cmd not in ["cd", "open", "cat"]:
		return

	var children := terminal.fs.get_children_at_path(terminal.current_path)
	if children.is_empty():
		return

	var display: Array[String] = []
	for child in children:
		var child_path := terminal.fs.join_path(terminal.current_path, child)
		var node := terminal.fs.get_node_at_path(child_path)
		if node == null:
			continue
		if cmd == "cd" and node.type == "folder":
			display.append(child + "/")
		elif cmd in ["open", "cat"] and node.type == "file":
			display.append(child)
		elif cmd not in ["cd"]:
			display.append(child)

	if display.size() > 0:
		terminal.output_text.append_text("\n[color=" + T.muted_hex + "]可选项: " + " | ".join(display) + "[/color]")
		terminal.tw._do_scroll()

# ---- 文件/目录名部分补全 ----
func _complete_file_name(cmd: String, partial_name: String) -> void:
	if cmd not in ["cd", "open", "cat"]:
		return

	var children := terminal.fs.get_children_at_path(terminal.current_path)
	var matches: Array[String] = []

	for child in children:
		if child.to_lower().begins_with(partial_name.to_lower()):
			var child_path := terminal.fs.join_path(terminal.current_path, child)
			var node := terminal.fs.get_node_at_path(child_path)
			if node == null:
				continue
			if cmd == "cd" and node.type == "folder":
				matches.append(child)
			elif cmd in ["open", "cat"] and node.type == "file":
				matches.append(child)

	if matches.size() == 1:
		terminal.input_field.text = cmd + " " + matches[0]
		terminal.input_field.caret_column = terminal.input_field.text.length()
	elif matches.size() > 1:
		var common: String = _find_common_prefix(matches)
		if common.length() > partial_name.length():
			terminal.input_field.text = cmd + " " + common
			terminal.input_field.caret_column = terminal.input_field.text.length()
		terminal.output_text.append_text("\n[color=" + T.muted_hex + "]可选项: " + " | ".join(matches) + "[/color]")
		terminal.tw._do_scroll()

# ---- 公共前缀查找 ----
func _find_common_prefix(strings: Array[String]) -> String:
	if strings.is_empty():
		return ""
	if strings.size() == 1:
		return strings[0]
	var prefix: String = strings[0]
	for i in range(1, strings.size()):
		while not strings[i].to_lower().begins_with(prefix.to_lower()):
			prefix = prefix.substr(0, prefix.length() - 1)
			if prefix.is_empty():
				return ""
	return prefix
```

---

### 修改后的 `main.gd`（完整版）

```gdscript
extends Control
# ============================================================
# 节点引用
# ============================================================
@onready var path_label: Label = $MainContent/StatusFrame/StatusBar/PathLabel
@onready var mail_icon: Label = $MainContent/StatusFrame/StatusBar/MailIcon
@onready var output_text: RichTextLabel = $MainContent/OutputArea/OutputText
@onready var input_field: LineEdit = $MainContent/InputFrame/InputArea/InputField
@onready var scroll_container: ScrollContainer = $MainContent/OutputArea
@onready var status_frame: PanelContainer = $MainContent/StatusFrame
@onready var input_frame: PanelContainer = $MainContent/InputFrame
var background: TextureRect = null  # 由 UIManager 创建

# 模块实例
var save_mgr: SaveManager = SaveManager.new()
var fs: FileSystem = FileSystem.new()
var tw: Typewriter = null
var input_handler: InputHandler = InputHandler.new()

# 主题色快捷引用（在 _ready 中初始化）
var T: ThemeManager.ThemeColors = null

# ============================================================
# 状态变量
# ============================================================
var current_path: String = "/"
var has_new_mail: bool = false
var command_history: Array[String] = []
var history_index: int = -1
var current_input_backup: String = ""

# 桌面/终端模式
var _desktop_mode: bool = true

# ============================================================
# 剧本系统
# ============================================================
var story_loader: StoryLoader = null
var story_manifest: Dictionary = {}
var current_story_path: String = ""
var available_stories: Array[Dictionary] = []
var current_story_index: int = -1
var story_id: String = ""
var read_files: Array[String] = []
var unlocked_passwords: Array[String] = []

# 密码输入弹窗状态
var _password_mode: bool = false
var _password_target_path: String = ""

# 文件密码系统
var _file_password_mode: bool = false
var _file_password_target: String = ""
var _file_password_filename: String = ""

# ============================================================
# 初始化
# ============================================================
func _ready() -> void:
	# 初始化主题系统（必须最先调用）
	ThemeManager.init("phosphor_green")
	T = ThemeManager.current

	# 初始化打字机模块
	tw = Typewriter.new()
	tw.name = "Typewriter"
	add_child(tw)

	# 初始化输入处理模块
	input_handler.setup(self)

	save_mgr.ensure_stories_dir()
	save_mgr.ensure_saves_dir()

	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	# === UI 初始化（全部委托给 UIManager） ===
	background = UIManager.setup_background(self, save_mgr.get_game_root_dir())
	UIManager.setup_main_content(self, $MainContent)
	UIManager.setup_all_styles(status_frame, path_label, mail_icon, input_frame, input_field, output_text, scroll_container)

	# CRT效果层鼠标穿透
	UIManager.setup_crt_effect($CRTEffect)

	# 自定义CRT风格鼠标光标
	UIManager.setup_custom_cursor(self)

	# 连接超链接信号
	output_text.meta_clicked.connect(_on_meta_clicked)

	# 初始化打字机引用
	tw.setup(output_text, scroll_container)

	# 输入框设置
	input_field.focus_mode = Control.FOCUS_ALL
	input_field.focus_next = input_field.get_path()
	input_field.focus_previous = input_field.get_path()
	input_field.grab_focus()

	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()

# ============================================================
# 输入处理（委托给 InputHandler）
# ============================================================
func _input(event: InputEvent) -> void:
	input_handler.handle_input(event)

# ============================================================
# 命令提交处理
# ============================================================
func _on_command_submitted(command_text: String) -> void:
	var raw_input: String = command_text.strip_edges()
	input_field.clear()

	if raw_input.is_empty():
		return

	if _file_password_mode:
		_file_password_mode = false
		input_field.placeholder_text = "> 输入命令..."
		while tw.is_typing:
			await get_tree().process_frame
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
		if raw_input.to_lower() == "cancel":
			append_output("[color=" + T.muted_hex + "]已取消文件密码输入。[/color]\n", false)
			_file_password_target = ""
			_file_password_filename = ""
			return
		await _verify_file_password(raw_input)
		return

	if _password_mode:
		_password_mode = false
		input_field.placeholder_text = "> 输入命令..."
		while tw.is_typing:
			await get_tree().process_frame
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + "*".repeat(raw_input.length()) + "\n")
		if raw_input.to_lower() == "cancel":
			append_output("[color=" + T.muted_hex + "]已取消密码输入。[/color]\n", false)
			return
		_verify_password(raw_input)
		return

	command_history.append(raw_input)
	history_index = -1

	while tw.is_typing:
		await get_tree().process_frame

	if output_text.get_parsed_text().length() > 0:
		output_text.append_text("\n")
	output_text.append_text("> " + raw_input + "\n")

	await _execute_command(raw_input)

# ============================================================
# 命令解析与执行
# ============================================================
func _execute_command(raw_input: String) -> void:
	tw.instant = false
	var parts := raw_input.split(" ", false)
	if parts.is_empty():
		return

	var command: String = parts[0].to_lower()
	var args := parts.slice(1)

	if _desktop_mode:
		match command:
			"load":
				await _cmd_desktop_load(args)
			"scan":
				await _cmd_scan()
			"clear", "cls":
				_cmd_clear()
			"exit", "quit":
				await _cmd_exit()
			"help", "?":
				_cmd_desktop_help()
			"vdisc", "disc", "disk":
				_cmd_story_info()
			"reboot", "restart":
				await _cmd_reboot()
			_:
				append_output("[color=" + T.error_hex + "][ERROR] 未知指令: " + command + "[/color]\n[color=" + T.muted_hex + "]输入 [/color][color=" + T.primary_hex + "]help[/color][color=" + T.muted_hex + "] 查看可用命令。[/color]\n", false)
		return

	match command:
		"help", "?":
			_cmd_help()
		"ls", "dir":
			_cmd_ls()
		"cd":
			_cmd_cd(args)
		"open", "cat":
			await _cmd_open(args)
		"back":
			_cmd_back()
		"clear", "cls":
			_cmd_clear()
		"status":
			_cmd_status()
		"mail":
			_cmd_mail(args)
		"exit", "quit":
			await _cmd_exit()
		"whoami":
			_cmd_whoami()
		"vdisc", "disc", "disk":
			if args.size() >= 1 and args[0].to_lower() == "load":
				await _cmd_vdisc_load(args.slice(1))
			else:
				_cmd_story_info()
		"unlock":
			_cmd_unlock(args)
		"scan":
			await _cmd_scan()
		"reboot", "restart":
			await _cmd_reboot()
		"eject":
			await _cmd_eject()
		"load":
			append_output("[color=" + T.muted_hex + "]磁盘已加载。使用 [/color][color=" + T.primary_hex + "]eject[/color][color=" + T.muted_hex + "] 返回桌面后再切换磁盘，或使用 [/color][color=" + T.primary_hex + "]vdisc load <编号>[/color][color=" + T.muted_hex + "] 直接切换。[/color]\n", false)
		_:
			append_output("[color=" + T.error_hex + "][ERROR] 未知指令: " + command + "[/color]\n输入 [color=" + T.primary_hex + "]help[/color] 查看可用命令。\n", false)

# ============================================================
# 各命令的具体实现
# ============================================================
func _cmd_desktop_help() -> void:
	var p: String = T.primary_hex
	var lines: Array[String] = []
	lines.append("[color=" + p + "]═══════════════ 桌面命令 ═══════════════[/color]")
	lines.append("  [color=" + p + "]load <编号>[/color]   加载指定虚拟磁盘")
	lines.append("  [color=" + p + "]scan[/color]   重新扫描vdisc目录")
	lines.append("  [color=" + p + "]vdisc[/color] 查看磁盘列表详情")
	lines.append("  [color=" + p + "]clear[/color] 清空屏幕")
	lines.append("  [color=" + p + "]reboot[/color] 重启终端")
	lines.append("  [color=" + p + "]exit[/color]   退出终端")
	lines.append("[color=" + p + "]═══════════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_help() -> void:
	var p: String = T.primary_hex
	var m: String = T.muted_hex
	var lines: Array[String] = []
	lines.append("[color=" + p + "]═══════════════════ 可用命令 ═══════════════════[/color]")
	lines.append("  [color=" + p + "]help[/color]   显示本帮助信息")
	lines.append("  [color=" + p + "]ls[/color] 列出当前目录下的文件和文件夹")
	lines.append("  [color=" + p + "]cd <路径>[/color] 切换到指定目录")
	lines.append("  [color=" + p + "]back[/color]   返回上一级目录")
	lines.append("  [color=" + p + "]open <文件>[/color]   打开并显示文件内容")
	lines.append("  [color=" + p + "]clear[/color] 清空屏幕")
	lines.append("  [color=" + p + "]status[/color] 查看当前用户状态")
	lines.append("  [color=" + p + "]mail[/color]   查看收件箱")
	lines.append("  [color=" + p + "]whoami[/color] 查看当前用户信息")
	lines.append("  [color=" + p + "]vdisc[/color] 查看虚拟磁盘列表和信息")
	lines.append("  [color=" + p + "]vdisc load <编号>[/color] 切换加载指定磁盘")
	lines.append("  [color=" + p + "]scan[/color]   重新扫描虚拟磁盘")
	lines.append("  [color=" + p + "]unlock[/color] 进入密码认证（或 unlock <密码>）")
	lines.append("  [color=" + p + "]eject[/color] 卸载磁盘，返回桌面")
	lines.append("  [color=" + p + "]reboot[/color] 重启终端")
	lines.append("  [color=" + p + "]exit[/color]   退出终端")
	lines.append("[color=" + p + "]═══════════════════════════════════════════════[/color]")
	lines.append("[color=" + m + "]快捷键: ↑↓ 历史命令 | PageUp/Down 滚动 | Tab 自动补全[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_ls() -> void:
	var items := fs.get_children_at_path(current_path)
	if items.is_empty():
		append_output("[color=" + T.muted_hex + "]该目录为空。[/color]")
		return

	var lines: Array[String] = []
	lines.append("[color=" + T.primary_hex + "]目录: " + current_path + "[/color]")
	lines.append("")

	for item in items:
		var item_path := fs.join_path(current_path, item)
		var node := fs.get_node_at_path(item_path)
		if node == null:
			continue
		var item_required: int = fs.get_required_clearance(item_path)
		var is_locked: bool = not fs.has_clearance(item_path)
		if node.type == "folder":
			if is_locked:
				lines.append("  [color=" + T.error_hex + "][DIR]  " + item + "/  【LOCKED LV." + str(item_required) + "】[/color]")
			else:
				lines.append("  [color=" + T.info_hex + "][DIR]  " + item + "/[/color]")
		else:
			if is_locked:
				lines.append("  [color=" + T.error_hex + "][FILE] " + item + "  【LOCKED LV." + str(item_required) + "】[/color]")
			else:
				var fp_key: String = fs.get_file_password_key(item_path)
				if not fp_key.is_empty() and not fs.is_file_password_unlocked(item_path):
					lines.append("  [color=" + T.warning_hex + "][FILE] " + item + "  [PASSWORD][/color]")
				else:
					lines.append("  [color=" + T.success_hex + "][FILE] " + item + "[/color]")
	lines.append("")
	append_output("\n".join(lines) + "\n", false)

func _cmd_cd(args: Array) -> void:
	if args.is_empty():
		append_output("[color=" + T.error_hex + "][ERROR] 用法: cd <目录名>[/color]")
		return

	var target: String = args[0]
	var new_path: String
	if target == "/":
		new_path = "/"
	elif target == "..":
		new_path = fs.get_parent_path(current_path)
	elif target.begins_with("/"):
		new_path = target
	else:
		new_path = fs.join_path(current_path, target)
	new_path = fs.normalize_path(new_path)

	var node := fs.get_node_at_path(new_path)
	if node == null:
		append_output("[color=" + T.error_hex + "][ERROR] 目录不存在: " + target + "[/color]")
		return
	if node.type != "folder":
		append_output("[color=" + T.error_hex + "][ERROR] " + target + " 不是一个目录。[/color]")
		return

	var required: int = fs.get_required_clearance(new_path)
	if not fs.has_clearance(new_path):
		var box: String = fs.build_box_sectioned([
			["ACCESS DENIED", "权限不足"],
			["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
			["输入 unlock 尝试密码认证"]
		], T.error_hex)
		append_output(box + "\n", false)
		return

	current_path = new_path
	_update_status_bar()
	append_output("已切换到: " + current_path + "\n", false)

func _cmd_open(args: Array) -> void:
	if args.is_empty():
		append_output("[color=" + T.error_hex + "][ERROR] 用法: open <文件名>[/color]")
		return

	var filename: String = args[0]
	var file_path: String
	if filename.begins_with("/"):
		file_path = filename
	else:
		file_path = fs.join_path(current_path, filename)
	file_path = fs.normalize_path(file_path)

	var node := fs.get_node_at_path(file_path)
	if node == null:
		append_output("[color=" + T.error_hex + "][ERROR] 文件不存在: " + filename + "[/color]")
		return
	if node.type != "file":
		append_output("[color=" + T.error_hex + "][ERROR] " + filename + " 是一个目录，请使用 cd 命令进入。[/color]")
		return

	var required: int = fs.get_required_clearance(file_path)
	if not fs.has_clearance(file_path):
		var box: String = fs.build_box_sectioned([
			["ACCESS DENIED", "权限不足"],
			["需要等级: " + str(required) + "  当前等级: " + str(fs.player_clearance)],
			["输入 unlock 尝试密码认证"]
		], T.error_hex)
		append_output(box + "\n", false)
		return

	var fp_key: String = fs.get_file_password_key(file_path)
	if not fp_key.is_empty() and not fs.is_file_password_unlocked(file_path):
		var fp_info: Dictionary = fs.story_file_passwords[fp_key]
		var hint_text: String = fp_info.get("hint", "")
		var box_lines: Array = [["FILE PASSWORD REQUIRED", "此文件需要输入密码"]]
		if not hint_text.is_empty():
			box_lines.append(["提示: " + hint_text])
		box_lines.append(["请输入密码:", "(输入 cancel 取消)"])
		var box: String = fs.build_box_sectioned(box_lines, T.warning_hex)
		append_output(box + "\n", false)
		_file_password_mode = true
		_file_password_target = file_path
		_file_password_filename = filename
		input_field.placeholder_text = "输入文件密码..."
		return

	while tw.is_typing:
		await get_tree().process_frame

	var content_size: int = node.content.length()
	await tw.show_progress_bar(content_size)
	await get_tree().create_timer(0.5).timeout

	output_text.text = ""
	tw.clear_queue()
	var header: String = "[color=" + T.primary_hex + "]══════════ " + filename + " ══════════[/color]"
	output_text.append_text(header + "\n\n")

	if not read_files.has(file_path):
		read_files.append(file_path)
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

	var clean_content: String = node.content.strip_edges()
	clean_content = clean_content.replace("\r\n", "\n").replace("\r", "\n")
	append_output(clean_content, false)
	append_output("\n[color=" + T.primary_hex + "]══════════ 文件结束 ══════════[/color]\n[color=" + T.muted_hex + "]输入任意命令返回终端。[/color]\n", false)

func _cmd_back() -> void:
	if current_path == "/":
		append_output("[color=" + T.muted_hex + "]已经在根目录了。[/color]")
		return
	current_path = fs.get_parent_path(current_path)
	_update_status_bar()
	append_output("已返回: " + current_path + "\n", false)

func _cmd_clear() -> void:
	output_text.text = ""
	tw.clear_queue()

func _cmd_status() -> void:
	var p: String = T.primary_hex
	var w: String = T.warning_hex
	var m: String = T.muted_hex
	var lines: Array[String] = []
	lines.append("[color=" + p + "]═══════════ 用户状态 ═══════════[/color]")
	lines.append("  用户名: [color=" + p + "]未登录[/color]")
	lines.append("  权限等级:   [color=" + w + "]" + str(fs.player_clearance) + "[/color]")
	lines.append("  当前路径:   [color=" + p + "]" + current_path + "[/color]")
	lines.append("  已读文件:   [color=" + p + "]" + str(read_files.size()) + "[/color]")
	lines.append("  已获取密码: [color=" + p + "]" + str(unlocked_passwords.size()) + "[/color]")
	lines.append("  已解锁文件: [color=" + p + "]" + str(fs.unlocked_file_passwords.size()) + "[/color]")
	if not story_id.is_empty():
		lines.append("  盘ID: [color=" + m + "]" + story_id + "[/color]")
	lines.append("[color=" + p + "]════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_mail(args: Array) -> void:
	append_output("[color=" + T.muted_hex + "]收件箱为空。\n(邮件系统将在后续版本中实现)[/color]\n", false)

func _cmd_exit() -> void:
	append_output("[color=" + T.muted_hex + "]正在断开连接...[/color]")
	await get_tree().create_timer(1.0).timeout
	get_tree().quit()

func _cmd_whoami() -> void:
	append_output("[color=" + T.primary_hex + "]未登录用户[/color]\n[color=" + T.muted_hex + "](用户系统将在后续版本中实现)[/color]\n", false)

func _cmd_story_info() -> void:
	var p: String = T.primary_hex
	var s: String = T.success_hex
	var w: String = T.warning_hex
	var m: String = T.muted_hex

	if story_manifest.is_empty() and available_stories.is_empty():
		append_output("[color=" + m + "]未检测到外部虚拟磁盘，当前运行于内置诊断模式。\n将 .scp 或 .zip 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n", false)
		return

	var lines: Array[String] = []
	lines.append("[color=" + p + "]═══════════════ 虚拟磁盘管理 ═══════════════[/color]")

	if available_stories.size() > 0:
		lines.append("")
		lines.append("  已发现 [color=" + p + "]" + str(available_stories.size()) + "[/color] 个虚拟磁盘:")
		lines.append("")
		for i in range(available_stories.size()):
			var info: Dictionary = available_stories[i]
			var marker: String = ""
			if i == current_story_index:
				marker = " [color=" + s + "]<< 当前[/color]"
			lines.append("  [color=" + w + "]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=" + m + "](" + info.get("filename", "") + ")[/color]" + marker)
			lines.append("     作者: [color=" + m + "]" + info.get("author", "未知") + "[/color]")
		lines.append("")
		lines.append("[color=" + m + "]  使用 [/color][color=" + p + "]vdisc load <编号>[/color][color=" + m + "] 切换磁盘[/color]")
		lines.append("[color=" + m + "]  使用 [/color][color=" + p + "]scan[/color][color=" + m + "] 重新扫描目录[/color]")

	if story_manifest.has("story"):
		lines.append("")
		lines.append("[color=" + p + "]─────────── 当前磁盘详情 ───────────[/color]")
		var info: Dictionary = story_manifest["story"]
		lines.append("  磁盘标签: [color=" + p + "]" + info.get("title", "未知") + "[/color]")
		lines.append("  制作者:   [color=" + p + "]" + info.get("author", "未知") + "[/color]")
		lines.append("  版本: [color=" + p + "]" + info.get("version", "未知") + "[/color]")
		if info.has("description"):
			lines.append("  描述: [color=" + m + "]" + info["description"] + "[/color]")
		lines.append("  文件总数: [color=" + p + "]" + str(fs.file_system.size()) + "[/color]")
		lines.append("  磁盘来源: [color=" + m + "]" + current_story_path.get_file() + "[/color]")
		lines.append("  磁盘状态: [color=" + s + "]已挂载[/color]")

	lines.append("[color=" + p + "]═══════════════════════════════════════════[/color]")
	append_output("\n".join(lines) + "\n", false)

func _cmd_vdisc_load(args: Array) -> void:
	if args.is_empty():
		append_output("[color=" + T.error_hex + "][ERROR] 用法: vdisc load <编号>[/color]\n[color=" + T.muted_hex + "]输入 vdisc 查看可用磁盘列表。[/color]\n", false)
		return

	var index_str: String = args[0]
	if not index_str.is_valid_int():
		append_output("[color=" + T.error_hex + "][ERROR] 请输入有效的编号数字。[/color]\n", false)
		return

	var index: int = index_str.to_int() - 1
	if index < 0 or index >= available_stories.size():
		append_output("[color=" + T.error_hex + "][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return

	if index == current_story_index:
		append_output("[color=" + T.muted_hex + "]该磁盘已经是当前加载的磁盘。[/color]\n", false)
		return

	save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

	append_output("[color=" + T.muted_hex + "]正在卸载当前磁盘...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.3).timeout

	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	read_files.clear()
	unlocked_passwords.clear()

	await tw.show_progress_bar(800)
	await get_tree().create_timer(0.3).timeout

	if _load_story_by_index(index):
		var title: String = available_stories[index].get("title", "未知")
		var box: String = fs.build_box_sectioned([
			["DISC LOADED", "磁盘加载完成"],
			[title]
		], T.success_hex)
		append_output(box + "\n", false)
		_update_status_bar()
		append_output("[color=" + T.muted_hex + "]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
		append_output("[color=" + T.muted_hex + "]当前路径: " + current_path + "  权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
	else:
		append_output("[color=" + T.error_hex + "][ERROR] 磁盘加载失败。[/color]\n", false)
		fs.init_test_file_system()
		_update_status_bar()

func _cmd_unlock(args: Array) -> void:
	if not args.is_empty():
		_verify_password(args[0])
		return
	_enter_password_mode()

func _enter_password_mode(target_path: String = "") -> void:
	_password_mode = true
	_password_target_path = target_path
	var box: String = fs.build_box_sectioned([
		["SECURITY AUTHENTICATION", "安全认证系统"],
		["请输入访问密码:", "(输入 cancel 取消)"]
	], T.warning_hex)
	append_output(box + "\n", false)
	input_field.placeholder_text = "输入密码..."

func _verify_password(password: String) -> void:
	if not story_manifest.has("passwords"):
		append_output("[color=" + T.error_hex + "][ERROR] 当前剧本未配置密码系统。[/color]\n", false)
		return

	var passwords: Dictionary = story_manifest["passwords"]
	if passwords.has(password):
		var pwd_info: Dictionary = passwords[password]
		var grant_level: int = int(float(pwd_info.get("grants_clearance", 0)))

		if unlocked_passwords.has(password):
			append_output("[color=" + T.muted_hex + "]该密码已使用过。当前权限等级: " + str(fs.player_clearance) + "[/color]\n", false)
			return

		if grant_level <= fs.player_clearance:
			append_output("[color=" + T.muted_hex + "]该密码对应的权限等级不高于当前等级。当前: " + str(fs.player_clearance) + "[/color]\n", false)
			return

		unlocked_passwords.append(password)
		var old_level: int = fs.player_clearance
		fs.player_clearance = grant_level
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

		var box: String = fs.build_box_sectioned([
			["ACCESS GRANTED", "权限认证通过"],
			["权限等级: " + str(old_level) + " -> " + str(fs.player_clearance)]
		], T.success_hex)
		append_output(box + "\n", false)

		if pwd_info.has("message"):
			append_output("[color=" + T.muted_hex + "]" + str(pwd_info["message"]) + "[/color]\n", false)
	else:
		var box: String = fs.build_box(["ACCESS DENIED", "密码验证失败"] as Array[String], T.error_hex)
		append_output(box + "\n", false)

func _verify_file_password(input_password: String) -> void:
	var fp_key: String = fs.get_file_password_key(_file_password_target)
	if fp_key.is_empty():
		append_output("[color=" + T.error_hex + "][ERROR] 内部错误：未找到文件密码配置。[/color]\n", false)
		return

	var fp_info: Dictionary = fs.story_file_passwords[fp_key]
	var correct_password: String = str(fp_info.get("password", ""))

	if input_password == correct_password:
		fs.unlocked_file_passwords.append(_file_password_target)
		save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)

		var box: String = fs.build_box(["PASSWORD ACCEPTED", "文件密码验证通过"] as Array[String], T.success_hex)
		append_output(box + "\n", false)
		while tw.is_typing:
			await get_tree().process_frame
		await get_tree().create_timer(0.5).timeout
		await _cmd_open([_file_password_filename])
	else:
		var box: String = fs.build_box(["PASSWORD REJECTED", "文件密码错误"] as Array[String], T.error_hex)
		append_output(box + "\n", false)

func _cmd_scan() -> void:
	append_output("[color=" + T.muted_hex + "]正在扫描vdisc目录...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await tw.show_progress_bar(500)
	await get_tree().create_timer(0.3).timeout

	var old_story_path: String = current_story_path
	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	read_files.clear()
	unlocked_passwords.clear()
	available_stories.clear()
	current_story_index = -1

	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	if _desktop_mode:
		if available_stories.is_empty():
			append_output("[color=" + T.warning_hex + "][WARN] 未找到虚拟磁盘文件。[/color]", false)
			append_output("[color=" + T.muted_hex + "]请将 .scp 文件放入 vdisc/ 目录后重新扫描。[/color]\n", false)
		else:
			var scan_lines: Array[String] = []
			scan_lines.append("[color=" + T.success_hex + "][OK] 扫描完成，发现 " + str(available_stories.size()) + " 个虚拟磁盘。[/color]")
			scan_lines.append("")
			for i in range(available_stories.size()):
				var info: Dictionary = available_stories[i]
				scan_lines.append("  [color=" + T.warning_hex + "]" + str(i + 1) + ".[/color] " + info.get("title", "未知") + " [color=" + T.muted_hex + "](" + info.get("filename", "") + ")[/color]")
			scan_lines.append("")
			scan_lines.append("[color=" + T.muted_hex + "]输入 [/color][color=" + T.primary_hex + "]load <编号>[/color][color=" + T.muted_hex + "] 加载磁盘。[/color]")
			append_output("\n".join(scan_lines) + "\n", false)
		_update_status_bar()
	else:
		if available_stories.is_empty():
			_desktop_mode = true
			fs.init_test_file_system()
			current_path = "/"
			_update_status_bar()
			append_output("[color=" + T.warning_hex + "][WARN] 未找到剧本文件，已返回桌面。[/color]\n", false)
		elif _load_story_by_index(0):
			var title: String = "未知"
			if story_manifest.has("story") and story_manifest["story"].has("title"):
				title = story_manifest["story"]["title"]
			append_output("[color=" + T.success_hex + "][OK] 已重新加载剧本: " + title + "[/color]", false)
			append_output("[color=" + T.muted_hex + "]文件数量: " + str(fs.file_system.size()) + "  权限规则: " + str(fs.story_permissions.size()) + " 条[/color]\n", false)
			if story_manifest.has("settings") and story_manifest["settings"].has("start_path"):
				current_path = story_manifest["settings"]["start_path"]
			else:
				current_path = "/"
			_update_status_bar()
		else:
			append_output("[color=" + T.error_hex + "][ERROR] 重新加载失败。[/color]\n", false)

func _cmd_reboot() -> void:
	append_output("[color=" + T.muted_hex + "]正在重启终端...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.5).timeout

	output_text.text = ""
	tw.clear_queue()
	command_history.clear()
	history_index = -1

	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	has_new_mail = false
	read_files.clear()
	unlocked_passwords.clear()
	available_stories.clear()
	current_story_index = -1

	save_mgr.ensure_stories_dir()
	var vdisc_dir: String = save_mgr.get_game_root_dir() + "vdisc/"
	_scan_available_stories(vdisc_dir)

	output_text.append_text("[color=" + T.muted_hex + "]...[/color]\n")
	await get_tree().create_timer(0.3).timeout
	output_text.append_text("[color=" + T.muted_hex + "]终端系统重新初始化中...[/color]\n")
	await get_tree().create_timer(0.5).timeout

	output_text.text = ""
	_desktop_mode = true
	_update_status_bar()
	_show_desktop_welcome()
	input_field.grab_focus()

# ============================================================
# 输出工具（转发到打字机模块）
# ============================================================
func append_output(text: String, extra_newline: bool = true) -> void:
	tw.append(text, extra_newline)

# ============================================================
# 每帧处理（滚动）
# ============================================================
func _process(_delta: float) -> void:
	tw.process_scroll()

# ============================================================
# 状态栏更新
# ============================================================
func _update_status_bar() -> void:
	if _desktop_mode:
		path_label.text = "[DESKTOP]  " + str(available_stories.size()) + " disc(s) found"
		mail_icon.text = "[Mail]"
		return

	var disc_name: String = ""
	if current_story_index >= 0 and current_story_index < available_stories.size():
		disc_name = available_stories[current_story_index].get("title", "")

	if disc_name.is_empty():
		path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance)
	else:
		path_label.text = "[" + current_path + "]  LV:" + str(fs.player_clearance) + "  DISC:" + disc_name

	if has_new_mail:
		mail_icon.text = "[Mail NEW]"
	else:
		mail_icon.text = "[Mail]"

# ============================================================
# 超链接处理
# ============================================================
func _on_meta_clicked(meta: Variant) -> void:
	var meta_str: String = str(meta)

	if meta_str.begins_with("cmd://"):
		var cmd: String = meta_str.substr(6)
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> " + cmd)
		output_text.append_text("\n")
		_execute_command(cmd)
		return

	if meta_str.begins_with("file://"):
		var file_path: String = meta_str.substr(7)
		if output_text.get_parsed_text().length() > 0:
			output_text.append_text("\n")
		output_text.append_text("> open " + file_path)
		output_text.append_text("\n")
		await _cmd_open([file_path])
		return

	print("[Terminal] 未知链接: " + meta_str)

# ============================================================
# 桌面模式
# ============================================================
func _show_desktop_welcome() -> void:
	var p: String = T.primary_hex
	var w: String = T.warning_hex
	var m: String = T.muted_hex

	var title: String = "SCP FOUNDATION TERMINAL v0.1"
	var subtitle: String = "SECURE - CONTAIN - PROTECT"
	var box: String = fs.build_box([title, subtitle] as Array[String], p)
	output_text.append_text(box + "\n\n")

	if available_stories.is_empty():
		output_text.append_text("[color=" + w + "]未检测到虚拟磁盘。[/color]\n")
		output_text.append_text("[color=" + m + "]请将 .scp 文件放入 vdisc/ 目录后输入 scan 重新扫描。[/color]\n\n")
	else:
		output_text.append_text("[color=" + p + "]检测到 " + str(available_stories.size()) + " 个虚拟磁盘:[/color]\n\n")
		for i in range(available_stories.size()):
			var info: Dictionary = available_stories[i]
			output_text.append_text("  [color=" + w + "]" + str(i + 1) + ".[/color] [color=" + p + "]" + info.get("title", "未知") + "[/color]\n")
			output_text.append_text("     [color=" + m + "]" + info.get("author", "未知") + " | " + info.get("filename", "") + "[/color]\n")
		output_text.append_text("\n")

	output_text.append_text("[color=" + m + "]可用命令:[/color]\n")
	output_text.append_text("  [color=" + p + "]load <编号>[/color]   加载指定磁盘\n")
	output_text.append_text("  [color=" + p + "]scan[/color]   重新扫描磁盘目录\n")
	output_text.append_text("  [color=" + p + "]clear[/color] 清空屏幕\n")
	output_text.append_text("  [color=" + p + "]exit[/color]   退出终端\n")

func _cmd_desktop_load(args: Array) -> void:
	if args.is_empty():
		append_output("[color=" + T.error_hex + "][ERROR] 用法: load <编号>[/color]", false)
		if available_stories.size() > 0:
			append_output("[color=" + T.muted_hex + "]可用磁盘: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return

	var index_str: String = args[0]
	if not index_str.is_valid_int():
		append_output("[color=" + T.error_hex + "][ERROR] 请输入有效的编号数字。[/color]\n", false)
		return

	var index: int = index_str.to_int() - 1
	if index < 0 or index >= available_stories.size():
		append_output("[color=" + T.error_hex + "][ERROR] 编号超出范围。可用范围: 1-" + str(available_stories.size()) + "[/color]\n", false)
		return

	append_output("[color=" + T.muted_hex + "]正在加载虚拟磁盘...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await tw.show_progress_bar(800)
	await get_tree().create_timer(0.3).timeout

	if _load_story_by_index(index):
		_desktop_mode = false
		var title: String = available_stories[index].get("title", "未知")
		output_text.text = ""
		tw.clear_queue()
		_update_status_bar()
		_show_welcome_message()
	else:
		append_output("[color=" + T.error_hex + "][ERROR] 磁盘加载失败。[/color]\n", false)

func _cmd_eject() -> void:
	if _desktop_mode:
		append_output("[color=" + T.muted_hex + "]当前已在桌面模式。[/color]\n", false)
		return

	save_mgr.auto_save(story_id, fs.player_clearance, read_files, unlocked_passwords, fs.unlocked_file_passwords, current_path)
	append_output("[color=" + T.muted_hex + "]正在卸载磁盘...[/color]", false)
	while tw.is_typing:
		await get_tree().process_frame
	await get_tree().create_timer(0.5).timeout

	fs.clear_all()
	story_manifest.clear()
	current_story_path = ""
	story_id = ""
	current_path = "/"
	read_files.clear()
	unlocked_passwords.clear()
	current_story_index = -1

	_desktop_mode = true
	output_text.text = ""
	tw.clear_queue()
	_update_status_bar()
	_show_desktop_welcome()

# ============================================================
# 欢迎信息
# ============================================================
func _show_welcome_message() -> void:
	var p: String = T.primary_hex
	var m: String = T.muted_hex

	var title: String = "SCP FOUNDATION TERMINAL v0.1"
	var subtitle: String = "SECURE - CONTAIN - PROTECT"
	if story_manifest.has("story"):
		var story_info: Dictionary = story_manifest["story"]
		if story_info.has("title"):
			subtitle = story_info["title"]

	var title_display_len: int = fs.display_width(title)
	var subtitle_display_len: int = fs.display_width(subtitle)
	var inner_width: int = max(title_display_len, subtitle_display_len) + 6

	var title_pad_total: int = inner_width - title_display_len
	var title_pad_left: int = title_pad_total / 2
	var title_pad_right: int = title_pad_total - title_pad_left

	var subtitle_pad_total: int = inner_width - subtitle_display_len
	var subtitle_pad_left: int = subtitle_pad_total / 2
	var subtitle_pad_right: int = subtitle_pad_total - subtitle_pad_left

	var border_h: String = "═".repeat(inner_width)

	var welcome: String = ""
	welcome += "[color=" + p + "]╔" + border_h + "╗\n"
	welcome += "║" + " ".repeat(title_pad_left) + title + " ".repeat(title_pad_right) + "║\n"
	welcome += "║" + " ".repeat(subtitle_pad_left) + subtitle + " ".repeat(subtitle_pad_right) + "║\n"
	welcome += "╚" + border_h + "╝[/color]\n"
	welcome += "\n"
	welcome += "[color=" + m + "]终端系统已启动。\n"
	welcome += "输入 [/color][color=" + p + "]help[/color][color=" + m + "] 查看可用命令。[/color]\n"
	output_text.append_text(welcome)

### USER
继续补完代码

### ASSISTANT


### USER
继续补完代码

### ASSISTANT